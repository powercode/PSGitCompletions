using System;
using System.Linq;

namespace PowerCode
{
    public class GitCommand
    {
        public static GitCommand[] Commands =
        {
            #region Commands
            			new GitCommand("add", "Add file contents to the index",
@"git add [--verbose | -v] [--dry-run | -n] [--force | -f] [--interactive | -i] [--patch | -p]
          [--edit | -e] [--[no-]all | --[no-]ignore-removal | [--update | -u]] [--sparse]
          [--intent-to-add | -N] [--refresh] [--ignore-errors] [--ignore-missing] [--renormalize]
          [--chmod=(+|-)x] [--pathspec-from-file=<file> [--pathspec-file-nul]]
          [--] [<pathspec>…​]",
		@"This command updates the index using the current content found in
the working tree, to prepare the content staged for the next commit.
It typically adds the current content of existing paths as a whole,
but with some options it can also be used to add content with
only part of the changes made to the working tree files applied, or
remove paths that do not exist in the working tree anymore.

The ""index"" holds a snapshot of the content of the working tree, and it
is this snapshot that is taken as the contents of the next commit.  Thus
after making any changes to the working tree, and before running
the commit command, you must use the add command to add any new or
modified files to the index.

This command can be performed multiple times before a commit.  It only
adds the content of the specified file(s) at the time the add command is
run; if you want subsequent changes included in the next commit, then
you must run git add again to add the new content to the index."),
			new GitCommand("am", "Apply a series of patches from a mailbox",
@"git am [--signoff] [--keep] [--[no-]keep-cr] [--[no-]utf8]
         [--[no-]3way] [--interactive] [--committer-date-is-author-date]
         [--ignore-date] [--ignore-space-change | --ignore-whitespace]
         [--whitespace=<option>] [-C<n>] [-p<n>] [--directory=<dir>]
         [--exclude=<path>] [--include=<path>] [--reject] [-q | --quiet]
         [--[no-]scissors] [-S[<keyid>]] [--patch-format=<format>]
         [--quoted-cr=<action>]
         [--empty=(stop|drop|keep)]
         [(<mbox> | <Maildir>)…​]
git am (--continue | --skip | --abort | --quit | --show-current-patch[=(diff|raw)] | --allow-empty)",
		@"Splits mail messages in a mailbox into commit log message,
authorship information and patches, and applies them to the
current branch."),
			new GitCommand("annotate", "Annotate file lines with commit information",
@"git annotate [<options>] <file> [<revision>]",
		@"Annotates each line in the given file with information from the commit
which introduced the line. Optionally annotates from a given revision.

The only difference between this command and git-blame(1) is that
they use slightly different output formats, and this command exists only
for backward compatibility to support existing scripts, and provide a more
familiar command name for people coming from other SCM systems."),
			new GitCommand("apply", "Apply a patch to files and/or to the index",
@"git apply [--stat] [--numstat] [--summary] [--check] [--index | --intent-to-add] [--3way]
          [--apply] [--no-add] [--build-fake-ancestor=<file>] [-R | --reverse]
          [--allow-binary-replacement | --binary] [--reject] [-z]
          [-p<n>] [-C<n>] [--inaccurate-eof] [--recount] [--cached]
          [--ignore-space-change | --ignore-whitespace]
          [--whitespace=(nowarn|warn|fix|error|error-all)]
          [--exclude=<path>] [--include=<path>] [--directory=<root>]
          [--verbose | --quiet] [--unsafe-paths] [--allow-empty] [<patch>…​]",
		@"Reads the supplied diff output (i.e. ""a patch"") and applies it to files.
When running from a subdirectory in a repository, patched paths
outside the directory are ignored.
With the --index option the patch is also applied to the index, and
with the --cached option the patch is only applied to the index.
Without these options, the command applies the patch only to files,
and does not require them to be in a Git repository.

This command applies the patch but does not create a commit.  Use
git-am(1) to create commits from patches generated by
git-format-patch(1) and/or received by email."),
			new GitCommand("archive", "Create an archive of files from a named tree",
@"git archive [--format=<fmt>] [--list] [--prefix=<prefix>/] [<extra>]
              [-o <file> | --output=<file>] [--worktree-attributes]
              [--remote=<repo> [--exec=<git-upload-archive>]] <tree-ish>
              [<path>…​]",
		@"Creates an archive of the specified format containing the tree
structure for the named tree, and writes it out to the standard
output.  If <prefix> is specified it is
prepended to the filenames in the archive.

git archive behaves differently when given a tree ID versus when
given a commit ID or tag ID.  In the first case the current time is
used as the modification time of each file in the archive.  In the latter
case the commit time as recorded in the referenced commit object is
used instead.  Additionally the commit ID is stored in a global
extended pax header if the tar format is used; it can be extracted
using git get-tar-commit-id. In ZIP files it is stored as a file
comment."),
			new GitCommand("bash", "A Windows-specific wrapper to open a Git Bash window",
@"git-bash [--cd-to-home] [--cd=<directory>] [--minimal-search-path]
    [--command=<path>] [--app-id=<id>] [<args>…​]",
		@"This command opens a window with an interactive Git Bash. It is specific to the
Git for Windows project.

By default, this will open a MinTTY window, but it can be configured in Git for
Windows' installer to use Windows' default Console window instead.

Before starting the interactive Bash session, the environment is adjusted a
bit. For example, the PATH is adjusted to find the git executable, and
git-bash will ensure that HOME is set (because it is expected to be present
by Git, and to point to the current user’s home directory). See the
ENVIRONMENT VARIABLES section below for more information."),
			new GitCommand("bisect", "Use binary search to find the commit that introduced a bug",
@"git bisect <subcommand> <options>",
		@"The command takes various subcommands, and different options depending
on the subcommand:


git bisect start [--term-{new,bad}=<term> --term-{old,good}=<term>]
	  [--no-checkout] [--first-parent] [<bad> [<good>...]] [--] [<paths>...]
git bisect (bad|new|<term-new>) [<rev>]
git bisect (good|old|<term-old>) [<rev>...]
git bisect terms [--term-good | --term-bad]
git bisect skip [(<rev>|<range>)...]
git bisect reset [<commit>]
git bisect (visualize|view)
git bisect replay <logfile>
git bisect log
git bisect run <cmd>...
git bisect help"),
			new GitCommand("blame", "Show what revision and author last modified each line of a file",
@"git blame [-c] [-b] [-l] [--root] [-t] [-f] [-n] [-s] [-e] [-p] [-w] [--incremental]
            [-L <range>] [-S <revs-file>] [-M] [-C] [-C] [-C] [--since=<date>]
            [--ignore-rev <rev>] [--ignore-revs-file <file>]
            [--color-lines] [--color-by-age] [--progress] [--abbrev=<n>]
            [<rev> | --contents <file> | --reverse <rev>..<rev>] [--] <file>",
		@"Annotates each line in the given file with information from the revision which
last modified the line. Optionally, start annotating from the given revision.

When specified one or more times, -L restricts annotation to the requested
lines.

The origin of lines is automatically followed across whole-file
renames (currently there is no option to turn the rename-following
off). To follow lines moved from one file to another, or to follow
lines that were copied and pasted from another file, etc., see the
-C and -M options.

The report does not tell you anything about lines which have been deleted or
replaced; you need to use a tool such as git diff or the ""pickaxe""
interface briefly mentioned in the following paragraph."),
			new GitCommand("branch", "List, create, or delete branches",
@"git branch [--color[=<when>] | --no-color] [--show-current]
        [-v [--abbrev=<n> | --no-abbrev]]
        [--column[=<options>] | --no-column] [--sort=<key>]
        [--merged [<commit>]] [--no-merged [<commit>]]
        [--contains [<commit>]] [--no-contains [<commit>]]
        [--points-at <object>] [--format=<format>]
        [(-r | --remotes) | (-a | --all)]
        [--list] [<pattern>…​]
git branch [--track[=(direct|inherit)] | --no-track] [-f]
        [--recurse-submodules] <branchname> [<start-point>]
git branch (--set-upstream-to=<upstream> | -u <upstream>) [<branchname>]
git branch --unset-upstream [<branchname>]
git branch (-m | -M) [<oldbranch>] <newbranch>
git branch (-c | -C) [<oldbranch>] <newbranch>
git branch (-d | -D) [-r] <branchname>…​
git branch --edit-description [<branchname>]",
		@"If --list is given, or if there are no non-option arguments, existing
branches are listed; the current branch will be highlighted in green and
marked with an asterisk.  Any branches checked out in linked worktrees will
be highlighted in cyan and marked with a plus sign. Option -r causes the
remote-tracking branches to be listed,
and option -a shows both local and remote branches.

If a <pattern>
is given, it is used as a shell wildcard to restrict the output to
matching branches. If multiple patterns are given, a branch is shown if
it matches any of the patterns.

Note that when providing a
<pattern>, you must use --list; otherwise the command may be interpreted
as branch creation."),
			new GitCommand("bugreport", "Collect information for user to file a bug report",
@"git bugreport [(-o | --output-directory) <path>] [(-s | --suffix) <format>]",
		@"Captures information about the user’s machine, Git client, and repository state,
as well as a form requesting information about the behavior the user observed,
into a single text file which the user can then share, for example to the Git
mailing list, in order to report an observed bug.

The following information is requested from the user:



Reproduction steps


Expected behavior


Actual behavior



The following information is captured automatically:



git version --build-options


uname sysname, release, version, and machine strings


Compiler-specific info string


A list of enabled hooks


$SHELL



This tool is invoked via the typical Git setup process, which means that in some
cases, it might not be able to launch - for example, if a relevant config file
is unreadable. In this kind of scenario, it may be helpful to manually gather
the kind of information listed above when manually asking for help."),
			new GitCommand("bundle", "Move objects and refs by archive",
@"git bundle create [-q | --quiet | --progress | --all-progress] [--all-progress-implied]
                    [--version=<version>] <file> <git-rev-list-args>
git bundle verify [-q | --quiet] <file>
git bundle list-heads <file> [<refname>…​]
git bundle unbundle [--progress] <file> [<refname>…​]",
		@"Create, unpack, and manipulate ""bundle"" files. Bundles are used for
the ""offline"" transfer of Git objects without an active ""server""
sitting on the other side of the network connection.

They can be used to create both incremental and full backups of a
repository, and to relay the state of the references in one repository
to another.

Git commands that fetch or otherwise ""read"" via protocols such as
ssh:// and https:// can also operate on bundle files. It is
possible git-clone(1) a new repository from a bundle, to use
git-fetch(1) to fetch from one, and to list the references
contained within it with git-ls-remote(1). There’s no
corresponding ""write"" support, i.e.a git push into a bundle is not
supported.

See the ""EXAMPLES"" section below for examples of how to use bundles."),
			new GitCommand("cat-file", "Provide content or type and size information for repository objects",
@"git cat-file <type> <object>
git cat-file (-e | -p) <object>
git cat-file (-t | -s) [--allow-unknown-type] <object>
git cat-file (--batch | --batch-check | --batch-command) [--batch-all-objects]
             [--buffer] [--follow-symlinks] [--unordered]
             [--textconv | --filters]
git cat-file (--textconv | --filters)
             [<rev>:<path|tree-ish> | --path=<path|tree-ish> <rev>]",
		@"In its first form, the command provides the content or the type of an object in
the repository. The type is required unless -t or -p is used to find the
object type, or -s is used to find the object size, or --textconv or
--filters is used (which imply type ""blob"").

In the second form, a list of objects (separated by linefeeds) is provided on
stdin, and the SHA-1, type, and size of each object is printed on stdout. The
output format can be overridden using the optional <format> argument. If
either --textconv or --filters was specified, the input is expected to
list the object names followed by the path name, separated by a single
whitespace, so that the appropriate drivers can be determined."),
			new GitCommand("check-attr", "Display gitattributes information",
@"git check-attr [-a | --all | <attr>…​] [--] <pathname>…​
git check-attr --stdin [-z] [-a | --all | <attr>…​]",
		@"For every pathname, this command will list if each attribute is unspecified,
set, or unset as a gitattribute on that pathname."),
			new GitCommand("check-ignore", "Debug gitignore / exclude files",
@"git check-ignore [<options>] <pathname>…​
git check-ignore [<options>] --stdin",
		@"For each pathname given via the command-line or from a file via
--stdin, check whether the file is excluded by .gitignore (or other
input files to the exclude mechanism) and output the path if it is
excluded.

By default, tracked files are not shown at all since they are not
subject to exclude rules; but see ‘--no-index’."),
			new GitCommand("check-mailmap", "Show canonical names and email addresses of contacts",
@"git check-mailmap [<options>] <contact>…​",
		@"For each “Name <user@host>” or “<user@host>” from the command-line
or standard input (when using --stdin), look up the person’s canonical name
and email address (see ""Mapping Authors"" below). If found, print them;
otherwise print the input as-is."),
			new GitCommand("check-ref-format", "Ensures that a reference name is well formed",
@"git check-ref-format [--normalize]
       [--[no-]allow-onelevel] [--refspec-pattern]
       <refname>
git check-ref-format --branch <branchname-shorthand>",
		@"Checks if a given refname is acceptable, and exits with a non-zero
status if it is not.

A reference is used in Git to specify branches and tags.  A
branch head is stored in the refs/heads hierarchy, while
a tag is stored in the refs/tags hierarchy of the ref namespace
(typically in $GIT_DIR/refs/heads and $GIT_DIR/refs/tags
directories or, as entries in file $GIT_DIR/packed-refs
if refs are packed by git gc).

Git imposes the following rules on how references are named:"),
			new GitCommand("checkout-index", "Copy files from the index to the working tree",
@"git checkout-index [-u] [-q] [-a] [-f] [-n] [--prefix=<string>]
                   [--stage=<number>|all]
                   [--temp]
                   [--ignore-skip-worktree-bits]
                   [-z] [--stdin]
                   [--] [<file>…​]",
		@"Will copy all files listed from the index to the working directory
(not overwriting existing files)."),
			new GitCommand("checkout", "Switch branches or restore working tree files",
@"git checkout [-q] [-f] [-m] [<branch>]
git checkout [-q] [-f] [-m] --detach [<branch>]
git checkout [-q] [-f] [-m] [--detach] <commit>
git checkout [-q] [-f] [-m] [[-b|-B|--orphan] <new-branch>] [<start-point>]
git checkout [-f|--ours|--theirs|-m|--conflict=<style>] [<tree-ish>] [--] <pathspec>…​
git checkout [-f|--ours|--theirs|-m|--conflict=<style>] [<tree-ish>] --pathspec-from-file=<file> [--pathspec-file-nul]
git checkout (-p|--patch) [<tree-ish>] [--] [<pathspec>…​]",
		@"Updates files in the working tree to match the version in the index
or the specified tree.  If no pathspec was given, git checkout will
also update HEAD to set the specified branch as the current
branch."),
			new GitCommand("cherry-pick", "Apply the changes introduced by some existing commits",
@"git cherry-pick [--edit] [-n] [-m <parent-number>] [-s] [-x] [--ff]
                  [-S[<keyid>]] <commit>…​
git cherry-pick (--continue | --skip | --abort | --quit)",
		@"Given one or more existing commits, apply the change each one
introduces, recording a new commit for each.  This requires your
working tree to be clean (no modifications from the HEAD commit).

When it is not obvious how to apply a change, the following
happens:



The current branch and HEAD pointer stay at the last commit
successfully made.


The CHERRY_PICK_HEAD ref is set to point at the commit that
introduced the change that is difficult to apply.


Paths in which the change applied cleanly are updated both
in the index file and in your working tree.


For conflicting paths, the index file records up to three
versions, as described in the ""TRUE MERGE"" section of
git-merge(1).  The working tree files will include
a description of the conflict bracketed by the usual
conflict markers <<<<<<< and >>>>>>>.


No other modifications are made.



See git-merge(1) for some hints on resolving such
conflicts."),
			new GitCommand("cherry", "Find commits yet to be applied to upstream",
@"git cherry [-v] [<upstream> [<head> [<limit>]]]",
		@"Determine whether there are commits in <head>..<upstream> that are
equivalent to those in the range <limit>..<head>.

The equivalence test is based on the diff, after removing whitespace
and line numbers.  git-cherry therefore detects when commits have been
""copied"" by means of git-cherry-pick(1), git-am(1) or
git-rebase(1).

Outputs the SHA1 of every commit in <limit>..<head>, prefixed with
- for commits that have an equivalent in <upstream>, and + for
commits that do not."),
			new GitCommand("citool", "Graphical alternative to git-commit",
@"git citool",
		@"A Tcl/Tk based graphical interface to review modified files, stage
them into the index, enter a commit message and record the new
commit onto the current branch.  This interface is an alternative
to the less interactive git commit program.

git citool is actually a standard alias for git gui citool.
See git-gui(1) for more details."),
			new GitCommand("clean", "Remove untracked files from the working tree",
@"git clean [-d] [-f] [-i] [-n] [-q] [-e <pattern>] [-x | -X] [--] <path>…​",
		@"Cleans the working tree by recursively removing files that are not
under version control, starting from the current directory.

Normally, only files unknown to Git are removed, but if the -x
option is specified, ignored files are also removed. This can, for
example, be useful to remove all build products.

If any optional <path>... arguments are given, only those paths
are affected."),
			new GitCommand("clone", "Clone a repository into a new directory",
@"git clone [--template=<template-directory>]
          [-l] [-s] [--no-hardlinks] [-q] [-n] [--bare] [--mirror]
          [-o <name>] [-b <name>] [-u <upload-pack>] [--reference <repository>]
          [--dissociate] [--separate-git-dir <git-dir>]
          [--depth <depth>] [--[no-]single-branch] [--no-tags]
          [--recurse-submodules[=<pathspec>]] [--[no-]shallow-submodules]
          [--[no-]remote-submodules] [--jobs <n>] [--sparse] [--[no-]reject-shallow]
          [--filter=<filter> [--also-filter-submodules]] [--] <repository>
          [<directory>]",
		@"Clones a repository into a newly created directory, creates
remote-tracking branches for each branch in the cloned repository
(visible using git branch --remotes), and creates and checks out an
initial branch that is forked from the cloned repository’s
currently active branch.

After the clone, a plain git fetch without arguments will update
all the remote-tracking branches, and a git pull without
arguments will in addition merge the remote master branch into the
current master branch, if any (this is untrue when ""--single-branch""
is given; see below).

This default configuration is achieved by creating references to
the remote branch heads under refs/remotes/origin and
by initializing remote.origin.url and remote.origin.fetch
configuration variables."),
			new GitCommand("column", "Display data in columns",
@"git column [--command=<name>] [--[raw-]mode=<mode>] [--width=<width>]
             [--indent=<string>] [--nl=<string>] [--padding=<n>]",
		@"This command formats the lines of its standard input into a table with
multiple columns. Each input line occupies one cell of the table. It
is used internally by other git commands to format output into
columns."),
			new GitCommand("commit-graph", "Write and verify Git commit-graph files",
@"git commit-graph verify [--object-dir <dir>] [--shallow] [--[no-]progress]
git commit-graph write <options> [--object-dir <dir>] [--[no-]progress]",
		@"Manage the serialized commit-graph file."),
			new GitCommand("commit-tree", "Create a new commit object",
@"git commit-tree <tree> [(-p <parent>)…​]
git commit-tree [(-p <parent>)…​] [-S[<keyid>]] [(-m <message>)…​]
                  [(-F <file>)…​] <tree>",
		@"This is usually not what an end user wants to run directly.  See
git-commit(1) instead.

Creates a new commit object based on the provided tree object and
emits the new commit object id on stdout. The log message is read
from the standard input, unless -m or -F options are given.

The -m and -F options can be given any number of times, in any
order. The commit log message will be composed in the order in which
the options are given.

A commit object may have any number of parents. With exactly one
parent, it is an ordinary commit. Having more than one parent makes
the commit a merge between several lines of history. Initial (root)
commits have no parents.

While a tree represents a particular directory state of a working
directory, a commit represents that state in ""time"", and explains how
to get there."),
			new GitCommand("commit", "Record changes to the repository",
@"git commit [-a | --interactive | --patch] [-s] [-v] [-u<mode>] [--amend]
           [--dry-run] [(-c | -C | --squash) <commit> | --fixup [(amend|reword):]<commit>)]
           [-F <file> | -m <msg>] [--reset-author] [--allow-empty]
           [--allow-empty-message] [--no-verify] [-e] [--author=<author>]
           [--date=<date>] [--cleanup=<mode>] [--[no-]status]
           [-i | -o] [--pathspec-from-file=<file> [--pathspec-file-nul]]
           [(--trailer <token>[(=|:)<value>])…​] [-S[<keyid>]]
           [--] [<pathspec>…​]",
		@"Create a new commit containing the current contents of the index and
the given log message describing the changes. The new commit is a
direct child of HEAD, usually the tip of the current branch, and the
branch is updated to point to it (unless no branch is associated with
the working tree, in which case HEAD is ""detached"" as described in
git-checkout(1)).

The content to be committed can be specified in several ways:"),
			new GitCommand("config", "Get and set repository or global options",
@"git config [<file-option>] [--type=<type>] [--fixed-value] [--show-origin] [--show-scope] [-z|--null] <name> [<value> [<value-pattern>]]
git config [<file-option>] [--type=<type>] --add <name> <value>
git config [<file-option>] [--type=<type>] [--fixed-value] --replace-all <name> <value> [<value-pattern>]
git config [<file-option>] [--type=<type>] [--show-origin] [--show-scope] [-z|--null] [--fixed-value] --get <name> [<value-pattern>]
git config [<file-option>] [--type=<type>] [--show-origin] [--show-scope] [-z|--null] [--fixed-value] --get-all <name> [<value-pattern>]
git config [<file-option>] [--type=<type>] [--show-origin] [--show-scope] [-z|--null] [--fixed-value] [--name-only] --get-regexp <name-regex> [<value-pattern>]
git config [<file-option>] [--type=<type>] [-z|--null] --get-urlmatch <name> <URL>
git config [<file-option>] [--fixed-value] --unset <name> [<value-pattern>]
git config [<file-option>] [--fixed-value] --unset-all <name> [<value-pattern>]
git config [<file-option>] --rename-section <old-name> <new-name>
git config [<file-option>] --remove-section <name>
git config [<file-option>] [--show-origin] [--show-scope] [-z|--null] [--name-only] -l | --list
git config [<file-option>] --get-color <name> [<default>]
git config [<file-option>] --get-colorbool <name> [<stdout-is-tty>]
git config [<file-option>] -e | --edit",
		@"You can query/set/replace/unset options with this command. The name is
actually the section and the key separated by a dot, and the value will be
escaped.

Multiple lines can be added to an option by using the --add option.
If you want to update or unset an option which can occur on multiple
lines, a value-pattern (which is an extended regular expression,
unless the --fixed-value option is given) needs to be given.  Only the
existing values that match the pattern are updated or unset.  If
you want to handle the lines that do not match the pattern, just
prepend a single exclamation mark in front (see also EXAMPLES),
but note that this only works when the --fixed-value option is not
in use."),
			new GitCommand("count-objects", "Count unpacked number of objects and their disk consumption",
@"git count-objects [-v] [-H | --human-readable]",
		@"This counts the number of unpacked object files and disk space consumed by
them, to help you decide when it is a good time to repack."),
			new GitCommand("credential-cache--daemon", "Temporarily store user credentials in memory",
@"git credential-cache--daemon [--debug] <socket>",
		@"Note


You probably don’t want to invoke this command yourself; it is
started automatically when you use git-credential-cache(1).




This command listens on the Unix domain socket specified by <socket>
for git-credential-cache clients. Clients may store and retrieve
credentials. Each credential is held for a timeout specified by the
client; once no credentials are held, the daemon exits.

If the --debug option is specified, the daemon does not close its
stderr stream, and may output extra diagnostics to it even after it has
begun listening for clients."),
			new GitCommand("credential-cache", "Helper to temporarily store passwords in memory",
@"git config credential.helper 'cache [<options>]'",
		@"This command caches credentials in memory for use by future Git
programs. The stored credentials never touch the disk, and are forgotten
after a configurable timeout.  The cache is accessible over a Unix
domain socket, restricted to the current user by filesystem permissions.

You probably don’t want to invoke this command directly; it is meant to
be used as a credential helper by other parts of Git. See
gitcredentials(7) or EXAMPLES below."),
			new GitCommand("credential-store", "Helper to store credentials on disk",
@"git config credential.helper 'store [<options>]'",
		@"Note


Using this helper will store your passwords unencrypted on disk,
protected only by filesystem permissions. If this is not an acceptable
security tradeoff, try git-credential-cache(1), or find a helper
that integrates with secure storage provided by your operating system.




This command stores credentials indefinitely on disk for use by future
Git programs.

You probably don’t want to invoke this command directly; it is meant to
be used as a credential helper by other parts of git. See
gitcredentials(7) or EXAMPLES below."),
			new GitCommand("credential", "Retrieve and store user credentials",
@"'git credential' (fill|approve|reject)",
		@"Git has an internal interface for storing and retrieving credentials
from system-specific helpers, as well as prompting the user for
usernames and passwords. The git-credential command exposes this
interface to scripts which may want to retrieve, store, or prompt for
credentials in the same manner as Git. The design of this scriptable
interface models the internal C API; see credential.h for more
background on the concepts.

git-credential takes an ""action"" option on the command-line (one of
fill, approve, or reject) and reads a credential description
on stdin (see INPUT/OUTPUT FORMAT).

If the action is fill, git-credential will attempt to add ""username""
and ""password"" attributes to the description by reading config files,
by contacting any configured credential helpers, or by prompting the
user. The username and password attributes of the credential
description are then printed to stdout together with the attributes
already provided."),
			new GitCommand("daemon", "A really simple server for Git repositories",
@"git daemon [--verbose] [--syslog] [--export-all]
             [--timeout=<n>] [--init-timeout=<n>] [--max-connections=<n>]
             [--strict-paths] [--base-path=<path>] [--base-path-relaxed]
             [--user-path | --user-path=<path>]
             [--interpolated-path=<pathtemplate>]
             [--reuseaddr] [--detach] [--pid-file=<file>]
             [--enable=<service>] [--disable=<service>]
             [--allow-override=<service>] [--forbid-override=<service>]
             [--access-hook=<path>] [--[no-]informative-errors]
             [--inetd |
              [--listen=<host_or_ipaddr>] [--port=<n>]
              [--user=<user> [--group=<group>]]]
             [--log-destination=(stderr|syslog|none)]
             [<directory>…​]",
		@"A really simple TCP Git daemon that normally listens on port ""DEFAULT_GIT_PORT""
aka 9418.  It waits for a connection asking for a service, and will serve
that service if it is enabled.

It verifies that the directory has the magic file ""git-daemon-export-ok"", and
it will refuse to export any Git directory that hasn’t explicitly been marked
for export this way (unless the --export-all parameter is specified). If you
pass some directory paths as git daemon arguments, you can further restrict
the offers to a whitelist comprising of those.

By default, only upload-pack service is enabled, which serves
git fetch-pack and git ls-remote clients, which are invoked
from git fetch, git pull, and git clone.

This is ideally suited for read-only updates, i.e., pulling from
Git repositories.

An upload-archive also exists to serve git archive."),
			new GitCommand("describe", "Give an object a human readable name based on an available ref",
@"git describe [--all] [--tags] [--contains] [--abbrev=<n>] [<commit-ish>…​]
git describe [--all] [--tags] [--contains] [--abbrev=<n>] --dirty[=<mark>]
git describe <blob>",
		@"The command finds the most recent tag that is reachable from a
commit.  If the tag points to the commit, then only the tag is
shown.  Otherwise, it suffixes the tag name with the number of
additional commits on top of the tagged object and the
abbreviated object name of the most recent commit. The result
is a ""human-readable"" object name which can also be used to
identify the commit to other git commands.

By default (without --all or --tags) git describe only shows
annotated tags.  For more information about creating annotated tags
see the -a and -s options to git-tag(1).

If the given object refers to a blob, it will be described
as <commit-ish>:<path>, such that the blob can be found
at <path> in the <commit-ish>, which itself describes the
first commit in which this blob occurs in a reverse revision walk
from HEAD."),
			new GitCommand("diff-files", "Compares files in the working tree and the index",
@"git diff-files [-q] [-0|-1|-2|-3|-c|--cc] [<common-diff-options>] [<path>…​]",
		@"Compares the files in the working tree and the index.  When paths
are specified, compares only those named paths.  Otherwise all
entries in the index are compared.  The output format is the
same as for git diff-index and git diff-tree."),
			new GitCommand("diff-index", "Compare a tree to the working tree or index",
@"git diff-index [-m] [--cached] [--merge-base] [<common-diff-options>] <tree-ish> [<path>…​]",
		@"Compares the content and mode of the blobs found in a tree object
with the corresponding tracked files in the working tree, or with the
corresponding paths in the index.  When <path> arguments are present,
compares only paths matching those patterns.  Otherwise all tracked
files are compared."),
			new GitCommand("diff-tree", "Compares the content and mode of blobs found via two tree objects",
@"git diff-tree [--stdin] [-m] [-s] [-v] [--no-commit-id] [--pretty]
              [-t] [-r] [-c | --cc] [--combined-all-paths] [--root] [--merge-base]
              [<common-diff-options>] <tree-ish> [<tree-ish>] [<path>…​]",
		@"Compares the content and mode of the blobs found via two tree objects.

If there is only one <tree-ish> given, the commit is compared with its parents
(see --stdin below).

Note that git diff-tree can use the tree encapsulated in a commit object."),
			new GitCommand("diff", "Show changes between commits, commit and working tree, etc",
@"git diff [<options>] [<commit>] [--] [<path>…​]
git diff [<options>] --cached [--merge-base] [<commit>] [--] [<path>…​]
git diff [<options>] [--merge-base] <commit> [<commit>…​] <commit> [--] [<path>…​]
git diff [<options>] <commit>…​<commit> [--] [<path>…​]
git diff [<options>] <blob> <blob>
git diff [<options>] --no-index [--] <path> <path>",
		@"Show changes between the working tree and the index or a tree, changes
between the index and a tree, changes between two trees, changes resulting
from a merge, changes between two blob objects, or changes between two
files on disk."),
			new GitCommand("difftool", "Show changes using common diff tools",
@"git difftool [<options>] [<commit> [<commit>]] [--] [<path>…​]",
		@"git difftool is a Git command that allows you to compare and edit files
between revisions using common diff tools.  git difftool is a frontend
to git diff and accepts the same options and arguments. See
git-diff(1)."),
			new GitCommand("fast-export", "Git data exporter",
@"git fast-export [<options>] | git fast-import",
		@"This program dumps the given revisions in a form suitable to be piped
into git fast-import.

You can use it as a human-readable bundle replacement (see
git-bundle(1)), or as a format that can be edited before being
fed to git fast-import in order to do history rewrites (an ability
relied on by tools like git filter-repo)."),
			new GitCommand("fast-import", "Backend for fast Git data importers",
@"frontend | git fast-import [<options>]",
		@"This program is usually not what the end user wants to run directly.
Most end users want to use one of the existing frontend programs,
which parses a specific type of foreign source and feeds the contents
stored there to git fast-import.

fast-import reads a mixed command/data stream from standard input and
writes one or more packfiles directly into the current repository.
When EOF is received on standard input, fast import writes out
updated branch and tag refs, fully updating the current repository
with the newly imported data.

The fast-import backend itself can import into an empty repository (one that
has already been initialized by git init) or incrementally
update an existing populated repository.  Whether or not incremental
imports are supported from a particular foreign source depends on
the frontend program in use."),
			new GitCommand("fetch-pack", "Receive missing objects from another repository",
@"git fetch-pack [--all] [--quiet|-q] [--keep|-k] [--thin] [--include-tag]
        [--upload-pack=<git-upload-pack>]
        [--depth=<n>] [--no-progress]
        [-v] <repository> [<refs>…​]",
		@"Usually you would want to use git fetch, which is a
higher level wrapper of this command, instead.

Invokes git-upload-pack on a possibly remote repository
and asks it to send objects missing from this repository, to
update the named heads.  The list of commits available locally
is found out by scanning the local refs/ hierarchy and sent to
git-upload-pack running on the other end.

This command degenerates to download everything to complete the
asked refs from the remote side when the local side does not
have a common ancestor commit."),
			new GitCommand("fetch", "Download objects and refs from another repository",
@"git fetch [<options>] [<repository> [<refspec>…​]]
git fetch [<options>] <group>
git fetch --multiple [<options>] [(<repository> | <group>)…​]
git fetch --all [<options>]",
		@"Fetch branches and/or tags (collectively, ""refs"") from one or more
other repositories, along with the objects necessary to complete their
histories.  Remote-tracking branches are updated (see the description
of <refspec> below for ways to control this behavior).

By default, any tag that points into the histories being fetched is
also fetched; the effect is to fetch tags that
point at branches that you are interested in.  This default behavior
can be changed by using the --tags or --no-tags options or by
configuring remote.<name>.tagOpt.  By using a refspec that fetches tags
explicitly, you can fetch tags that do not point into branches you
are interested in as well.

git fetch can fetch from either a single named repository or URL,
or from several repositories at once if <group> is given and
there is a remotes.<group> entry in the configuration file.
(See git-config(1))."),
			new GitCommand("filter-branch", "Rewrite branches",
@"git filter-branch [--setup <command>] [--subdirectory-filter <directory>]
        [--env-filter <command>] [--tree-filter <command>]
        [--index-filter <command>] [--parent-filter <command>]
        [--msg-filter <command>] [--commit-filter <command>]
        [--tag-name-filter <command>] [--prune-empty]
        [--original <namespace>] [-d <directory>] [-f | --force]
        [--state-branch <branch>] [--] [<rev-list options>…​]",
		@"Lets you rewrite Git revision history by rewriting the branches mentioned
in the <rev-list options>, applying custom filters on each revision.
Those filters can modify each tree (e.g. removing a file or running
a perl rewrite on all files) or information about each commit.
Otherwise, all information (including original commit times or merge
information) will be preserved.

The command will only rewrite the positive refs mentioned in the
command line (e.g. if you pass a..b, only b will be rewritten).
If you specify no filters, the commits will be recommitted without any
changes, which would normally have no effect.  Nevertheless, this may be
useful in the future for compensating for some Git bugs or such,
therefore such a usage is permitted.

NOTE: This command honors .git/info/grafts file and refs in
the refs/replace/ namespace.
If you have any grafts or replacement refs defined, running this command
will make them permanent."),
			new GitCommand("fmt-merge-msg", "Produce a merge commit message",
@"git fmt-merge-msg [-m <message>] [--into-name <branch>] [--log[=<n>] | --no-log]
git fmt-merge-msg [-m <message>] [--log[=<n>] | --no-log] -F <file>",
		@"Takes the list of merged objects on stdin and produces a suitable
commit message to be used for the merge commit, usually to be
passed as the <merge-message> argument of git merge.

This command is intended mostly for internal use by scripts
automatically invoking git merge."),
			new GitCommand("for-each-ref", "Output information on each ref",
@"git for-each-ref [--count=<count>] [--shell|--perl|--python|--tcl]
                   [(--sort=<key>)…​] [--format=<format>] [<pattern>…​]
                   [--points-at=<object>]
                   [--merged[=<object>]] [--no-merged[=<object>]]
                   [--contains[=<object>]] [--no-contains[=<object>]]",
		@"Iterate over all refs that match <pattern> and show them
according to the given <format>, after sorting them according
to the given set of <key>.  If <count> is given, stop after
showing that many refs.  The interpolated values in <format>
can optionally be quoted as string literals in the specified
host language allowing their direct evaluation in that language."),
			new GitCommand("for-each-repo", "Run a Git command on a list of repositories",
@"git for-each-repo --config=<config> [--] <arguments>",
		@"Run a Git command on a list of repositories. The arguments after the
known options or -- indicator are used as the arguments for the Git
subprocess.

THIS COMMAND IS EXPERIMENTAL. THE BEHAVIOR MAY CHANGE.

For example, we could run maintenance on each of a list of repositories
stored in a maintenance.repo config variable using


git for-each-repo --config=maintenance.repo maintenance run


This will run git -C <repo> maintenance run for each value <repo>
in the multi-valued config variable maintenance.repo."),
			new GitCommand("format-patch", "Prepare patches for e-mail submission",
@"git format-patch [-k] [(-o|--output-directory) <dir> | --stdout]
                   [--no-thread | --thread[=<style>]]
                   [(--attach|--inline)[=<boundary>] | --no-attach]
                   [-s | --signoff]
                   [--signature=<signature> | --no-signature]
                   [--signature-file=<file>]
                   [-n | --numbered | -N | --no-numbered]
                   [--start-number <n>] [--numbered-files]
                   [--in-reply-to=<message id>] [--suffix=.<sfx>]
                   [--ignore-if-in-upstream] [--always]
                   [--cover-from-description=<mode>]
                   [--rfc] [--subject-prefix=<subject prefix>]
                   [(--reroll-count|-v) <n>]
                   [--to=<email>] [--cc=<email>]
                   [--[no-]cover-letter] [--quiet]
                   [--[no-]encode-email-headers]
                   [--no-notes | --notes[=<ref>]]
                   [--interdiff=<previous>]
                   [--range-diff=<previous> [--creation-factor=<percent>]]
                   [--filename-max-length=<n>]
                   [--progress]
                   [<common diff options>]
                   [ <since> | <revision range> ]",
		@"Prepare each non-merge commit with its ""patch"" in
one ""message"" per commit, formatted to resemble a UNIX mailbox.
The output of this command is convenient for e-mail submission or
for use with git am.

A ""message"" generated by the command consists of three parts:



A brief metadata header that begins with From <commit>
with a fixed Mon Sep 17 00:00:00 2001 datestamp to help programs
like ""file(1)"" to recognize that the file is an output from this
command, fields that record the author identity, the author date,
and the title of the change (taken from the first paragraph of the
commit log message).


The second and subsequent paragraphs of the commit log message.


The ""patch"", which is the ""diff -p --stat"" output (see
git-diff(1)) between the commit and its parent.



The log message and the patch is separated by a line with a
three-dash line.

There are two ways to specify which commits to operate on."),
			new GitCommand("fsck-objects", "Verifies the connectivity and validity of the objects in the database",
@"git fsck-objects …​",
		@"This is a synonym for git-fsck(1).  Please refer to the
documentation of that command."),
			new GitCommand("fsck", "Verifies the connectivity and validity of the objects in the database",
@"git fsck [--tags] [--root] [--unreachable] [--cache] [--no-reflogs]
         [--[no-]full] [--strict] [--verbose] [--lost-found]
         [--[no-]dangling] [--[no-]progress] [--connectivity-only]
         [--[no-]name-objects] [<object>…​]",
		@"Verifies the connectivity and validity of the objects in the database."),
			new GitCommand("fsmonitor--daemon", "A Built-in File System Monitor",
@"git fsmonitor--daemon start
git fsmonitor--daemon run
git fsmonitor--daemon stop
git fsmonitor--daemon status",
		@"A daemon to watch the working directory for file and directory
changes using platform-specific file system notification facilities.

This daemon communicates directly with commands like git status
using the simple IPC interface
instead of the slower githooks(5) interface.

This daemon is built into Git so that no third-party tools are
required."),
			new GitCommand("gc", "Cleanup unnecessary files and optimize the local repository",
@"git gc [--aggressive] [--auto] [--quiet] [--prune=<date> | --no-prune] [--force] [--keep-largest-pack]",
		@"Runs a number of housekeeping tasks within the current repository,
such as compressing file revisions (to reduce disk space and increase
performance), removing unreachable objects which may have been
created from prior invocations of git add, packing refs, pruning
reflog, rerere metadata or stale working trees. May also update ancillary
indexes such as the commit-graph.

When common porcelain operations that create objects are run, they
will check whether the repository has grown substantially since the
last maintenance, and if so run git gc automatically. See gc.auto
below for how to disable this behavior.

Running git gc manually should only be needed when adding objects to
a repository without regularly running such porcelain commands, to do
a one-off repository optimization, or e.g. to clean up a suboptimal
mass-import. See the ""PACKFILE OPTIMIZATION"" section in
git-fast-import(1) for more details on the import case."),
			new GitCommand("get-tar-commit-id", "Extract commit ID from an archive created using git-archive",
@"git get-tar-commit-id",
		@"Read a tar archive created by git archive from the standard input
and extract the commit ID stored in it.  It reads only the first
1024 bytes of input, thus its runtime is not influenced by the size
of the tar archive very much.

If no commit ID is found, git get-tar-commit-id quietly exists with a
return code of 1.  This can happen if the archive had not been created
using git archive or if the first parameter of git archive had been
a tree ID instead of a commit ID or tag."),
			new GitCommand("grep", "Print lines matching a pattern",
@"git grep [-a | --text] [-I] [--textconv] [-i | --ignore-case] [-w | --word-regexp]
           [-v | --invert-match] [-h|-H] [--full-name]
           [-E | --extended-regexp] [-G | --basic-regexp]
           [-P | --perl-regexp]
           [-F | --fixed-strings] [-n | --line-number] [--column]
           [-l | --files-with-matches] [-L | --files-without-match]
           [(-O | --open-files-in-pager) [<pager>]]
           [-z | --null]
           [ -o | --only-matching ] [-c | --count] [--all-match] [-q | --quiet]
           [--max-depth <depth>] [--[no-]recursive]
           [--color[=<when>] | --no-color]
           [--break] [--heading] [-p | --show-function]
           [-A <post-context>] [-B <pre-context>] [-C <context>]
           [-W | --function-context]
           [--threads <num>]
           [-f <file>] [-e] <pattern>
           [--and|--or|--not|(|)|-e <pattern>…​]
           [--recurse-submodules] [--parent-basename <basename>]
           [ [--[no-]exclude-standard] [--cached | --no-index | --untracked] | <tree>…​]
           [--] [<pathspec>…​]",
		@"Look for specified patterns in the tracked files in the work tree, blobs
registered in the index file, or blobs in given tree objects.  Patterns
are lists of one or more search expressions separated by newline
characters.  An empty string as search expression matches all lines."),
			new GitCommand("gui", "A portable graphical interface to Git",
@"git gui [<command>] [<arguments>]",
		@"A Tcl/Tk based graphical user interface to Git.  git gui focuses
on allowing users to make changes to their repository by making
new commits, amending existing ones, creating branches, performing
local merges, and fetching/pushing to remote repositories.

Unlike gitk, git gui focuses on commit generation
and single file annotation and does not show project history.
It does however supply menu actions to start a gitk session from
within git gui.

git gui is known to work on all popular UNIX systems, Mac OS X,
and Windows (under both Cygwin and MSYS).  To the extent possible
OS specific user interface guidelines are followed, making git gui
a fairly native interface for users."),
			new GitCommand("hash-object", "Compute object ID and optionally creates a blob from a file",
@"git hash-object [-t <type>] [-w] [--path=<file>|--no-filters] [--stdin [--literally]] [--] <file>…​
git hash-object [-t <type>] [-w] --stdin-paths [--no-filters]",
		@"Computes the object ID value for an object with specified type
with the contents of the named file (which can be outside of the
work tree), and optionally writes the resulting object into the
object database.  Reports its object ID to its standard output.
When <type> is not specified, it defaults to ""blob""."),
			new GitCommand("help", "Display help information about Git",
@"git help [-a|--all] [--[no-]verbose] [--[no-]external-commands] [--[no-]aliases]
git help [[-i|--info] [-m|--man] [-w|--web]] [<command>|<guide>]
git help [-g|--guides]
git help [-c|--config]",
		@"With no options and no <command> or <guide> given, the synopsis of the git
command and a list of the most commonly used Git commands are printed
on the standard output.

If the option --all or -a is given, all available commands are
printed on the standard output.

If the option --guides or -g is given, a list of the
Git concept guides is also printed on the standard output.

If a command, or a guide, is given, a manual page for that command or
guide is brought up. The man program is used by default for this
purpose, but this can be overridden by other options or configuration
variables.

If an alias is given, git shows the definition of the alias on
standard output. To get the manual page for the aliased command, use
git <command> --help.

Note that git --help ... is identical to git help ... because the
former is internally converted into the latter.

To display the git(1) man page, use git help git."),
			new GitCommand("hook", "Run git hooks",
@"git hook run [--ignore-missing] <hook-name> [-- <hook-args>]",
		@"A command interface to running git hooks (see githooks(5)),
for use by other scripted git commands."),
			new GitCommand("http-backend", "Server side implementation of Git over HTTP",
@"git http-backend",
		@"A simple CGI program to serve the contents of a Git repository to Git
clients accessing the repository over http:// and https:// protocols.
The program supports clients fetching using both the smart HTTP protocol
and the backwards-compatible dumb HTTP protocol, as well as clients
pushing using the smart HTTP protocol. It also supports Git’s
more-efficient ""v2"" protocol if properly configured; see the
discussion of GIT_PROTOCOL in the ENVIRONMENT section below.

It verifies that the directory has the magic file
""git-daemon-export-ok"", and it will refuse to export any Git directory
that hasn’t explicitly been marked for export this way (unless the
GIT_HTTP_EXPORT_ALL environmental variable is set)."),
			new GitCommand("http-fetch", "Download from a remote Git repository via HTTP",
@"git http-fetch [-c] [-t] [-a] [-d] [-v] [-w <filename>] [--recover] [--stdin | --packfile=<hash> | <commit>] <URL>",
		@"Downloads a remote Git repository via HTTP.

This command always gets all objects. Historically, there were three options
-a, -c and -t for choosing which objects to download. They are now
silently ignored."),
			new GitCommand("http-push", "Push objects over HTTP/DAV to another repository",
@"git http-push [--all] [--dry-run] [--force] [--verbose] <URL> <ref> [<ref>…​]",
		@"Sends missing objects to remote repository, and updates the
remote branch.

NOTE: This command is temporarily disabled if your libcurl
is older than 7.16, as the combination has been reported
not to work and sometimes corrupts repository."),
			new GitCommand("imap-send", "Send a collection of patches from stdin to an IMAP folder",
@"git imap-send [-v] [-q] [--[no-]curl]",
		@"This command uploads a mailbox generated with git format-patch
into an IMAP drafts folder.  This allows patches to be sent as
other email is when using mail clients that cannot read mailbox
files directly. The command also works with any general mailbox
in which emails have the fields ""From"", ""Date"", and ""Subject"" in
that order.

Typical usage is something like:

git format-patch --signoff --stdout --attach origin | git imap-send"),
			new GitCommand("index-pack", "Build pack index file for an existing packed archive",
@"git index-pack [-v] [-o <index-file>] [--[no-]rev-index] <pack-file>
git index-pack --stdin [--fix-thin] [--keep] [-v] [-o <index-file>]
                  [--[no-]rev-index] [<pack-file>]",
		@"Reads a packed archive (.pack) from the specified file, and
builds a pack index file (.idx) for it. Optionally writes a
reverse-index (.rev) for the specified pack. The packed
archive together with the pack index can then be placed in
the objects/pack/ directory of a Git repository."),
			new GitCommand("init-db", "Creates an empty Git repository",
@"git init-db [-q | --quiet] [--bare] [--template=<template-directory>] [--separate-git-dir <git-dir>] [--shared[=<permissions>]]",
		@"This is a synonym for git-init(1).  Please refer to the
documentation of that command."),
			new GitCommand("init", "Create an empty Git repository or reinitialize an existing one",
@"git init [-q | --quiet] [--bare] [--template=<template-directory>]
          [--separate-git-dir <git-dir>] [--object-format=<format>]
          [-b <branch-name> | --initial-branch=<branch-name>]
          [--shared[=<permissions>]] [<directory>]",
		@"This command creates an empty Git repository - basically a .git
directory with subdirectories for objects, refs/heads,
refs/tags, and template files.  An initial branch without any
commits will be created (see the --initial-branch option below
for its name).

If the $GIT_DIR environment variable is set then it specifies a path
to use instead of ./.git for the base of the repository.

If the object storage directory is specified via the
$GIT_OBJECT_DIRECTORY environment variable then the sha1 directories
are created underneath - otherwise the default $GIT_DIR/objects
directory is used.

Running git init in an existing repository is safe. It will not
overwrite things that are already there. The primary reason for
rerunning git init is to pick up newly added templates (or to move
the repository to another place if --separate-git-dir is given)."),
			new GitCommand("instaweb", "Instantly browse your working repository in gitweb",
@"git instaweb [--local] [--httpd=<httpd>] [--port=<port>]
               [--browser=<browser>]
git instaweb [--start] [--stop] [--restart]",
		@"A simple script to set up gitweb and a web server for browsing the local
repository."),
			new GitCommand("interpret-trailers", "Add or parse structured information in commit messages",
@"git interpret-trailers [<options>] [(--trailer <token>[(=|:)<value>])…​] [<file>…​]
git interpret-trailers [<options>] [--parse] [<file>…​]",
		@"Help parsing or adding trailers lines, that look similar to RFC 822 e-mail
headers, at the end of the otherwise free-form part of a commit
message.

This command reads some patches or commit messages from either the
<file> arguments or the standard input if no <file> is specified. If
--parse is specified, the output consists of the parsed trailers.

Otherwise, this command applies the arguments passed using the
--trailer option, if any, to the commit message part of each input
file. The result is emitted on the standard output.

Some configuration variables control the way the --trailer arguments
are applied to each commit message and the way any existing trailer in
the commit message is changed. They also make it possible to
automatically add some trailers."),
			new GitCommand("log", "Show commit logs",
@"git log [<options>] [<revision-range>] [[--] <path>…​]",
		@"Shows the commit logs.

List commits that are reachable by following the parent links from the
given commit(s), but exclude commits that are reachable from the one(s)
given with a ^ in front of them.  The output is given in reverse
chronological order by default.

You can think of this as a set operation. Commits reachable from any of
the commits given on the command line form a set, and then commits reachable
from any of the ones given with ^ in front are subtracted from that
set.  The remaining commits are what comes out in the command’s output.
Various other options and paths parameters can be used to further limit the
result.

Thus, the following command:


$ git log foo bar ^baz


means ""list all the commits which are reachable from foo or bar, but
not from baz""."),
			new GitCommand("ls-files", "Show information about files in the index and the working tree",
@"git ls-files [-z] [-t] [-v] [-f]
                [-c|--cached] [-d|--deleted] [-o|--others] [-i|--|ignored]
                [-s|--stage] [-u|--unmerged] [-k|--|killed] [-m|--modified]
                [--directory [--no-empty-directory]] [--eol]
                [--deduplicate]
                [-x <pattern>|--exclude=<pattern>]
                [-X <file>|--exclude-from=<file>]
                [--exclude-per-directory=<file>]
                [--exclude-standard]
                [--error-unmatch] [--with-tree=<tree-ish>]
                [--full-name] [--recurse-submodules]
                [--abbrev[=<n>]] [--] [<file>…​]",
		@"This merges the file listing in the index with the actual working
directory list, and shows different combinations of the two.

One or more of the options below may be used to determine the files
shown:"),
			new GitCommand("ls-remote", "List references in a remote repository",
@"git ls-remote [--heads] [--tags] [--refs] [--upload-pack=<exec>]
              [-q | --quiet] [--exit-code] [--get-url] [--sort=<key>]
              [--symref] [<repository> [<refs>…​]]",
		@"Displays references available in a remote repository along with the associated
commit IDs."),
			new GitCommand("ls-tree", "List the contents of a tree object",
@"git ls-tree [-d] [-r] [-t] [-l] [-z]
            [--name-only] [--name-status] [--object-only] [--full-name] [--full-tree] [--abbrev[=<n>]] [--format=<format>]
            <tree-ish> [<path>…​]",
		@"Lists the contents of a given tree object, like what ""/bin/ls -a"" does
in the current working directory.  Note that:



the behaviour is slightly different from that of ""/bin/ls"" in that the
<path> denotes just a list of patterns to match, e.g. so specifying
directory name (without -r) will behave differently, and order of the
arguments does not matter.


the behaviour is similar to that of ""/bin/ls"" in that the <path> is
taken as relative to the current working directory.  E.g. when you are
in a directory sub that has a directory dir, you can run git
ls-tree -r HEAD dir to list the contents of the tree (that is
sub/dir in HEAD).  You don’t want to give a tree that is not at the
root level (e.g. git ls-tree -r HEAD:sub dir) in this case, as that
would result in asking for sub/sub/dir in the HEAD commit.
However, the current working directory can be ignored by passing
--full-tree option."),
			new GitCommand("mailinfo", "Extracts patch and authorship from a single e-mail message",
@"git mailinfo [-k|-b] [-u | --encoding=<encoding> | -n]
               [--[no-]scissors] [--quoted-cr=<action>]
               <msg> <patch>",
		@"Reads a single e-mail message from the standard input, and
writes the commit log message in <msg> file, and the patches in
<patch> file.  The author name, e-mail and e-mail subject are
written out to the standard output to be used by git am
to create a commit.  It is usually not necessary to use this
command directly.  See git-am(1) instead."),
			new GitCommand("mailsplit", "Simple UNIX mbox splitter program",
@"git mailsplit [-b] [-f<nn>] [-d<prec>] [--keep-cr] [--mboxrd]
                -o<directory> [--] [(<mbox>|<Maildir>)…​]",
		@"Splits a mbox file or a Maildir into a list of files: ""0001"" ""0002"" ..  in the
specified directory so you can process them further from there.




Important


Maildir splitting relies upon filenames being sorted to output
patches in the correct order."),
			new GitCommand("maintenance", "Run tasks to optimize Git repository data",
@"git maintenance run [<options>]
git maintenance start [--scheduler=<scheduler>]
git maintenance (stop|register|unregister)",
		@"Run tasks to optimize Git repository data, speeding up other Git commands
and reducing storage requirements for the repository.

Git commands that add repository data, such as git add or git fetch,
are optimized for a responsive user experience. These commands do not take
time to optimize the Git data, since such optimizations scale with the full
size of the repository while these user commands each perform a relatively
small action.

The git maintenance command provides flexibility for how to optimize the
Git repository."),
			new GitCommand("merge-base", "Find as good common ancestors as possible for a merge",
@"git merge-base [-a|--all] <commit> <commit>…​
git merge-base [-a|--all] --octopus <commit>…​
git merge-base --is-ancestor <commit> <commit>
git merge-base --independent <commit>…​
git merge-base --fork-point <ref> [<commit>]",
		@"git merge-base finds best common ancestor(s) between two commits to use
in a three-way merge.  One common ancestor is better than another common
ancestor if the latter is an ancestor of the former.  A common ancestor
that does not have any better common ancestor is a best common
ancestor, i.e. a merge base.  Note that there can be more than one
merge base for a pair of commits."),
			new GitCommand("merge-file", "Run a three-way file merge",
@"git merge-file [-L <current-name> [-L <base-name> [-L <other-name>]]]
        [--ours|--theirs|--union] [-p|--stdout] [-q|--quiet] [--marker-size=<n>]
        [--[no-]diff3] <current-file> <base-file> <other-file>",
		@"git merge-file incorporates all changes that lead from the <base-file>
to <other-file> into <current-file>. The result ordinarily goes into
<current-file>. git merge-file is useful for combining separate changes
to an original. Suppose <base-file> is the original, and both
<current-file> and <other-file> are modifications of <base-file>,
then git merge-file combines both changes.

A conflict occurs if both <current-file> and <other-file> have changes
in a common segment of lines. If a conflict is found, git merge-file
normally outputs a warning and brackets the conflict with lines containing
<<<<<<< and >>>>>>> markers. A typical conflict will look like this:


<<<<<<< A
lines in file A
=======
lines in file B
>>>>>>> B"),
			new GitCommand("merge-index", "Run a merge for files needing merging",
@"git merge-index [-o] [-q] <merge-program> (-a | ( [--] <file>…​) )",
		@"This looks up the <file>(s) in the index and, if there are any merge
entries, passes the SHA-1 hash for those files as arguments 1, 2, 3 (empty
argument if no file), and <file> as argument 4.  File modes for the three
files are passed as arguments 5, 6 and 7."),
			new GitCommand("merge-one-file", "The standard helper program to use with git-merge-index",
@"git merge-one-file",
		@"This is the standard helper program to use with git merge-index
to resolve a merge after the trivial merge done with git read-tree -m."),
			new GitCommand("merge-tree", "Show three-way merge without touching index",
@"git merge-tree <base-tree> <branch1> <branch2>",
		@"Reads three tree-ish, and output trivial merge results and
conflicting stages to the standard output.  This is similar to
what three-way git read-tree -m does, but instead of storing the
results in the index, the command outputs the entries to the
standard output.

This is meant to be used by higher level scripts to compute
merge results outside of the index, and stuff the results back into the
index.  For this reason, the output from the command omits
entries that match the <branch1> tree."),
			new GitCommand("merge", "Join two or more development histories together",
@"git merge [-n] [--stat] [--no-commit] [--squash] [--[no-]edit]
        [--no-verify] [-s <strategy>] [-X <strategy-option>] [-S[<keyid>]]
        [--[no-]allow-unrelated-histories]
        [--[no-]rerere-autoupdate] [-m <msg>] [-F <file>]
        [--into-name <branch>] [<commit>…​]
git merge (--continue | --abort | --quit)",
		@"Incorporates changes from the named commits (since the time their
histories diverged from the current branch) into the current
branch.  This command is used by git pull to incorporate changes
from another repository and can be used by hand to merge changes
from one branch into another.

Assume the following history exists and the current branch is
""master"":


          A---B---C topic
         /
    D---E---F---G master


Then ""git merge topic"" will replay the changes made on the
topic branch since it diverged from master (i.e., E) until
its current commit (C) on top of master, and record the result
in a new commit along with the names of the two parent commits and
a log message from the user describing the changes.


          A---B---C topic
         /         \
    D---E---F---G---H master"),
			new GitCommand("mergetool--lib", "Common Git merge tool shell scriptlets",
@"TOOL_MODE=(diff|merge) . ""$(git --exec-path)/git-mergetool--lib""",
		@"This is not a command the end user would want to run.  Ever.
This documentation is meant for people who are studying the
Porcelain-ish scripts and/or are writing new ones.

The git-mergetool--lib scriptlet is designed to be sourced (using
.) by other shell scripts to set up functions for working
with Git merge tools.

Before sourcing git-mergetool--lib, your script must set TOOL_MODE
to define the operation mode for the functions listed below.
diff and merge are valid values."),
			new GitCommand("mergetool", "Run merge conflict resolution tools to resolve merge conflicts",
@"git mergetool [--tool=<tool>] [-y | --[no-]prompt] [<file>…​]",
		@"Use git mergetool to run one of several merge utilities to resolve
merge conflicts.  It is typically run after git merge.

If one or more <file> parameters are given, the merge tool program will
be run to resolve differences on each file (skipping those without
conflicts).  Specifying a directory will include all unresolved files in
that path.  If no <file> names are specified, git mergetool will run
the merge tool program on every file with merge conflicts."),
			new GitCommand("mktag", "Creates a tag object with extra validation",
@"git mktag",
		@"Reads a tag contents on standard input and creates a tag object. The
output is the new tag’s <object> identifier.

This command is mostly equivalent to git-hash-object(1)
invoked with -t tag -w --stdin. I.e. both of these will create and
write a tag found in my-tag:


git mktag <my-tag
git hash-object -t tag -w --stdin <my-tag


The difference is that mktag will die before writing the tag if the
tag doesn’t pass a git-fsck(1) check.

The ""fsck"" check done mktag is stricter than what git-fsck(1)
would run by default in that all fsck.<msg-id> messages are promoted
from warnings to errors (so e.g. a missing ""tagger"" line is an error).

Extra headers in the object are also an error under mktag, but ignored
by git-fsck(1). This extra check can be turned off by setting
the appropriate fsck.<msg-id> varible:


git -c fsck.extraHeaderEntry=ignore mktag <my-tag-with-headers"),
			new GitCommand("mktree", "Build a tree-object from ls-tree formatted text",
@"git mktree [-z] [--missing] [--batch]",
		@"Reads standard input in non-recursive ls-tree output format, and creates
a tree object.  The order of the tree entries is normalized by mktree so
pre-sorting the input is not required.  The object name of the tree object
built is written to the standard output."),
			new GitCommand("multi-pack-index", "Write and verify multi-pack-indexes",
@"git multi-pack-index [--object-dir=<dir>] [--[no-]bitmap] <sub-command>",
		@"Write or verify a multi-pack-index (MIDX) file."),
			new GitCommand("mv", "Move or rename a file, a directory, or a symlink",
@"git mv <options>…​ <args>…​",
		@"Move or rename a file, directory or symlink.


git mv [-v] [-f] [-n] [-k] <source> <destination>
git mv [-v] [-f] [-n] [-k] <source> ... <destination directory>


In the first form, it renames <source>, which must exist and be either
a file, symlink or directory, to <destination>.
In the second form, the last argument has to be an existing
directory; the given sources will be moved into this directory.

The index is updated after successful completion, but the change must still be
committed."),
			new GitCommand("name-rev", "Find symbolic names for given revs",
@"git name-rev [--tags] [--refs=<pattern>]
               ( --all | --stdin | <commit-ish>…​ )",
		@"Finds symbolic names suitable for human digestion for revisions given in any
format parsable by git rev-parse."),
			new GitCommand("notes", "Add or inspect object notes",
@"git notes [list [<object>]]
git notes add [-f] [--allow-empty] [-F <file> | -m <msg> | (-c | -C) <object>] [<object>]
git notes copy [-f] ( --stdin | <from-object> [<to-object>] )
git notes append [--allow-empty] [-F <file> | -m <msg> | (-c | -C) <object>] [<object>]
git notes edit [--allow-empty] [<object>]
git notes show [<object>]
git notes merge [-v | -q] [-s <strategy> ] <notes-ref>
git notes merge --commit [-v | -q]
git notes merge --abort [-v | -q]
git notes remove [--ignore-missing] [--stdin] [<object>…​]
git notes prune [-n] [-v]
git notes get-ref",
		@"Adds, removes, or reads notes attached to objects, without touching
the objects themselves.

By default, notes are saved to and read from refs/notes/commits, but
this default can be overridden.  See the OPTIONS, CONFIGURATION, and
ENVIRONMENT sections below.  If this ref does not exist, it will be
quietly created when it is first needed to store a note.

A typical use of notes is to supplement a commit message without
changing the commit itself. Notes can be shown by git log along with
the original commit message. To distinguish these notes from the
message stored in the commit object, the notes are indented like the
message, after an unindented line saying ""Notes (<refname>):"" (or
""Notes:"" for refs/notes/commits).

Notes can also be added to patches prepared with git format-patch by
using the --notes option. Such notes are added as a patch commentary
after a three dash separator line."),
			new GitCommand("p4", "Import from and submit to Perforce repositories",
@"git p4 clone [<sync-options>] [<clone-options>] <p4-depot-path>…​
git p4 sync [<sync-options>] [<p4-depot-path>…​]
git p4 rebase
git p4 submit [<submit-options>] [<master-branch-name>]",
		@"This command provides a way to interact with p4 repositories
using Git.

Create a new Git repository from an existing p4 repository using
git p4 clone, giving it one or more p4 depot paths.  Incorporate
new commits from p4 changes with git p4 sync.  The sync command
is also used to include new branches from other p4 depot paths.
Submit Git changes back to p4 using git p4 submit.  The command
git p4 rebase does a sync plus rebases the current branch onto
the updated p4 remote branch."),
			new GitCommand("pack-objects", "Create a packed archive of objects",
@"git pack-objects [-q | --progress | --all-progress] [--all-progress-implied]
        [--no-reuse-delta] [--delta-base-offset] [--non-empty]
        [--local] [--incremental] [--window=<n>] [--depth=<n>]
        [--revs [--unpacked | --all]] [--keep-pack=<pack-name>]
        [--stdout [--filter=<filter-spec>] | <base-name>]
        [--shallow] [--keep-true-parents] [--[no-]sparse] < <object-list>",
		@"Reads list of objects from the standard input, and writes either one or
more packed archives with the specified base-name to disk, or a packed
archive to the standard output.

A packed archive is an efficient way to transfer a set of objects
between two repositories as well as an access efficient archival
format.  In a packed archive, an object is either stored as a
compressed whole or as a difference from some other object.
The latter is often called a delta.

The packed archive format (.pack) is designed to be self-contained
so that it can be unpacked without any further information. Therefore,
each object that a delta depends upon must be present within the pack."),
			new GitCommand("pack-redundant", "Find redundant pack files",
@"git pack-redundant [ --verbose ] [ --alt-odb ] ( --all | <pack-filename>…​ )",
		@"This program computes which packs in your repository
are redundant. The output is suitable for piping to
xargs rm if you are in the root of the repository.

git pack-redundant accepts a list of objects on standard input. Any objects
given will be ignored when checking which packs are required. This makes the
following command useful when wanting to remove packs which contain unreachable
objects.

git fsck --full --unreachable | cut -d ' ' -f3 | \
git pack-redundant --all | xargs rm"),
			new GitCommand("pack-refs", "Pack heads and tags for efficient repository access",
@"git pack-refs [--all] [--no-prune]",
		@"Traditionally, tips of branches and tags (collectively known as
refs) were stored one file per ref in a (sub)directory
under $GIT_DIR/refs
directory.  While many branch tips tend to be updated often,
most tags and some branch tips are never updated.  When a
repository has hundreds or thousands of tags, this
one-file-per-ref format both wastes storage and hurts
performance.

This command is used to solve the storage and performance
problem by storing the refs in a single file,
$GIT_DIR/packed-refs.  When a ref is missing from the
traditional $GIT_DIR/refs directory hierarchy, it is looked
up in this
file and used if found.

Subsequent updates to branches always create new files under
$GIT_DIR/refs directory hierarchy."),
			new GitCommand("patch-id", "Compute unique ID for a patch",
@"git patch-id [--stable | --unstable]",
		@"Read a patch from the standard input and compute the patch ID for it.

A ""patch ID"" is nothing but a sum of SHA-1 of the file diffs associated with a
patch, with whitespace and line numbers ignored.  As such, it’s ""reasonably
stable"", but at the same time also reasonably unique, i.e., two patches that
have the same ""patch ID"" are almost guaranteed to be the same thing.

IOW, you can use this thing to look for likely duplicate commits.

When dealing with git diff-tree output, it takes advantage of
the fact that the patch is prefixed with the object name of the
commit, and outputs two 40-byte hexadecimal strings.  The first
string is the patch ID, and the second string is the commit ID.
This can be used to make a mapping from patch ID to commit ID."),
			new GitCommand("prune-packed", "Remove extra objects that are already in pack files",
@"git prune-packed [-n|--dry-run] [-q|--quiet]",
		@"This program searches the $GIT_OBJECT_DIRECTORY for all objects that currently
exist in a pack file as well as the independent object directories.

All such extra objects are removed.

A pack is a collection of objects, individually compressed, with delta
compression applied, stored in a single file, with an associated index file.

Packs are used to reduce the load on mirror systems, backup engines,
disk storage, etc."),
			new GitCommand("prune", "Prune all unreachable objects from the object database",
@"git prune [-n] [-v] [--progress] [--expire <time>] [--] [<head>…​]",
		@"Note


In most cases, users should run git gc, which calls
git prune. See the section ""NOTES"", below.




This runs git fsck --unreachable using all the refs
available in refs/, optionally with additional set of
objects specified on the command line, and prunes all unpacked
objects unreachable from any of these head objects from the object database.
In addition, it
prunes the unpacked objects that are also found in packs by
running git prune-packed.
It also removes entries from .git/shallow that are not reachable by
any ref.

Note that unreachable, packed objects will remain.  If this is
not desired, see git-repack(1)."),
			new GitCommand("pull", "Fetch from and integrate with another repository or a local branch",
@"git pull [<options>] [<repository> [<refspec>…​]]",
		@"Incorporates changes from a remote repository into the current branch.
If the current branch is behind the remote, then by default it will
fast-forward the current branch to match the remote.  If the current
branch and the remote have diverged, the user needs to specify how to
reconcile the divergent branches with --rebase or --no-rebase (or
the corresponding configuration option in pull.rebase).

More precisely, git pull runs git fetch with the given parameters
and then depending on configuration options or command line flags,
will call either git rebase or git merge to reconcile diverging
branches.

<repository> should be the name of a remote repository as
passed to git-fetch(1).  <refspec> can name an
arbitrary remote ref (for example, the name of a tag) or even
a collection of refs with corresponding remote-tracking branches
(e.g., refs/heads/*:refs/remotes/origin/*),
but usually it is the name of a branch in the remote repository."),
			new GitCommand("push", "Update remote refs along with associated objects",
@"git push [--all | --mirror | --tags] [--follow-tags] [--atomic] [-n | --dry-run] [--receive-pack=<git-receive-pack>]
           [--repo=<repository>] [-f | --force] [-d | --delete] [--prune] [-v | --verbose]
           [-u | --set-upstream] [-o <string> | --push-option=<string>]
           [--[no-]signed|--signed=(true|false|if-asked)]
           [--force-with-lease[=<refname>[:<expect>]] [--force-if-includes]]
           [--no-verify] [<repository> [<refspec>…​]]",
		@"Updates remote refs using local refs, while sending objects
necessary to complete the given refs.

You can make interesting things happen to a repository
every time you push into it, by setting up hooks there.  See
documentation for git-receive-pack(1).

When the command line does not specify where to push with the
<repository> argument, branch.*.remote configuration for the
current branch is consulted to determine where to push.  If the
configuration is missing, it defaults to origin.

When the command line does not specify what to push with <refspec>...
arguments or --all, --mirror, --tags options, the command finds
the default <refspec> by consulting remote.*.push configuration,
and if it is not found, honors push.default configuration to decide
what to push (See git-config(1) for the meaning of push.default)."),
			new GitCommand("quiltimport", "Applies a quilt patchset onto the current branch",
@"git quiltimport [--dry-run | -n] [--author <author>] [--patches <dir>]
                [--series <file>] [--keep-non-patch]",
		@"Applies a quilt patchset onto the current Git branch, preserving
the patch boundaries, patch order, and patch descriptions present
in the quilt patchset.

For each patch the code attempts to extract the author from the
patch description.  If that fails it falls back to the author
specified with --author.  If the --author flag was not given
the patch description is displayed and the user is asked to
interactively enter the author of the patch.

If a subject is not found in the patch description the patch name is
preserved as the 1 line subject in the Git description."),
			new GitCommand("range-diff", "Compare two commit ranges (e.g. two versions of a branch)",
@"git range-diff [--color=[<when>]] [--no-color] [<diff-options>]
        [--no-dual-color] [--creation-factor=<factor>]
        [--left-only | --right-only]
        ( <range1> <range2> | <rev1>…​<rev2> | <base> <rev1> <rev2> )",
		@"This command shows the differences between two versions of a patch
series, or more generally, two commit ranges (ignoring merge commits).

To that end, it first finds pairs of commits from both commit ranges
that correspond with each other. Two commits are said to correspond when
the diff between their patches (i.e. the author information, the commit
message and the commit diff) is reasonably small compared to the
patches' size. See ``Algorithm`` below for details.

Finally, the list of matching commits is shown in the order of the
second commit range, with unmatched commits being inserted just after
all of their ancestors have been shown.

There are three ways to specify the commit ranges:"),
			new GitCommand("read-tree", "Reads tree information into the index",
@"git read-tree [[-m [--trivial] [--aggressive] | --reset | --prefix=<prefix>]
                [-u | -i]] [--index-output=<file>] [--no-sparse-checkout]
                (--empty | <tree-ish1> [<tree-ish2> [<tree-ish3>]])",
		@"Reads the tree information given by <tree-ish> into the index,
but does not actually update any of the files it ""caches"". (see:
git-checkout-index(1))

Optionally, it can merge a tree into the index, perform a
fast-forward (i.e. 2-way) merge, or a 3-way merge, with the -m
flag.  When used with -m, the -u flag causes it to also update
the files in the work tree with the result of the merge.

Trivial merges are done by git read-tree itself.  Only conflicting paths
will be in unmerged state when git read-tree returns."),
			new GitCommand("rebase", "Reapply commits on top of another base tip",
@"git rebase [-i | --interactive] [<options>] [--exec <cmd>]
        [--onto <newbase> | --keep-base] [<upstream> [<branch>]]
git rebase [-i | --interactive] [<options>] [--exec <cmd>] [--onto <newbase>]
        --root [<branch>]
git rebase (--continue | --skip | --abort | --quit | --edit-todo | --show-current-patch)",
		@"If <branch> is specified, git rebase will perform an automatic
git switch <branch> before doing anything else.  Otherwise
it remains on the current branch.

If <upstream> is not specified, the upstream configured in
branch.<name>.remote and branch.<name>.merge options will be used (see
git-config(1) for details) and the --fork-point option is
assumed.  If you are currently not on any branch or if the current
branch does not have a configured upstream, the rebase will abort.

All changes made by commits in the current branch but that are not
in <upstream> are saved to a temporary area.  This is the same set
of commits that would be shown by git log <upstream>..HEAD; or by
git log 'fork_point'..HEAD, if --fork-point is active (see the
description on --fork-point below); or by git log HEAD, if the
--root option is specified."),
			new GitCommand("receive-pack", "Receive what is pushed into the repository",
@"git-receive-pack <directory>",
		@"Invoked by git send-pack and updates the repository with the
information fed from the remote end.

This command is usually not invoked directly by the end user.
The UI for the protocol is on the git send-pack side, and the
program pair is meant to be used to push updates to remote
repository.  For pull operations, see git-fetch-pack(1).

The command allows for creation and fast-forwarding of sha1 refs
(heads/tags) on the remote end (strictly speaking, it is the
local end git-receive-pack runs, but to the user who is sitting at
the send-pack end, it is updating the remote.  Confused?)

There are other real-world examples of using update and
post-update hooks found in the Documentation/howto directory.

git-receive-pack honours the receive.denyNonFastForwards config
option, which tells it if updates to a ref should be denied if they
are not fast-forwards.

A number of other receive.* config options are available to tweak
its behavior, see git-config(1)."),
			new GitCommand("reflog", "Manage reflog information",
@"git reflog <subcommand> <options>",
		@"The command takes various subcommands, and different options
depending on the subcommand:

git reflog [show] [<log-options>] [<ref>]
git reflog expire [--expire=<time>] [--expire-unreachable=<time>]
        [--rewrite] [--updateref] [--stale-fix]
        [--dry-run | -n] [--verbose] [--all [--single-worktree] | <refs>…​]
git reflog delete [--rewrite] [--updateref]
        [--dry-run | -n] [--verbose] <ref>@\{<specifier>\}…​
git reflog exists <ref>

Reference logs, or ""reflogs"", record when the tips of branches and
other references were updated in the local repository. Reflogs are
useful in various Git commands, to specify the old value of a
reference. For example, HEAD@{2} means ""where HEAD used to be two
moves ago"", master@{one.week.ago} means ""where master used to point
to one week ago in this local repository"", and so on. See
gitrevisions(7) for more details."),
			new GitCommand("remote-ext", "Bridge smart transport to external command.",
@"git remote add <nick> ""ext::<command>[ <arguments>…​]""",
		@"This remote helper uses the specified <command> to connect
to a remote Git server.

Data written to stdin of the specified <command> is assumed
to be sent to a git:// server, git-upload-pack, git-receive-pack
or git-upload-archive (depending on situation), and data read
from stdout of <command> is assumed to be received from
the same service.

Command and arguments are separated by an unescaped space.

The following sequences have a special meaning:"),
			new GitCommand("remote-fd", "Reflect smart transport stream back to caller",
@"""fd::<infd>[,<outfd>][/<anything>]"" (as URL)",
		@"This helper uses specified file descriptors to connect to a remote Git server.
This is not meant for end users but for programs and scripts calling git
fetch, push or archive.

If only <infd> is given, it is assumed to be a bidirectional socket connected
to remote Git server (git-upload-pack, git-receive-pack or
git-upload-archive). If both <infd> and <outfd> are given, they are assumed
to be pipes connected to a remote Git server (<infd> being the inbound pipe
and <outfd> being the outbound pipe.

It is assumed that any handshaking procedures have already been completed
(such as sending service request for git://) before this helper is started.

<anything> can be any string. It is ignored. It is meant for providing
information to user in the URL in case that URL is displayed in some
context."),
			new GitCommand("remote", "Manage set of tracked repositories",
@"git remote [-v | --verbose]
git remote add [-t <branch>] [-m <master>] [-f] [--[no-]tags] [--mirror=(fetch|push)] <name> <URL>
git remote rename [--[no-]progress] <old> <new>
git remote remove <name>
git remote set-head <name> (-a | --auto | -d | --delete | <branch>)
git remote set-branches [--add] <name> <branch>…​
git remote get-url [--push] [--all] <name>
git remote set-url [--push] <name> <newurl> [<oldurl>]
git remote set-url --add [--push] <name> <newurl>
git remote set-url --delete [--push] <name> <URL>
git remote [-v | --verbose] show [-n] <name>…​
git remote prune [-n | --dry-run] <name>…​
git remote [-v | --verbose] update [-p | --prune] [(<group> | <remote>)…​]",
		@"Manage the set of repositories (""remotes"") whose branches you track."),
			new GitCommand("repack", "Pack unpacked objects in a repository",
@"git repack [-a] [-A] [-d] [-f] [-F] [-l] [-n] [-q] [-b] [-m] [--window=<n>] [--depth=<n>] [--threads=<n>] [--keep-pack=<pack-name>] [--write-midx]",
		@"This command is used to combine all objects that do not currently
reside in a ""pack"", into a pack.  It can also be used to re-organize
existing packs into a single, more efficient pack.

A pack is a collection of objects, individually compressed, with
delta compression applied, stored in a single file, with an
associated index file.

Packs are used to reduce the load on mirror systems, backup
engines, disk storage, etc."),
			new GitCommand("replace", "Create, list, delete refs to replace objects",
@"git replace [-f] <object> <replacement>
git replace [-f] --edit <object>
git replace [-f] --graft <commit> [<parent>…​]
git replace [-f] --convert-graft-file
git replace -d <object>…​
git replace [--format=<format>] [-l [<pattern>]]",
		@"Adds a replace reference in refs/replace/ namespace.

The name of the replace reference is the SHA-1 of the object that is
replaced. The content of the replace reference is the SHA-1 of the
replacement object.

The replaced object and the replacement object must be of the same type.
This restriction can be bypassed using -f.

Unless -f is given, the replace reference must not yet exist.

There is no other restriction on the replaced and replacement objects.
Merge commits can be replaced by non-merge commits and vice versa.

Replacement references will be used by default by all Git commands
except those doing reachability traversal (prune, pack transfer and
fsck).

It is possible to disable use of replacement references for any
command using the --no-replace-objects option just after git.

For example if commit foo has been replaced by commit bar:


$ git --no-replace-objects cat-file commit foo


shows information about commit foo, while:"),
			new GitCommand("request-pull", "Generates a summary of pending changes",
@"git request-pull [-p] <start> <URL> [<end>]",
		@"Generate a request asking your upstream project to pull changes into
their tree.  The request, printed to the standard output,
begins with the branch description, summarizes
the changes and indicates from where they can be pulled.

The upstream project is expected to have the commit named by
<start> and the output asks it to integrate the changes you made
since that commit, up to the commit named by <end>, by visiting
the repository named by <URL>."),
			new GitCommand("rerere", "Reuse recorded resolution of conflicted merges",
@"git rerere [clear|forget <pathspec>|diff|remaining|status|gc]",
		@"In a workflow employing relatively long lived topic branches,
the developer sometimes needs to resolve the same conflicts over
and over again until the topic branches are done (either merged
to the ""release"" branch, or sent out and accepted upstream).

This command assists the developer in this process by recording
conflicted automerge results and corresponding hand resolve results
on the initial manual merge, and applying previously recorded
hand resolutions to their corresponding automerge results.




Note


You need to set the configuration variable rerere.enabled in order to
enable this command."),
			new GitCommand("reset", "Reset current HEAD to the specified state",
@"git reset [-q] [<tree-ish>] [--] <pathspec>…​
git reset [-q] [--pathspec-from-file=<file> [--pathspec-file-nul]] [<tree-ish>]
git reset (--patch | -p) [<tree-ish>] [--] [<pathspec>…​]
git reset [--soft | --mixed [-N] | --hard | --merge | --keep] [-q] [<commit>]
DEPRECATED: git reset [-q] [--stdin [-z]] [<tree-ish>]",
		@"In the first three forms, copy entries from <tree-ish> to the index.
In the last form, set the current branch head (HEAD) to <commit>,
optionally modifying index and working tree to match.
The <tree-ish>/<commit> defaults to HEAD in all forms."),
			new GitCommand("restore", "Restore working tree files",
@"git restore [<options>] [--source=<tree>] [--staged] [--worktree] [--] <pathspec>…​
git restore [<options>] [--source=<tree>] [--staged] [--worktree] --pathspec-from-file=<file> [--pathspec-file-nul]
git restore (-p|--patch) [<options>] [--source=<tree>] [--staged] [--worktree] [--] [<pathspec>…​]",
		@"Restore specified paths in the working tree with some contents from a
restore source. If a path is tracked but does not exist in the restore
source, it will be removed to match the source.

The command can also be used to restore the content in the index with
--staged, or restore both the working tree and the index with
--staged --worktree.

By default, if --staged is given, the contents are restored from HEAD,
otherwise from the index. Use --source to restore from a different commit.

See ""Reset, restore and revert"" in git(1) for the differences
between the three commands.

THIS COMMAND IS EXPERIMENTAL. THE BEHAVIOR MAY CHANGE."),
			new GitCommand("rev-list", "Lists commit objects in reverse chronological order",
@"git rev-list [<options>] <commit>…​ [[--] <path>…​]",
		@"List commits that are reachable by following the parent links from the
given commit(s), but exclude commits that are reachable from the one(s)
given with a ^ in front of them.  The output is given in reverse
chronological order by default.

You can think of this as a set operation. Commits reachable from any of
the commits given on the command line form a set, and then commits reachable
from any of the ones given with ^ in front are subtracted from that
set.  The remaining commits are what comes out in the command’s output.
Various other options and paths parameters can be used to further limit the
result.

Thus, the following command:


$ git rev-list foo bar ^baz


means ""list all the commits which are reachable from foo or bar, but
not from baz"".

A special notation ""<commit1>..<commit2>"" can be used as a
short-hand for ""^<commit1> <commit2>"". For example, either of
the following may be used interchangeably:"),
			new GitCommand("rev-parse", "Pick out and massage parameters",
@"git rev-parse [<options>] <args>…​",
		@"Many Git porcelainish commands take mixture of flags
(i.e. parameters that begin with a dash -) and parameters
meant for the underlying git rev-list command they use internally
and flags and parameters for the other commands they use
downstream of git rev-list.  This command is used to
distinguish between them."),
			new GitCommand("revert", "Revert some existing commits",
@"git revert [--[no-]edit] [-n] [-m parent-number] [-s] [-S[<keyid>]] <commit>…​
git revert (--continue | --skip | --abort | --quit)",
		@"Given one or more existing commits, revert the changes that the
related patches introduce, and record some new commits that record
them.  This requires your working tree to be clean (no modifications
from the HEAD commit).

Note: git revert is used to record some new commits to reverse the
effect of some earlier commits (often only a faulty one).  If you want to
throw away all uncommitted changes in your working directory, you
should see git-reset(1), particularly the --hard option.  If
you want to extract specific files as they were in another commit, you
should see git-restore(1), specifically the --source
option. Take care with these alternatives as
both will discard uncommitted changes in your working directory.

See ""Reset, restore and revert"" in git(1) for the differences
between the three commands."),
			new GitCommand("rm", "Remove files from the working tree and from the index",
@"git rm [-f | --force] [-n] [-r] [--cached] [--ignore-unmatch]
          [--quiet] [--pathspec-from-file=<file> [--pathspec-file-nul]]
          [--] [<pathspec>…​]",
		@"Remove files matching pathspec from the index, or from the working tree
and the index. git rm will not remove a file from just your working
directory. (There is no option to remove a file only from the working
tree and yet keep it in the index; use /bin/rm if you want to do
that.) The files being removed have to be identical to the tip of the
branch, and no updates to their contents can be staged in the index,
though that default behavior can be overridden with the -f option.
When --cached is given, the staged content has to
match either the tip of the branch or the file on disk,
allowing the file to be removed from just the index. When
sparse-checkouts are in use (see git-sparse-checkout(1)),
git rm will only remove paths within the sparse-checkout patterns."),
			new GitCommand("send-email", "Send a collection of patches as emails",
@"git send-email [<options>] <file|directory>…​
git send-email [<options>] <format-patch options>
git send-email --dump-aliases",
		@"Takes the patches given on the command line and emails them out.
Patches can be specified as files, directories (which will send all
files in the directory), or directly as a revision list.  In the
last case, any format accepted by git-format-patch(1) can
be passed to git send-email, as well as options understood by
git-format-patch(1).

The header of the email is configurable via command-line options.  If not
specified on the command line, the user will be prompted with a ReadLine
enabled interface to provide the necessary information.

There are two formats accepted for patch files:



mbox format files

This is what git-format-patch(1) generates.  Most headers and MIME
formatting are ignored.



The original format used by Greg Kroah-Hartman’s send_lots_of_email.pl
script

This format expects the first line of the file to contain the ""Cc:"" value
and the ""Subject:"" of the message as the second line."),
			new GitCommand("send-pack", "Push objects over Git protocol to another repository",
@"git send-pack [--dry-run] [--force] [--receive-pack=<git-receive-pack>]
                [--verbose] [--thin] [--atomic]
                [--[no-]signed|--signed=(true|false|if-asked)]
                [<host>:]<directory> (--all | <ref>…​)",
		@"Usually you would want to use git push, which is a
higher-level wrapper of this command, instead. See git-push(1).

Invokes git-receive-pack on a possibly remote repository, and
updates it from the current repository, sending named refs."),
			new GitCommand("sh-i18n--envsubst", "Git's own envsubst(1) for i18n fallbacks",
@"eval_gettext () {
        printf ""%s"" ""$1"" | (
                export PATH $(git sh-i18n--envsubst --variables ""$1"");
                git sh-i18n--envsubst ""$1""
        )
}",
		@"This is not a command the end user would want to run.  Ever.
This documentation is meant for people who are studying the
plumbing scripts and/or are writing new ones.

git sh-i18n--envsubst is Git’s stripped-down copy of the GNU
envsubst(1) program that comes with the GNU gettext package. It’s
used internally by git-sh-i18n(1) to interpolate the variables
passed to the eval_gettext function.

No promises are made about the interface, or that this
program won’t disappear without warning in the next version
of Git. Don’t use it."),
			new GitCommand("sh-i18n", "Git's i18n setup code for shell scripts",
@". ""$(git --exec-path)/git-sh-i18n""",
		@"This is not a command the end user would want to run.  Ever.
This documentation is meant for people who are studying the
Porcelain-ish scripts and/or are writing new ones.

The 'git sh-i18n scriptlet is designed to be sourced (using
.) by Git’s porcelain programs implemented in shell
script. It provides wrappers for the GNU gettext and
eval_gettext functions accessible through the gettext.sh
script, and provides pass-through fallbacks on systems
without GNU gettext."),
			new GitCommand("sh-setup", "Common Git shell script setup code",
@". ""$(git --exec-path)/git-sh-setup""",
		@"This is not a command the end user would want to run.  Ever.
This documentation is meant for people who are studying the
Porcelain-ish scripts and/or are writing new ones.

The git sh-setup scriptlet is designed to be sourced (using
.) by other shell scripts to set up some variables pointing at
the normal Git directories and a few helper shell functions.

Before sourcing it, your script should set up a few variables;
USAGE (and LONG_USAGE, if any) is used to define message
given by usage() shell function.  SUBDIRECTORY_OK can be set
if the script can run from a subdirectory of the working tree
(some commands do not).

The scriptlet sets GIT_DIR and GIT_OBJECT_DIRECTORY shell
variables, but does not export them to the environment."),
			new GitCommand("shell", "Restricted login shell for Git-only SSH access",
@"chsh -s $(command -v git-shell) <user>
git clone <user>@localhost:/path/to/repo.git
ssh <user>@localhost",
		@"This is a login shell for SSH accounts to provide restricted Git access.
It permits execution only of server-side Git commands implementing the
pull/push functionality, plus custom commands present in a subdirectory
named git-shell-commands in the user’s home directory."),
			new GitCommand("shortlog", "Summarize 'git log' output",
@"git shortlog [<options>] [<revision-range>] [[--] <path>…​]
git log --pretty=short | git shortlog [<options>]",
		@"Summarizes git log output in a format suitable for inclusion
in release announcements. Each commit will be grouped by author and title.

Additionally, ""[PATCH]"" will be stripped from the commit description.

If no revisions are passed on the command line and either standard input
is not a terminal or there is no current branch, git shortlog will
output a summary of the log read from standard input, without
reference to the current repository."),
			new GitCommand("show-branch", "Show branches and their commits",
@"git show-branch [-a|--all] [-r|--remotes] [--topo-order | --date-order]
                [--current] [--color[=<when>] | --no-color] [--sparse]
                [--more=<n> | --list | --independent | --merge-base]
                [--no-name | --sha1-name] [--topics]
                [(<rev> | <glob>)…​]
git show-branch (-g|--reflog)[=<n>[,<base>]] [--list] [<ref>]",
		@"Shows the commit ancestry graph starting from the commits named
with <rev>s or <glob>s (or all refs under refs/heads
and/or refs/tags) semi-visually.

It cannot show more than 29 branches and commits at a time.

It uses showbranch.default multi-valued configuration items if
no <rev> or <glob> is given on the command line."),
			new GitCommand("show-index", "Show packed archive index",
@"git show-index [--object-format=<hash-algorithm>]",
		@"Read the .idx file for a Git packfile (created with
git-pack-objects(1) or git-index-pack(1)) from the
standard input, and dump its contents. The output consists of one object
per line, with each line containing two or three space-separated
columns:



the first column is the offset in bytes of the object within the
corresponding packfile


the second column is the object id of the object


if the index version is 2 or higher, the third column contains the
CRC32 of the object data



The objects are output in the order in which they are found in the index
file, which should be (in a correctly constructed file) sorted by object
id.

Note that you can get more information on a packfile by calling
git-verify-pack(1). However, as this command considers only the
index file itself, it’s both faster and more flexible."),
			new GitCommand("show-ref", "List references in a local repository",
@"git show-ref [-q|--quiet] [--verify] [--head] [-d|--dereference]
             [-s|--hash[=<n>]] [--abbrev[=<n>]] [--tags]
             [--heads] [--] [<pattern>…​]
git show-ref --exclude-existing[=<pattern>]",
		@"Displays references available in a local repository along with the associated
commit IDs. Results can be filtered using a pattern and tags can be
dereferenced into object IDs. Additionally, it can be used to test whether a
particular ref exists.

By default, shows the tags, heads, and remote refs.

The --exclude-existing form is a filter that does the inverse. It reads
refs from stdin, one ref per line, and shows those that don’t exist in
the local repository.

Use of this utility is encouraged in favor of directly accessing files under
the .git directory."),
			new GitCommand("show", "Show various types of objects",
@"git show [<options>] [<object>…​]",
		@"Shows one or more objects (blobs, trees, tags and commits).

For commits it shows the log message and textual diff. It also
presents the merge commit in a special format as produced by
git diff-tree --cc.

For tags, it shows the tag message and the referenced objects.

For trees, it shows the names (equivalent to git ls-tree
with --name-only).

For plain blobs, it shows the plain contents.

The command takes options applicable to the git diff-tree command to
control how the changes the commit introduces are shown.

This manual page describes only the most frequently used options."),
			new GitCommand("sparse-checkout", "Reduce your working tree to a subset of tracked files",
@"git sparse-checkout <subcommand> [<options>]",
		@"This command is used to create sparse checkouts, which means that it
changes the working tree from having all tracked files present, to only
have a subset of them.  It can also switch which subset of files are
present, or undo and go back to having all tracked files present in the
working copy.

The subset of files is chosen by providing a list of directories in
cone mode (which is recommended), or by providing a list of patterns
in non-cone mode.

When in a sparse-checkout, other Git commands behave a bit differently.
For example, switching branches will not update paths outside the
sparse-checkout directories/patterns, and git commit -a will not record
paths outside the sparse-checkout directories/patterns as deleted.

THIS COMMAND IS EXPERIMENTAL. ITS BEHAVIOR, AND THE BEHAVIOR OF OTHER
COMMANDS IN THE PRESENCE OF SPARSE-CHECKOUTS, WILL LIKELY CHANGE IN
THE FUTURE."),
			new GitCommand("stage", "Add file contents to the staging area",
@"git stage <arg>…​",
		@"This is a synonym for git-add(1).  Please refer to the
documentation of that command."),
			new GitCommand("stash", "Stash the changes in a dirty working directory away",
@"git stash list [<log-options>]
git stash show [-u|--include-untracked|--only-untracked] [<diff-options>] [<stash>]
git stash drop [-q|--quiet] [<stash>]
git stash ( pop | apply ) [--index] [-q|--quiet] [<stash>]
git stash branch <branchname> [<stash>]
git stash [push [-p|--patch] [-S|--staged] [-k|--[no-]keep-index] [-q|--quiet]
             [-u|--include-untracked] [-a|--all] [-m|--message <message>]
             [--pathspec-from-file=<file> [--pathspec-file-nul]]
             [--] [<pathspec>…​]]
git stash clear
git stash create [<message>]
git stash store [-m|--message <message>] [-q|--quiet] <commit>",
		@"Use git stash when you want to record the current state of the
working directory and the index, but want to go back to a clean
working directory.  The command saves your local modifications away
and reverts the working directory to match the HEAD commit.

The modifications stashed away by this command can be listed with
git stash list, inspected with git stash show, and restored
(potentially on top of a different commit) with git stash apply.
Calling git stash without any arguments is equivalent to git stash push.
A stash is by default listed as ""WIP on branchname …​"", but
you can give a more descriptive message on the command line when
you create one."),
			new GitCommand("status", "Show the working tree status",
@"git status [<options>…​] [--] [<pathspec>…​]",
		@"Displays paths that have differences between the index file and the
current HEAD commit, paths that have differences between the working
tree and the index file, and paths in the working tree that are not
tracked by Git (and are not ignored by gitignore(5)). The first
are what you would commit by running git commit; the second and
third are what you could commit by running git add before running
git commit."),
			new GitCommand("stripspace", "Remove unnecessary whitespace",
@"git stripspace [-s | --strip-comments]
git stripspace [-c | --comment-lines]",
		@"Read text, such as commit messages, notes, tags and branch
descriptions, from the standard input and clean it in the manner
used by Git.

With no arguments, this will:



remove trailing whitespace from all lines


collapse multiple consecutive empty lines into one empty line


remove empty lines from the beginning and end of the input


add a missing \n to the last line if necessary.



In the case where the input consists entirely of whitespace characters, no
output will be produced.

NOTE: This is intended for cleaning metadata, prefer the --whitespace=fix
mode of git-apply(1) for correcting whitespace of patches or files in
the repository."),
			new GitCommand("submodule", "Initialize, update or inspect submodules",
@"git submodule [--quiet] [--cached]
git submodule [--quiet] add [<options>] [--] <repository> [<path>]
git submodule [--quiet] status [--cached] [--recursive] [--] [<path>…​]
git submodule [--quiet] init [--] [<path>…​]
git submodule [--quiet] deinit [-f|--force] (--all|[--] <path>…​)
git submodule [--quiet] update [<options>] [--] [<path>…​]
git submodule [--quiet] set-branch [<options>] [--] <path>
git submodule [--quiet] set-url [--] <path> <newurl>
git submodule [--quiet] summary [<options>] [--] [<path>…​]
git submodule [--quiet] foreach [--recursive] <command>
git submodule [--quiet] sync [--recursive] [--] [<path>…​]
git submodule [--quiet] absorbgitdirs [--] [<path>…​]",
		@"Inspects, updates and manages submodules.

For more information about submodules, see gitsubmodules(7)."),
			new GitCommand("subtree", "Merge subtrees together and split repository into subtrees",
@"git subtree [<options>] -P <prefix> add <local-commit>
git subtree [<options>] -P <prefix> add <repository> <remote-ref>
git subtree [<options>] -P <prefix> merge <local-commit>
git subtree [<options>] -P <prefix> split [<local-commit>]


git subtree [<options>] -P <prefix> pull <repository> <remote-ref>
git subtree [<options>] -P <prefix> push <repository> <refspec>",
		@"Subtrees allow subprojects to be included within a subdirectory
of the main project, optionally including the subproject’s
entire history.

For example, you could include the source code for a library
as a subdirectory of your application.

Subtrees are not to be confused with submodules, which are meant for
the same task. Unlike submodules, subtrees do not need any special
constructions (like .gitmodules files or gitlinks) be present in
your repository, and do not force end-users of your
repository to do anything special or to understand how subtrees
work. A subtree is just a subdirectory that can be
committed to, branched, and merged along with your project in
any way you want."),
			new GitCommand("svn", "Bidirectional operation between a Subversion repository and Git",
@"git svn <command> [<options>] [<arguments>]",
		@"git svn is a simple conduit for changesets between Subversion and Git.
It provides a bidirectional flow of changes between a Subversion and a Git
repository.

git svn can track a standard Subversion repository,
following the common ""trunk/branches/tags"" layout, with the --stdlayout option.
It can also follow branches and tags in any layout with the -T/-t/-b options
(see options to init below, and also the clone command).

Once tracking a Subversion repository (with any of the above methods), the Git
repository can be updated from Subversion by the fetch command and
Subversion updated from Git by the dcommit command."),
			new GitCommand("switch", "Switch branches",
@"git switch [<options>] [--no-guess] <branch>
git switch [<options>] --detach [<start-point>]
git switch [<options>] (-c|-C) <new-branch> [<start-point>]
git switch [<options>] --orphan <new-branch>",
		@"Switch to a specified branch. The working tree and the index are
updated to match the branch. All new commits will be added to the tip
of this branch.

Optionally a new branch could be created with either -c, -C,
automatically from a remote branch of same name (see --guess), or
detach the working tree from any branch with --detach, along with
switching.

Switching branches does not require a clean index and working tree
(i.e. no differences compared to HEAD). The operation is aborted
however if the operation leads to loss of local changes, unless told
otherwise with --discard-changes or --merge.

THIS COMMAND IS EXPERIMENTAL. THE BEHAVIOR MAY CHANGE."),
			new GitCommand("symbolic-ref", "Read, modify and delete symbolic refs",
@"git symbolic-ref [-m <reason>] <name> <ref>
git symbolic-ref [-q] [--short] <name>
git symbolic-ref --delete [-q] <name>",
		@"Given one argument, reads which branch head the given symbolic
ref refers to and outputs its path, relative to the .git/
directory.  Typically you would give HEAD as the <name>
argument to see which branch your working tree is on.

Given two arguments, creates or updates a symbolic ref <name> to
point at the given branch <ref>.

Given --delete and an additional argument, deletes the given
symbolic ref.

A symbolic ref is a regular file that stores a string that
begins with ref: refs/.  For example, your .git/HEAD is
a regular file whose contents is ref: refs/heads/master."),
			new GitCommand("tag", "Create, list, delete or verify a tag object signed with GPG",
@"git tag [-a | -s | -u <keyid>] [-f] [-m <msg> | -F <file>] [-e]
        <tagname> [<commit> | <object>]
git tag -d <tagname>…​
git tag [-n[<num>]] -l [--contains <commit>] [--no-contains <commit>]
        [--points-at <object>] [--column[=<options>] | --no-column]
        [--create-reflog] [--sort=<key>] [--format=<format>]
        [--merged <commit>] [--no-merged <commit>] [<pattern>…​]
git tag -v [--format=<format>] <tagname>…​",
		@"Add a tag reference in refs/tags/, unless -d/-l/-v is given
to delete, list or verify tags.

Unless -f is given, the named tag must not yet exist.

If one of -a, -s, or -u <keyid> is passed, the command
creates a tag object, and requires a tag message.  Unless
-m <msg> or -F <file> is given, an editor is started for the user to type
in the tag message.

If -m <msg> or -F <file> is given and -a, -s, and -u <keyid>
are absent, -a is implied.

Otherwise, a tag reference that points directly at the given object
(i.e., a lightweight tag) is created.

A GnuPG signed tag object will be created when -s or -u
<keyid> is used.  When -u <keyid> is not used, the
committer identity for the current user is used to find the
GnuPG key for signing. 	The configuration variable gpg.program
is used to specify custom GnuPG binary."),
			new GitCommand("unpack-file", "Creates a temporary file with a blob's contents",
@"git unpack-file <blob>",
		@"Creates a file holding the contents of the blob specified by sha1. It
returns the name of the temporary file in the following format:
	.merge_file_XXXXX"),
			new GitCommand("unpack-objects", "Unpack objects from a packed archive",
@"git unpack-objects [-n] [-q] [-r] [--strict]",
		@"Read a packed archive (.pack) from the standard input, expanding
the objects contained within and writing them into the repository in
""loose"" (one object per file) format.

Objects that already exist in the repository will not be unpacked
from the packfile.  Therefore, nothing will be unpacked if you use
this command on a packfile that exists within the target repository.

See git-repack(1) for options to generate
new packs and replace existing ones."),
			new GitCommand("update-index", "Register file contents in the working tree to the index",
@"git update-index
             [--add] [--remove | --force-remove] [--replace]
             [--refresh] [-q] [--unmerged] [--ignore-missing]
             [(--cacheinfo <mode>,<object>,<file>)…​]
             [--chmod=(+|-)x]
             [--[no-]assume-unchanged]
             [--[no-]skip-worktree]
             [--[no-]ignore-skip-worktree-entries]
             [--[no-]fsmonitor-valid]
             [--ignore-submodules]
             [--[no-]split-index]
             [--[no-|test-|force-]untracked-cache]
             [--[no-]fsmonitor]
             [--really-refresh] [--unresolve] [--again | -g]
             [--info-only] [--index-info]
             [-z] [--stdin] [--index-version <n>]
             [--verbose]
             [--] [<file>…​]",
		@"Modifies the index. Each file mentioned is updated into the index and
any unmerged or needs updating state is cleared.

See also git-add(1) for a more user-friendly way to do some of
the most common operations on the index.

The way git update-index handles files it is told about can be modified
using the various options:"),
			new GitCommand("update-ref", "Update the object name stored in a ref safely",
@"git update-ref [-m <reason>] [--no-deref] (-d <ref> [<oldvalue>] | [--create-reflog] <ref> <newvalue> [<oldvalue>] | --stdin [-z])",
		@"Given two arguments, stores the <newvalue> in the <ref>, possibly
dereferencing the symbolic refs.  E.g. git update-ref HEAD
<newvalue> updates the current branch head to the new object.

Given three arguments, stores the <newvalue> in the <ref>,
possibly dereferencing the symbolic refs, after verifying that
the current value of the <ref> matches <oldvalue>.
E.g. git update-ref refs/heads/master <newvalue> <oldvalue>
updates the master branch head to <newvalue> only if its current
value is <oldvalue>.  You can specify 40 ""0"" or an empty string
as <oldvalue> to make sure that the ref you are creating does
not exist.

It also allows a ""ref"" file to be a symbolic pointer to another
ref file by starting with the four-byte header sequence of
""ref:""."),
			new GitCommand("update-server-info", "Update auxiliary info file to help dumb servers",
@"git update-server-info",
		@"A dumb server that does not do on-the-fly pack generations must
have some auxiliary information files in $GIT_DIR/info and
$GIT_OBJECT_DIRECTORY/info directories to help clients discover
what references and packs the server has.  This command
generates such auxiliary files."),
			new GitCommand("upload-archive", "Send archive back to git-archive",
@"git upload-archive <directory>",
		@"Invoked by git archive --remote and sends a generated archive to the
other end over the Git protocol.

This command is usually not invoked directly by the end user.  The UI
for the protocol is on the git archive side, and the program pair
is meant to be used to get an archive from a remote repository."),
			new GitCommand("upload-pack", "Send objects packed back to git-fetch-pack",
@"git-upload-pack [--[no-]strict] [--timeout=<n>] [--stateless-rpc]
                  [--advertise-refs] <directory>",
		@"Invoked by git fetch-pack, learns what
objects the other side is missing, and sends them after packing.

This command is usually not invoked directly by the end user.
The UI for the protocol is on the git fetch-pack side, and the
program pair is meant to be used to pull updates from a remote
repository.  For push operations, see git send-pack."),
			new GitCommand("var", "Show a Git logical variable",
@"git var ( -l | <variable> )",
		@"Prints a Git logical variable."),
			new GitCommand("verify-commit", "Check the GPG signature of commits",
@"git verify-commit <commit>…​",
		@"Validates the GPG signature created by git commit -S."),
			new GitCommand("verify-pack", "Validate packed Git archive files",
@"git verify-pack [-v|--verbose] [-s|--stat-only] [--] <pack>.idx …​",
		@"Reads given idx file for packed Git archive created with the
git pack-objects command and verifies idx file and the
corresponding pack file."),
			new GitCommand("verify-tag", "Check the GPG signature of tags",
@"git verify-tag [--format=<format>] <tag>…​",
		@"Validates the gpg signature created by git tag."),
			new GitCommand("version", "Display version information about Git",
@"git version [--build-options]",
		@"With no options given, the version of git is printed on the standard output.

Note that git --version is identical to git version because the
former is internally converted into the latter."),
			new GitCommand("web--browse", "Git helper script to launch a web browser",
@"git web--browse [<options>] (<URL>|<file>)…​",
		@"This script tries, as much as possible, to display the URLs and FILEs
that are passed as arguments, as HTML pages in new tabs on an already
opened web browser.

The following browsers (or commands) are currently supported:



firefox (this is the default under X Window when not using KDE)


iceweasel


seamonkey


iceape


chromium (also supported as chromium-browser)


google-chrome (also supported as chrome)


konqueror (this is the default under KDE, see Note about konqueror below)


opera


w3m (this is the default outside graphical environments)


elinks


links


lynx


dillo


open (this is the default under Mac OS X GUI)


start (this is the default under MinGW)


cygstart (this is the default under Cygwin)


xdg-open



Custom commands may also be specified."),
			new GitCommand("whatchanged", "Show logs with difference each commit introduces",
@"git whatchanged <option>…​",
		@"Shows commit logs and diff output each commit introduces.

New users are encouraged to use git-log(1) instead.  The
whatchanged command is essentially the same as git-log(1)
but defaults to show the raw format diff output and to skip merges.

The command is kept primarily for historical reasons; fingers of
many people who learned Git long before git log was invented by
reading Linux kernel mailing list are trained to type it."),
			new GitCommand("worktree", "Manage multiple working trees",
@"git worktree add [-f] [--detach] [--checkout] [--lock [--reason <string>]] [-b <new-branch>] <path> [<commit-ish>]
git worktree list [-v | --porcelain [-z]]
git worktree lock [--reason <string>] <worktree>
git worktree move <worktree> <new-path>
git worktree prune [-n] [-v] [--expire <expire>]
git worktree remove [-f] <worktree>
git worktree repair [<path>…​]
git worktree unlock <worktree>",
		@"Manage multiple working trees attached to the same repository.

A git repository can support multiple working trees, allowing you to check
out more than one branch at a time.  With git worktree add a new working
tree is associated with the repository, along with additional metadata
that differentiates that working tree from others in the same repository.
The working tree, along with this metadata, is called a ""worktree"".

This new worktree is called a ""linked worktree"" as opposed to the ""main
worktree"" prepared by git-init(1) or git-clone(1).
A repository has one main worktree (if it’s not a bare repository) and
zero or more linked worktrees. When you are done with a linked worktree,
remove it with git worktree remove."),
			new GitCommand("write-tree", "Create a tree object from the current index",
@"git write-tree [--missing-ok] [--prefix=<prefix>/]",
		@"Creates a tree object using the current index. The name of the new
tree object is printed to standard output.

The index must be in a fully merged state.

Conceptually, git write-tree sync()s the current index contents
into a set of tree files.
In order to have that match what is actually in your directory right
now, you need to have done a git update-index phase before you did the
git write-tree.")         
            #endregion
        };

        public string Name { get; }
        public string CommandDesc { get; }

        public string Synopsis { get; }

        public string Description { get; }

        public GitCommand(string name, string commandDesc, string synopsis, string description)
        {
            Name = name;
            CommandDesc = commandDesc;
            Synopsis = synopsis;
            Description = description;
        }

        public static GitCommandOption[] GetOptions(string name, bool resolveAliases = true)
        {
            return name switch
            {
               	"add" => new GitCommandOption[] {
					new GitCommandOption("<pathspec>…​", "<pathspec>…​", @"Files to add content from.  Fileglobs (e.g. *.c) can be given to add all matching files.  Also a leading directory name (e.g. dir to add dir/file1 and dir/file2) can be given to update the index to match the current state of the directory as a whole (e.g. specifying dir will record not just a file dir/file1 modified in the working tree, a file dir/file2 added to the working tree, but also a file dir/file3 removed from the working tree). Note that older versions of Git used to ignore removed files; use --no-all option if you want to add modified or new files but ignore removed ones.  For more details about the <pathspec> syntax, see the pathspec entry in gitglossary."),
					new GitCommandOption("--", "--", @"This option can be used to separate command-line options from the list of files, (useful when filenames might be mistaken for command-line options)."),
					new GitCommandOption("--all", "--all", @"Update the index not only where the working tree has a file matching <pathspec> but also where the index already has an entry. This adds, modifies, and removes index entries to match the working tree.  If no <pathspec> is given when -A option is used, all files in the entire working tree are updated (old versions of Git used to limit the update to the current directory and its subdirectories)."),
					new GitCommandOption("--chmod", "--chmod=(+|-)x", @"Override the executable bit of the added files.  The executable bit is only changed in the index, the files on disk are left unchanged."),
					new GitCommandOption("--dry-run", "--dry-run", @"Don’t actually add the file(s), just show if they exist and/or will be ignored."),
					new GitCommandOption("--edit", "--edit", @"Open the diff vs. the index in an editor and let the user edit it.  After the editor was closed, adjust the hunk headers and apply the patch to the index.  The intent of this option is to pick and choose lines of the patch to apply, or even to modify the contents of lines to be staged. This can be quicker and more flexible than using the interactive hunk selector. However, it is easy to confuse oneself and create a patch that does not apply to the index. See EDITING PATCHES below."),
					new GitCommandOption("--force", "--force", @"Allow adding otherwise ignored files."),
					new GitCommandOption("--ignore-errors", "--ignore-errors", @"If some files could not be added because of errors indexing them, do not abort the operation, but continue adding the others. The command shall still exit with non-zero status. The configuration variable add.ignoreErrors can be set to true to make this the default behaviour."),
					new GitCommandOption("--ignore-missing", "--ignore-missing", @"This option can only be used together with --dry-run. By using this option the user can check if any of the given files would be ignored, no matter if they are already present in the work tree or not."),
					new GitCommandOption("--ignore-removal", "--ignore-removal", @"Update the index by adding new files that are unknown to the index and files modified in the working tree, but ignore files that have been removed from the working tree.  This option is a no-op when no <pathspec> is used.  This option is primarily to help users who are used to older versions of Git, whose ""git add <pathspec>…​"" was a synonym for ""git add --no-all <pathspec>…​"", i.e. ignored removed files."),
					new GitCommandOption("--intent-to-add", "--intent-to-add", @"Record only the fact that the path will be added later. An entry for the path is placed in the index with no content. This is useful for, among other things, showing the unstaged content of such files with git diff and committing them with git commit -a."),
					new GitCommandOption("--interactive", "--interactive", @"Add modified contents in the working tree interactively to the index. Optional path arguments may be supplied to limit operation to a subset of the working tree. See “Interactive mode” for details."),
					new GitCommandOption("--no-all", "--no-all", @"Update the index by adding new files that are unknown to the index and files modified in the working tree, but ignore files that have been removed from the working tree.  This option is a no-op when no <pathspec> is used.  This option is primarily to help users who are used to older versions of Git, whose ""git add <pathspec>…​"" was a synonym for ""git add --no-all <pathspec>…​"", i.e. ignored removed files."),
					new GitCommandOption("--no-ignore-removal", "--no-ignore-removal", @"Update the index not only where the working tree has a file matching <pathspec> but also where the index already has an entry. This adds, modifies, and removes index entries to match the working tree.  If no <pathspec> is given when -A option is used, all files in the entire working tree are updated (old versions of Git used to limit the update to the current directory and its subdirectories)."),
					new GitCommandOption("--no-warn-embedded-repo", "--no-warn-embedded-repo", @"By default, git add will warn when adding an embedded repository to the index without using git submodule add to create an entry in .gitmodules. This option will suppress the warning (e.g., if you are manually performing operations on submodules)."),
					new GitCommandOption("--patch", "--patch", @"Interactively choose hunks of patch between the index and the work tree and add them to the index. This gives the user a chance to review the difference before adding modified contents to the index.  This effectively runs add --interactive, but bypasses the initial command menu and directly jumps to the patch subcommand. See “Interactive mode” for details."),
					new GitCommandOption("--pathspec-file-nul", "--pathspec-file-nul", @"Only meaningful with --pathspec-from-file. Pathspec elements are separated with NUL character and all other characters are taken literally (including newlines and quotes)."),
					new GitCommandOption("--pathspec-from-file", "--pathspec-from-file=<file>", @"Pathspec is passed in <file> instead of commandline args. If <file> is exactly - then standard input is used. Pathspec elements are separated by LF or CR/LF. Pathspec elements can be quoted as explained for the configuration variable core.quotePath (see git-config). See also --pathspec-file-nul and global --literal-pathspecs."),
					new GitCommandOption("--refresh", "--refresh", @"Don’t add the file(s), but only refresh their stat() information in the index."),
					new GitCommandOption("--renormalize", "--renormalize", @"Apply the ""clean"" process freshly to all tracked files to forcibly add them again to the index.  This is useful after changing core.autocrlf configuration or the text attribute in order to correct files added with wrong CRLF/LF line endings. This option implies -u."),
					new GitCommandOption("--sparse", "--sparse", @"Allow updating index entries outside of the sparse-checkout cone. Normally, git add refuses to update index entries whose paths do not fit within the sparse-checkout cone, since those files might be removed from the working tree without warning. See git-sparse-checkout for more details."),
					new GitCommandOption("--update", "--update", @"Update the index just where it already has an entry matching <pathspec>.  This removes as well as modifies index entries to match the working tree, but adds no new files.  If no <pathspec> is given when -u option is used, all tracked files in the entire working tree are updated (old versions of Git used to limit the update to the current directory and its subdirectories)."),
					new GitCommandOption("--verbose", "--verbose", @"Be verbose."),
					new GitCommandOption("-A", "-A", @"Update the index not only where the working tree has a file matching <pathspec> but also where the index already has an entry. This adds, modifies, and removes index entries to match the working tree.  If no <pathspec> is given when -A option is used, all files in the entire working tree are updated (old versions of Git used to limit the update to the current directory and its subdirectories)."),
					new GitCommandOption("-e", "-e", @"Open the diff vs. the index in an editor and let the user edit it.  After the editor was closed, adjust the hunk headers and apply the patch to the index.  The intent of this option is to pick and choose lines of the patch to apply, or even to modify the contents of lines to be staged. This can be quicker and more flexible than using the interactive hunk selector. However, it is easy to confuse oneself and create a patch that does not apply to the index. See EDITING PATCHES below."),
					new GitCommandOption("-f", "-f", @"Allow adding otherwise ignored files."),
					new GitCommandOption("-i", "-i", @"Add modified contents in the working tree interactively to the index. Optional path arguments may be supplied to limit operation to a subset of the working tree. See “Interactive mode” for details."),
					new GitCommandOption("-n", "-n", @"Don’t actually add the file(s), just show if they exist and/or will be ignored."),
					new GitCommandOption("-N", "-N", @"Record only the fact that the path will be added later. An entry for the path is placed in the index with no content. This is useful for, among other things, showing the unstaged content of such files with git diff and committing them with git commit -a."),
					new GitCommandOption("-p", "-p", @"Interactively choose hunks of patch between the index and the work tree and add them to the index. This gives the user a chance to review the difference before adding modified contents to the index.  This effectively runs add --interactive, but bypasses the initial command menu and directly jumps to the patch subcommand. See “Interactive mode” for details."),
					new GitCommandOption("-u", "-u", @"Update the index just where it already has an entry matching <pathspec>.  This removes as well as modifies index entries to match the working tree, but adds no new files.  If no <pathspec> is given when -u option is used, all tracked files in the entire working tree are updated (old versions of Git used to limit the update to the current directory and its subdirectories)."),
					new GitCommandOption("-v", "-v", @"Be verbose."),
				}, 
	"am" => new GitCommandOption[] {
					new GitCommandOption("--[no-]keep-cr", "--[no-]keep-cr", @"With --keep-cr, call git mailsplit (see git-mailsplit) with the same option, to prevent it from stripping CR at the end of lines. am.keepcr configuration variable can be used to specify the default behaviour.  --no-keep-cr is useful to override am.keepcr."),
					new GitCommandOption("--3way", "--3way", @"When the patch does not apply cleanly, fall back on 3-way merge if the patch records the identity of blobs it is supposed to apply to and we have those blobs available locally. --no-3way can be used to override am.threeWay configuration variable. For more information, see am.threeWay in git-config."),
					new GitCommandOption("--abort", "--abort", @"Restore the original branch and abort the patching operation. Revert contents of files involved in the am operation to their pre-am state."),
					new GitCommandOption("--allow-empty", "--allow-empty", @"After a patch failure on an input e-mail message lacking a patch, create an empty commit with the contents of the e-mail message as its log message."),
					new GitCommandOption("--committer-date-is-author-date", "--committer-date-is-author-date", @"By default the command records the date from the e-mail message as the commit author date, and uses the time of commit creation as the committer date. This allows the user to lie about the committer date by using the same value as the author date."),
					new GitCommandOption("--continue", "--continue", @"After a patch failure (e.g. attempting to apply conflicting patch), the user has applied it by hand and the index file stores the result of the application. Make a commit using the authorship and commit log extracted from the e-mail message and the current index file, and continue."),
					new GitCommandOption("--directory", "--directory=<dir>", @"These flags are passed to the git apply (see git-apply) program that applies the patch."),
					new GitCommandOption("--empty", "--empty=(stop|drop|keep)", @"By default, or when the option is set to stop, the command errors out on an input e-mail message lacking a patch and stops into the middle of the current am session. When this option is set to drop, skip such an e-mail message instead. When this option is set to keep, create an empty commit, recording the contents of the e-mail message as its log."),
					new GitCommandOption("--exclude", "--exclude=<path>", @"These flags are passed to the git apply (see git-apply) program that applies the patch."),
					new GitCommandOption("--gpg-sign[", "--gpg-sign[=<keyid>]", @"GPG-sign commits. The keyid argument is optional and defaults to the committer identity; if specified, it must be stuck to the option without a space. --no-gpg-sign is useful to countermand both commit.gpgSign configuration variable, and earlier --gpg-sign."),
					new GitCommandOption("--ignore-date", "--ignore-date", @"By default the command records the date from the e-mail message as the commit author date, and uses the time of commit creation as the committer date. This allows the user to lie about the author date by using the same value as the committer date."),
					new GitCommandOption("--ignore-space-change", "--ignore-space-change", @"These flags are passed to the git apply (see git-apply) program that applies the patch."),
					new GitCommandOption("--ignore-whitespace", "--ignore-whitespace", @"These flags are passed to the git apply (see git-apply) program that applies the patch."),
					new GitCommandOption("--include", "--include=<path>", @"These flags are passed to the git apply (see git-apply) program that applies the patch."),
					new GitCommandOption("--interactive", "--interactive", @"Run interactively."),
					new GitCommandOption("--keep", "--keep", @"Pass -k flag to git mailinfo (see git-mailinfo)."),
					new GitCommandOption("--keep-non-patch", "--keep-non-patch", @"Pass -b flag to git mailinfo (see git-mailinfo)."),
					new GitCommandOption("--message-id", "--message-id", @"Pass the -m flag to git mailinfo (see git-mailinfo), so that the Message-ID header is added to the commit message. The am.messageid configuration variable can be used to specify the default behaviour."),
					new GitCommandOption("--no-3way", "--no-3way", @"When the patch does not apply cleanly, fall back on 3-way merge if the patch records the identity of blobs it is supposed to apply to and we have those blobs available locally. --no-3way can be used to override am.threeWay configuration variable. For more information, see am.threeWay in git-config."),
					new GitCommandOption("--no-gpg-sign", "--no-gpg-sign", @"GPG-sign commits. The keyid argument is optional and defaults to the committer identity; if specified, it must be stuck to the option without a space. --no-gpg-sign is useful to countermand both commit.gpgSign configuration variable, and earlier --gpg-sign."),
					new GitCommandOption("--no-message-id", "--no-message-id", @"Do not add the Message-ID header to the commit message. no-message-id is useful to override am.messageid."),
					new GitCommandOption("--no-rerere-autoupdate", "--no-rerere-autoupdate", @"Allow the rerere mechanism to update the index with the result of auto-conflict resolution if possible."),
					new GitCommandOption("--no-scissors", "--no-scissors", @"Ignore scissors lines (see git-mailinfo)."),
					new GitCommandOption("--no-utf8", "--no-utf8", @"Pass -n flag to git mailinfo (see git-mailinfo)."),
					new GitCommandOption("--patch-format", "--patch-format", @"By default the command will try to detect the patch format automatically. This option allows the user to bypass the automatic detection and specify the patch format that the patch(es) should be interpreted as. Valid formats are mbox, mboxrd, stgit, stgit-series and hg."),
					new GitCommandOption("--quiet", "--quiet", @"Be quiet. Only print error messages."),
					new GitCommandOption("--quit", "--quit", @"Abort the patching operation but keep HEAD and the index untouched."),
					new GitCommandOption("--quoted-cr", "--quoted-cr=<action>", @"This flag will be passed down to git mailinfo (see git-mailinfo)."),
					new GitCommandOption("--reject", "--reject", @"These flags are passed to the git apply (see git-apply) program that applies the patch."),
					new GitCommandOption("--rerere-autoupdate", "--rerere-autoupdate", @"Allow the rerere mechanism to update the index with the result of auto-conflict resolution if possible."),
					new GitCommandOption("--resolved", "--resolved", @"After a patch failure (e.g. attempting to apply conflicting patch), the user has applied it by hand and the index file stores the result of the application. Make a commit using the authorship and commit log extracted from the e-mail message and the current index file, and continue."),
					new GitCommandOption("--resolvemsg", "--resolvemsg=<msg>", @"When a patch failure occurs, <msg> will be printed to the screen before exiting.  This overrides the standard message informing you to use --continue or --skip to handle the failure.  This is solely for internal use between git rebase and git am."),
					new GitCommandOption("--scissors", "--scissors", @"Remove everything in body before a scissors line (see git-mailinfo). Can be activated by default using the mailinfo.scissors configuration variable."),
					new GitCommandOption("--show-current-patch[", "--show-current-patch[=(diff|raw)]", @"Show the message at which git am has stopped due to conflicts.  If raw is specified, show the raw contents of the e-mail message; if diff, show the diff portion only. Defaults to raw."),
					new GitCommandOption("--signoff", "--signoff", @"Add a Signed-off-by trailer to the commit message, using the committer identity of yourself. See the signoff option in git-commit for more information."),
					new GitCommandOption("--skip", "--skip", @"Skip the current patch.  This is only meaningful when restarting an aborted patch."),
					new GitCommandOption("--utf8", "--utf8", @"Pass -u flag to git mailinfo (see git-mailinfo). The proposed commit log message taken from the e-mail is re-coded into UTF-8 encoding (configuration variable i18n.commitEncoding can be used to specify project’s preferred encoding if it is not UTF-8).  This was optional in prior versions of git, but now it is the default.   You can use --no-utf8 to override this."),
					new GitCommandOption("--whitespace", "--whitespace=<option>", @"These flags are passed to the git apply (see git-apply) program that applies the patch."),
					new GitCommandOption("-3", "-3", @"When the patch does not apply cleanly, fall back on 3-way merge if the patch records the identity of blobs it is supposed to apply to and we have those blobs available locally. --no-3way can be used to override am.threeWay configuration variable. For more information, see am.threeWay in git-config."),
					new GitCommandOption("-c", "-c", @"Remove everything in body before a scissors line (see git-mailinfo). Can be activated by default using the mailinfo.scissors configuration variable."),
					new GitCommandOption("-C<n>", "-C<n>", @"These flags are passed to the git apply (see git-apply) program that applies the patch."),
					new GitCommandOption("-i", "-i", @"Run interactively."),
					new GitCommandOption("-k", "-k", @"Pass -k flag to git mailinfo (see git-mailinfo)."),
					new GitCommandOption("-m", "-m", @"Pass the -m flag to git mailinfo (see git-mailinfo), so that the Message-ID header is added to the commit message. The am.messageid configuration variable can be used to specify the default behaviour."),
					new GitCommandOption("-p<n>", "-p<n>", @"These flags are passed to the git apply (see git-apply) program that applies the patch."),
					new GitCommandOption("-q", "-q", @"Be quiet. Only print error messages."),
					new GitCommandOption("-r", "-r", @"After a patch failure (e.g. attempting to apply conflicting patch), the user has applied it by hand and the index file stores the result of the application. Make a commit using the authorship and commit log extracted from the e-mail message and the current index file, and continue."),
					new GitCommandOption("-s", "-s", @"Add a Signed-off-by trailer to the commit message, using the committer identity of yourself. See the signoff option in git-commit for more information."),
					new GitCommandOption("-S[<keyid>]", "-S[<keyid>]", @"GPG-sign commits. The keyid argument is optional and defaults to the committer identity; if specified, it must be stuck to the option without a space. --no-gpg-sign is useful to countermand both commit.gpgSign configuration variable, and earlier --gpg-sign."),
					new GitCommandOption("-u", "-u", @"Pass -u flag to git mailinfo (see git-mailinfo). The proposed commit log message taken from the e-mail is re-coded into UTF-8 encoding (configuration variable i18n.commitEncoding can be used to specify project’s preferred encoding if it is not UTF-8).  This was optional in prior versions of git, but now it is the default.   You can use --no-utf8 to override this."),
					new GitCommandOption("(<mbox>|<Maildir>)…​", "(<mbox>|<Maildir>)…​", @"The list of mailbox files to read patches from. If you do not supply this argument, the command reads from the standard input. If you supply directories, they will be treated as Maildirs."),
				}, 
	"annotate" => new GitCommandOption[] {
					new GitCommandOption("--[no-]progress", "--[no-]progress", @"Progress status is reported on the standard error stream by default when it is attached to a terminal. This flag enables progress reporting even if not attached to a terminal. Can’t use --progress together with --porcelain or --incremental."),
					new GitCommandOption("--color-by-age", "--color-by-age", @"Color line annotations depending on the age of the line in the default format. The color.blame.highlightRecent config option controls what color is used for each range of age."),
					new GitCommandOption("--color-lines", "--color-lines", @"Color line annotations in the default format differently if they come from the same commit as the preceding line. This makes it easier to distinguish code blocks introduced by different commits. The color defaults to cyan and can be adjusted using the color.blame.repeatedLines config option."),
					new GitCommandOption("--contents", "--contents <file>", @"When <rev> is not specified, the command annotates the changes starting backwards from the working tree copy. This flag makes the command pretend as if the working tree copy has the contents of the named file (specify - to make the command read from the standard input)."),
					new GitCommandOption("--date", "--date <format>", @"Specifies the format used to output dates. If --date is not provided, the value of the blame.date config variable is used. If the blame.date config variable is also not set, the iso format is used. For supported values, see the discussion of the --date option at git-log."),
					new GitCommandOption("--encoding", "--encoding=<encoding>", @"Specifies the encoding used to output author names and commit summaries. Setting it to none makes blame output unconverted data. For more information see the discussion about encoding in the git-log manual page."),
					new GitCommandOption("--first-parent", "--first-parent", @"Follow only the first parent commit upon seeing a merge commit. This option can be used to determine when a line was introduced to a particular integration branch, rather than when it was introduced to the history overall."),
					new GitCommandOption("--ignore-rev", "--ignore-rev <rev>", @"Ignore changes made by the revision when assigning blame, as if the change never happened.  Lines that were changed or added by an ignored commit will be blamed on the previous commit that changed that line or nearby lines.  This option may be specified multiple times to ignore more than one revision.  If the blame.markIgnoredLines config option is set, then lines that were changed by an ignored commit and attributed to another commit will be marked with a ? in the blame output.  If the blame.markUnblamableLines config option is set, then those lines touched by an ignored commit that we could not attribute to another revision are marked with a *."),
					new GitCommandOption("--ignore-revs-file", "--ignore-revs-file <file>", @"Ignore revisions listed in file, which must be in the same format as an fsck.skipList.  This option may be repeated, and these files will be processed after any files specified with the blame.ignoreRevsFile config option.  An empty file name, """", will clear the list of revs from previously processed files."),
					new GitCommandOption("--incremental", "--incremental", @"Show the result incrementally in a format designed for machine consumption."),
					new GitCommandOption("--line-porcelain", "--line-porcelain", @"Show the porcelain format, but output commit information for each line, not just the first time a commit is referenced. Implies --porcelain."),
					new GitCommandOption("--porcelain", "--porcelain", @"Show in a format designed for machine consumption."),
					new GitCommandOption("--reverse", "--reverse <rev>..<rev>", @"Walk history forward instead of backward. Instead of showing the revision in which a line appeared, this shows the last revision in which a line has existed. This requires a range of revision like START..END where the path to blame exists in START.  git blame --reverse START is taken as git blame --reverse START..HEAD for convenience."),
					new GitCommandOption("--root", "--root", @"Do not treat root commits as boundaries.  This can also be controlled via the blame.showRoot config option."),
					new GitCommandOption("--show-stats", "--show-stats", @"Include additional statistics at the end of blame output."),
					new GitCommandOption("-b", "-b", @"Show blank SHA-1 for boundary commits.  This can also be controlled via the blame.blankBoundary config option."),
					new GitCommandOption("-C[<num>]", "-C[<num>]", @"In addition to -M, detect lines moved or copied from other files that were modified in the same commit.  This is useful when you reorganize your program and move code around across files.  When this option is given twice, the command additionally looks for copies from other files in the commit that creates the file. When this option is given three times, the command additionally looks for copies from other files in any commit.  <num> is optional but it is the lower bound on the number of alphanumeric characters that Git must detect as moving/copying between files for it to associate those lines with the parent commit. And the default value is 40. If there are more than one -C options given, the <num> argument of the last -C will take effect."),
					new GitCommandOption("-h", "-h", @"Show help message."),
					new GitCommandOption("-l", "-l", @"Show long rev (Default: off)."),
					new GitCommandOption("-L", "-L :<funcname>", @"Annotate only the line range given by <start>,<end>, or by the function name regex <funcname>. May be specified multiple times. Overlapping ranges are allowed.  <start> and <end> are optional. -L <start> or -L <start>, spans from <start> to end of file. -L ,<end> spans from start of file to <end>.   <start> and <end> can take one of these forms:     number  If <start> or <end> is a number, it specifies an absolute line number (lines count from 1).    /regex/  This form will use the first line matching the given POSIX regex. If <start> is a regex, it will search from the end of the previous -L range, if any, otherwise from the start of file. If <start> is ^/regex/, it will search from the start of file. If <end> is a regex, it will search starting at the line given by <start>.    +offset or -offset  This is only valid for <end> and will specify a number of lines before or after the line given by <start>.      If :<funcname> is given in place of <start> and <end>, it is a regular expression that denotes the range from the first funcname line that matches <funcname>, up to the next funcname line. :<funcname> searches from the end of the previous -L range, if any, otherwise from the start of file. ^:<funcname> searches from the start of file. The function names are determined in the same way as git diff works out patch hunk headers (see Defining a custom hunk-header in gitattributes)."),
					new GitCommandOption("-L", "-L <start>,<end>", @"Annotate only the line range given by <start>,<end>, or by the function name regex <funcname>. May be specified multiple times. Overlapping ranges are allowed.  <start> and <end> are optional. -L <start> or -L <start>, spans from <start> to end of file. -L ,<end> spans from start of file to <end>.   <start> and <end> can take one of these forms:     number  If <start> or <end> is a number, it specifies an absolute line number (lines count from 1).    /regex/  This form will use the first line matching the given POSIX regex. If <start> is a regex, it will search from the end of the previous -L range, if any, otherwise from the start of file. If <start> is ^/regex/, it will search from the start of file. If <end> is a regex, it will search starting at the line given by <start>.    +offset or -offset  This is only valid for <end> and will specify a number of lines before or after the line given by <start>.      If :<funcname> is given in place of <start> and <end>, it is a regular expression that denotes the range from the first funcname line that matches <funcname>, up to the next funcname line. :<funcname> searches from the end of the previous -L range, if any, otherwise from the start of file. ^:<funcname> searches from the start of file. The function names are determined in the same way as git diff works out patch hunk headers (see Defining a custom hunk-header in gitattributes)."),
					new GitCommandOption("-M[<num>]", "-M[<num>]", @"Detect moved or copied lines within a file. When a commit moves or copies a block of lines (e.g. the original file has A and then B, and the commit changes it to B and then A), the traditional blame algorithm notices only half of the movement and typically blames the lines that were moved up (i.e. B) to the parent and assigns blame to the lines that were moved down (i.e. A) to the child commit.  With this option, both groups of lines are blamed on the parent by running extra passes of inspection.  <num> is optional but it is the lower bound on the number of alphanumeric characters that Git must detect as moving/copying within a file for it to associate those lines with the parent commit. The default value is 20."),
					new GitCommandOption("-p", "-p", @"Show in a format designed for machine consumption."),
					new GitCommandOption("-S", "-S <revs-file>", @"Use revisions from revs-file instead of calling git-rev-list."),
					new GitCommandOption("-t", "-t", @"Show raw timestamp (Default: off)."),
				}, 
	"apply" => new GitCommandOption[] {
					new GitCommandOption("<patch>…​", "<patch>…​", @"The files to read the patch from.  - can be used to read from the standard input."),
					new GitCommandOption("--3way", "--3way", @"Attempt 3-way merge if the patch records the identity of blobs it is supposed to apply to and we have those blobs available locally, possibly leaving the conflict markers in the files in the working tree for the user to resolve.  This option implies the --index option unless the --cached option is used, and is incompatible with the --reject option. When used with the --cached option, any conflicts are left at higher stages in the cache."),
					new GitCommandOption("--allow-binary-replacement", "--allow-binary-replacement", @"Historically we did not allow binary patch applied without an explicit permission from the user, and this flag was the way to do so.  Currently we always allow binary patch application, so this is a no-op."),
					new GitCommandOption("--allow-empty", "--allow-empty", @"Don’t return error for patches containing no diff. This includes empty patches and patches with commit text only."),
					new GitCommandOption("--apply", "--apply", @"If you use any of the options marked ""Turns off apply"" above, git apply reads and outputs the requested information without actually applying the patch.  Give this flag after those flags to also apply the patch."),
					new GitCommandOption("--binary", "--binary", @"Historically we did not allow binary patch applied without an explicit permission from the user, and this flag was the way to do so.  Currently we always allow binary patch application, so this is a no-op."),
					new GitCommandOption("--build-fake-ancestor", "--build-fake-ancestor=<file>", @"Newer git diff output has embedded index information for each blob to help identify the original version that the patch applies to.  When this flag is given, and if the original versions of the blobs are available locally, builds a temporary index containing those blobs.  When a pure mode change is encountered (which has no index information), the information is read from the current index instead."),
					new GitCommandOption("--cached", "--cached", @"Apply the patch to just the index, without touching the working tree. If --check is in effect, merely check that it would apply cleanly to the index entry."),
					new GitCommandOption("--check", "--check", @"Instead of applying the patch, see if the patch is applicable to the current working tree and/or the index file and detects errors.  Turns off ""apply""."),
					new GitCommandOption("--directory", "--directory=<root>", @"Prepend <root> to all filenames.  If a ""-p"" argument was also passed, it is applied before prepending the new root.  For example, a patch that talks about updating a/git-gui.sh to b/git-gui.sh can be applied to the file in the working tree modules/git-gui/git-gui.sh by running git apply --directory=modules/git-gui."),
					new GitCommandOption("--exclude", "--exclude=<path-pattern>", @"Don’t apply changes to files matching the given path pattern. This can be useful when importing patchsets, where you want to exclude certain files or directories."),
					new GitCommandOption("--ignore-space-change", "--ignore-space-change", @"When applying a patch, ignore changes in whitespace in context lines if necessary. Context lines will preserve their whitespace, and they will not undergo whitespace fixing regardless of the value of the --whitespace option. New lines will still be fixed, though."),
					new GitCommandOption("--ignore-whitespace", "--ignore-whitespace", @"When applying a patch, ignore changes in whitespace in context lines if necessary. Context lines will preserve their whitespace, and they will not undergo whitespace fixing regardless of the value of the --whitespace option. New lines will still be fixed, though."),
					new GitCommandOption("--inaccurate-eof", "--inaccurate-eof", @"Under certain circumstances, some versions of diff do not correctly detect a missing new-line at the end of the file. As a result, patches created by such diff programs do not record incomplete lines correctly. This option adds support for applying such patches by working around this bug."),
					new GitCommandOption("--include", "--include=<path-pattern>", @"Apply changes to files matching the given path pattern. This can be useful when importing patchsets, where you want to include certain files or directories.  When --exclude and --include patterns are used, they are examined in the order they appear on the command line, and the first match determines if a patch to each path is used.  A patch to a path that does not match any include/exclude pattern is used by default if there is no include pattern on the command line, and ignored if there is any include pattern."),
					new GitCommandOption("--index", "--index", @"Apply the patch to both the index and the working tree (or merely check that it would apply cleanly to both if --check is in effect). Note that --index expects index entries and working tree copies for relevant paths to be identical (their contents and metadata such as file mode must match), and will raise an error if they are not, even if the patch would apply cleanly to both the index and the working tree in isolation."),
					new GitCommandOption("--intent-to-add", "--intent-to-add", @"When applying the patch only to the working tree, mark new files to be added to the index later (see --intent-to-add option in git-add). This option is ignored unless running in a Git repository and --index is not specified. Note that --index could be implied by other options such as --cached or --3way."),
					new GitCommandOption("--no-add", "--no-add", @"When applying a patch, ignore additions made by the patch.  This can be used to extract the common part between two files by first running diff on them and applying the result with this option, which would apply the deletion part but not the addition part."),
					new GitCommandOption("--numstat", "--numstat", @"Similar to --stat, but shows the number of added and deleted lines in decimal notation and the pathname without abbreviation, to make it more machine friendly.  For binary files, outputs two - instead of saying 0 0.  Turns off ""apply""."),
					new GitCommandOption("--quiet", "--quiet", @"Suppress stderr output. Messages about patch status and progress will not be printed."),
					new GitCommandOption("--recount", "--recount", @"Do not trust the line counts in the hunk headers, but infer them by inspecting the patch (e.g. after editing the patch without adjusting the hunk headers appropriately)."),
					new GitCommandOption("--reject", "--reject", @"For atomicity, git apply by default fails the whole patch and does not touch the working tree when some of the hunks do not apply.  This option makes it apply the parts of the patch that are applicable, and leave the rejected hunks in corresponding *.rej files."),
					new GitCommandOption("--reverse", "--reverse", @"Apply the patch in reverse."),
					new GitCommandOption("--stat", "--stat", @"Instead of applying the patch, output diffstat for the input.  Turns off ""apply""."),
					new GitCommandOption("--summary", "--summary", @"Instead of applying the patch, output a condensed summary of information obtained from git diff extended headers, such as creations, renames and mode changes. Turns off ""apply""."),
					new GitCommandOption("--unidiff-zero", "--unidiff-zero", @"By default, git apply expects that the patch being applied is a unified diff with at least one line of context. This provides good safety measures, but breaks down when applying a diff generated with --unified=0. To bypass these checks use --unidiff-zero.  Note, for the reasons stated above usage of context-free patches is discouraged."),
					new GitCommandOption("--unsafe-paths", "--unsafe-paths", @"By default, a patch that affects outside the working area (either a Git controlled working tree, or the current working directory when ""git apply"" is used as a replacement of GNU patch) is rejected as a mistake (or a mischief).  When git apply is used as a ""better GNU patch"", the user can pass the --unsafe-paths option to override this safety check.  This option has no effect when --index or --cached is in use."),
					new GitCommandOption("--verbose", "--verbose", @"Report progress to stderr. By default, only a message about the current patch being applied will be printed. This option will cause additional information to be reported."),
					new GitCommandOption("--whitespace", "--whitespace=<action>", @"When applying a patch, detect a new or modified line that has whitespace errors.  What are considered whitespace errors is controlled by core.whitespace configuration.  By default, trailing whitespaces (including lines that solely consist of whitespaces) and a space character that is immediately followed by a tab character inside the initial indent of the line are considered whitespace errors.  By default, the command outputs warning messages but applies the patch. When git-apply is used for statistics and not applying a patch, it defaults to nowarn.   You can use different <action> values to control this behavior:     nowarn turns off the trailing whitespace warning.   warn outputs warnings for a few such errors, but applies the patch as-is (default).   fix outputs warnings for a few such errors, and applies the patch after fixing them (strip is a synonym --- the tool used to consider only trailing whitespace characters as errors, and the fix involved stripping them, but modern Gits do more).   error outputs warnings for a few such errors, and refuses to apply the patch.   error-all is similar to error but shows all errors."),
					new GitCommandOption("-3", "-3", @"Attempt 3-way merge if the patch records the identity of blobs it is supposed to apply to and we have those blobs available locally, possibly leaving the conflict markers in the files in the working tree for the user to resolve.  This option implies the --index option unless the --cached option is used, and is incompatible with the --reject option. When used with the --cached option, any conflicts are left at higher stages in the cache."),
					new GitCommandOption("-C<n>", "-C<n>", @"Ensure at least <n> lines of surrounding context match before and after each change.  When fewer lines of surrounding context exist they all must match.  By default no context is ever ignored."),
					new GitCommandOption("-p<n>", "-p<n>", @"Remove <n> leading path components (separated by slashes) from traditional diff paths. E.g., with -p2, a patch against a/dir/file will be applied directly to file. The default is 1."),
					new GitCommandOption("-q", "-q", @"Suppress stderr output. Messages about patch status and progress will not be printed."),
					new GitCommandOption("-R", "-R", @"Apply the patch in reverse."),
					new GitCommandOption("-v", "-v", @"Report progress to stderr. By default, only a message about the current patch being applied will be printed. This option will cause additional information to be reported."),
					new GitCommandOption("-z", "-z", @"When --numstat has been given, do not munge pathnames, but use a NUL-terminated machine-readable format.  Without this option, pathnames with ""unusual"" characters are quoted as explained for the configuration variable core.quotePath (see git-config)."),
				}, 
	"archive" => new GitCommandOption[] {
					new GitCommandOption("<extra>", "<extra>", @"This can be any options that the archiver backend understands. See next section."),
					new GitCommandOption("<path>", "<path>", @"Without an optional path parameter, all files and subdirectories of the current working directory are included in the archive. If one or more paths are specified, only these are included."),
					new GitCommandOption("<tree-ish>", "<tree-ish>", @"The tree or commit to produce an archive for."),
					new GitCommandOption("--add-file", "--add-file=<file>", @"Add a non-tracked file to the archive.  Can be repeated to add multiple files.  The path of the file in the archive is built by concatenating the value for --prefix (if any) and the basename of <file>."),
					new GitCommandOption("--exec", "--exec=<git-upload-archive>", @"Used with --remote to specify the path to the git-upload-archive on the remote side."),
					new GitCommandOption("--format", "--format=<fmt>", @"Format of the resulting archive: tar or zip. If this option is not given, and the output file is specified, the format is inferred from the filename if possible (e.g. writing to ""foo.zip"" makes the output to be in the zip format). Otherwise the output format is tar."),
					new GitCommandOption("--list", "--list", @"Show all available formats."),
					new GitCommandOption("--output", "--output=<file>", @"Write the archive to <file> instead of stdout."),
					new GitCommandOption("--prefix", "--prefix=<prefix>/", @"Prepend <prefix>/ to each filename in the archive."),
					new GitCommandOption("--remote", "--remote=<repo>", @"Instead of making a tar archive from the local repository, retrieve a tar archive from a remote repository. Note that the remote repository may place restrictions on which sha1 expressions may be allowed in <tree-ish>. See git-upload-archive for details."),
					new GitCommandOption("--verbose", "--verbose", @"Report progress to stderr."),
					new GitCommandOption("--worktree-attributes", "--worktree-attributes", @"Look for attributes in .gitattributes files in the working tree as well (see ATTRIBUTES)."),
					new GitCommandOption("-l", "-l", @"Show all available formats."),
					new GitCommandOption("-o", "-o <file>", @"Write the archive to <file> instead of stdout."),
					new GitCommandOption("-v", "-v", @"Report progress to stderr."),
				}, 
	"bash" => new GitCommandOption[] {
					new GitCommandOption("--app-id", "--app-id=<command>", @"Allows the user to override the ID used e.g. in Windows' Task Bar. Defaults to GitForWindows.Bash."),
					new GitCommandOption("--append-quote", "--append-quote", @"These options do not make sense in the context of git-bash; They are merely inherited from the Git Wrapper (see the GIT WRAPPER section below)."),
					new GitCommandOption("--cd", "--cd=<directory>", @"By default, Git Bash will not change the current directory; To allow e.g. for Windows Explorer integration (""Git Bash Here""), the --cd=<directory> option can be used to change the current directory before running the interactive Bash.  The --cd-to-home option can be used to change the current directory to the user’s home directory (as determined by the environment variable HOME). The --no-cd option can be used to override --cd options that precede it."),
					new GitCommandOption("--cd-to-home", "--cd-to-home", @"By default, Git Bash will not change the current directory; To allow e.g. for Windows Explorer integration (""Git Bash Here""), the --cd=<directory> option can be used to change the current directory before running the interactive Bash.  The --cd-to-home option can be used to change the current directory to the user’s home directory (as determined by the environment variable HOME). The --no-cd option can be used to override --cd options that precede it."),
					new GitCommandOption("--command", "--command=<command>", @"Allows the user to ask for a different command to be specified. Defaults to usr\\bin\\mintty.exe. If the specified command is not an absolute path, it is interpreted relative to git-bash.exe."),
					new GitCommandOption("--hide", "--hide", @"These options do not make sense in the context of git-bash; They are merely inherited from the Git Wrapper (see the GIT WRAPPER section below)."),
					new GitCommandOption("--minimal-search-path", "--minimal-search-path", @"By default, Git Bash will adjust the PATH not only to include the git executable, but also all of the Unix-y tools (such as sed, awk, etc). With --minimal-search-path, it will be adjusted so that only the git, git-gui and gitk executables are found, as well as the scripts start-ssh-agent.cmd and start-ssh-pageant.cmd."),
					new GitCommandOption("--needs-console", "--needs-console", @"These options do not make sense in the context of git-bash; They are merely inherited from the Git Wrapper (see the GIT WRAPPER section below)."),
					new GitCommandOption("--no-append-quote", "--no-append-quote", @"These options do not make sense in the context of git-bash; They are merely inherited from the Git Wrapper (see the GIT WRAPPER section below)."),
					new GitCommandOption("--no-cd", "--no-cd", @"By default, Git Bash will not change the current directory; To allow e.g. for Windows Explorer integration (""Git Bash Here""), the --cd=<directory> option can be used to change the current directory before running the interactive Bash.  The --cd-to-home option can be used to change the current directory to the user’s home directory (as determined by the environment variable HOME). The --no-cd option can be used to override --cd options that precede it."),
					new GitCommandOption("--no-hide", "--no-hide", @"These options do not make sense in the context of git-bash; They are merely inherited from the Git Wrapper (see the GIT WRAPPER section below)."),
					new GitCommandOption("--no-minimal-search-path", "--no-minimal-search-path", @"By default, Git Bash will adjust the PATH not only to include the git executable, but also all of the Unix-y tools (such as sed, awk, etc). With --minimal-search-path, it will be adjusted so that only the git, git-gui and gitk executables are found, as well as the scripts start-ssh-agent.cmd and start-ssh-pageant.cmd."),
					new GitCommandOption("--no-needs-console", "--no-needs-console", @"These options do not make sense in the context of git-bash; They are merely inherited from the Git Wrapper (see the GIT WRAPPER section below)."),
				}, 
	"bisect" => new GitCommandOption[] {
					new GitCommandOption("--first-parent", "--first-parent", @"Follow only the first parent commit upon seeing a merge commit.   In detecting regressions introduced through the merging of a branch, the merge commit will be identified as introduction of the bug and its ancestors will be ignored.   This option is particularly useful in avoiding false positives when a merged branch contained broken or non-buildable commits, but the merge itself was OK."),
					new GitCommandOption("--no-checkout", "--no-checkout", @"Do not checkout the new working tree at each iteration of the bisection process. Instead just update a special reference named BISECT_HEAD to make it point to the commit that should be tested.   This option may be useful when the test you would perform in each step does not require a checked out tree.   If the repository is bare, --no-checkout is assumed."),
				}, 
	"blame" => new GitCommandOption[] {
					new GitCommandOption("--[no-]progress", "--[no-]progress", @"Progress status is reported on the standard error stream by default when it is attached to a terminal. This flag enables progress reporting even if not attached to a terminal. Can’t use --progress together with --porcelain or --incremental."),
					new GitCommandOption("--abbrev", "--abbrev=<n>", @"Instead of using the default 7+1 hexadecimal digits as the abbreviated object name, use <m>+1 digits, where <m> is at least <n> but ensures the commit object names are unique. Note that 1 column is used for a caret to mark the boundary commit."),
					new GitCommandOption("--color-by-age", "--color-by-age", @"Color line annotations depending on the age of the line in the default format. The color.blame.highlightRecent config option controls what color is used for each range of age."),
					new GitCommandOption("--color-lines", "--color-lines", @"Color line annotations in the default format differently if they come from the same commit as the preceding line. This makes it easier to distinguish code blocks introduced by different commits. The color defaults to cyan and can be adjusted using the color.blame.repeatedLines config option."),
					new GitCommandOption("--contents", "--contents <file>", @"When <rev> is not specified, the command annotates the changes starting backwards from the working tree copy. This flag makes the command pretend as if the working tree copy has the contents of the named file (specify - to make the command read from the standard input)."),
					new GitCommandOption("--date", "--date <format>", @"Specifies the format used to output dates. If --date is not provided, the value of the blame.date config variable is used. If the blame.date config variable is also not set, the iso format is used. For supported values, see the discussion of the --date option at git-log."),
					new GitCommandOption("--encoding", "--encoding=<encoding>", @"Specifies the encoding used to output author names and commit summaries. Setting it to none makes blame output unconverted data. For more information see the discussion about encoding in the git-log manual page."),
					new GitCommandOption("--first-parent", "--first-parent", @"Follow only the first parent commit upon seeing a merge commit. This option can be used to determine when a line was introduced to a particular integration branch, rather than when it was introduced to the history overall."),
					new GitCommandOption("--ignore-rev", "--ignore-rev <rev>", @"Ignore changes made by the revision when assigning blame, as if the change never happened.  Lines that were changed or added by an ignored commit will be blamed on the previous commit that changed that line or nearby lines.  This option may be specified multiple times to ignore more than one revision.  If the blame.markIgnoredLines config option is set, then lines that were changed by an ignored commit and attributed to another commit will be marked with a ? in the blame output.  If the blame.markUnblamableLines config option is set, then those lines touched by an ignored commit that we could not attribute to another revision are marked with a *."),
					new GitCommandOption("--ignore-revs-file", "--ignore-revs-file <file>", @"Ignore revisions listed in file, which must be in the same format as an fsck.skipList.  This option may be repeated, and these files will be processed after any files specified with the blame.ignoreRevsFile config option.  An empty file name, """", will clear the list of revs from previously processed files."),
					new GitCommandOption("--incremental", "--incremental", @"Show the result incrementally in a format designed for machine consumption."),
					new GitCommandOption("--line-porcelain", "--line-porcelain", @"Show the porcelain format, but output commit information for each line, not just the first time a commit is referenced. Implies --porcelain."),
					new GitCommandOption("--porcelain", "--porcelain", @"Show in a format designed for machine consumption."),
					new GitCommandOption("--reverse", "--reverse <rev>..<rev>", @"Walk history forward instead of backward. Instead of showing the revision in which a line appeared, this shows the last revision in which a line has existed. This requires a range of revision like START..END where the path to blame exists in START.  git blame --reverse START is taken as git blame --reverse START..HEAD for convenience."),
					new GitCommandOption("--root", "--root", @"Do not treat root commits as boundaries.  This can also be controlled via the blame.showRoot config option."),
					new GitCommandOption("--score-debug", "--score-debug", @"Include debugging information related to the movement of lines between files (see -C) and lines moved within a file (see -M).  The first number listed is the score. This is the number of alphanumeric characters detected as having been moved between or within files.  This must be above a certain threshold for git blame to consider those lines of code to have been moved."),
					new GitCommandOption("--show-email", "--show-email", @"Show the author email instead of author name (Default: off). This can also be controlled via the blame.showEmail config option."),
					new GitCommandOption("--show-name", "--show-name", @"Show the filename in the original commit.  By default the filename is shown if there is any line that came from a file with a different name, due to rename detection."),
					new GitCommandOption("--show-number", "--show-number", @"Show the line number in the original commit (Default: off)."),
					new GitCommandOption("--show-stats", "--show-stats", @"Include additional statistics at the end of blame output."),
					new GitCommandOption("-b", "-b", @"Show blank SHA-1 for boundary commits.  This can also be controlled via the blame.blankBoundary config option."),
					new GitCommandOption("-c", "-c", @"Use the same output mode as git-annotate (Default: off)."),
					new GitCommandOption("-C[<num>]", "-C[<num>]", @"In addition to -M, detect lines moved or copied from other files that were modified in the same commit.  This is useful when you reorganize your program and move code around across files.  When this option is given twice, the command additionally looks for copies from other files in the commit that creates the file. When this option is given three times, the command additionally looks for copies from other files in any commit.  <num> is optional but it is the lower bound on the number of alphanumeric characters that Git must detect as moving/copying between files for it to associate those lines with the parent commit. And the default value is 40. If there are more than one -C options given, the <num> argument of the last -C will take effect."),
					new GitCommandOption("-e", "-e", @"Show the author email instead of author name (Default: off). This can also be controlled via the blame.showEmail config option."),
					new GitCommandOption("-f", "-f", @"Show the filename in the original commit.  By default the filename is shown if there is any line that came from a file with a different name, due to rename detection."),
					new GitCommandOption("-h", "-h", @"Show help message."),
					new GitCommandOption("-l", "-l", @"Show long rev (Default: off)."),
					new GitCommandOption("-L", "-L :<funcname>", @"Annotate only the line range given by <start>,<end>, or by the function name regex <funcname>. May be specified multiple times. Overlapping ranges are allowed.  <start> and <end> are optional. -L <start> or -L <start>, spans from <start> to end of file. -L ,<end> spans from start of file to <end>.   <start> and <end> can take one of these forms:     number  If <start> or <end> is a number, it specifies an absolute line number (lines count from 1).    /regex/  This form will use the first line matching the given POSIX regex. If <start> is a regex, it will search from the end of the previous -L range, if any, otherwise from the start of file. If <start> is ^/regex/, it will search from the start of file. If <end> is a regex, it will search starting at the line given by <start>.    +offset or -offset  This is only valid for <end> and will specify a number of lines before or after the line given by <start>.      If :<funcname> is given in place of <start> and <end>, it is a regular expression that denotes the range from the first funcname line that matches <funcname>, up to the next funcname line. :<funcname> searches from the end of the previous -L range, if any, otherwise from the start of file. ^:<funcname> searches from the start of file. The function names are determined in the same way as git diff works out patch hunk headers (see Defining a custom hunk-header in gitattributes)."),
					new GitCommandOption("-L", "-L <start>,<end>", @"Annotate only the line range given by <start>,<end>, or by the function name regex <funcname>. May be specified multiple times. Overlapping ranges are allowed.  <start> and <end> are optional. -L <start> or -L <start>, spans from <start> to end of file. -L ,<end> spans from start of file to <end>.   <start> and <end> can take one of these forms:     number  If <start> or <end> is a number, it specifies an absolute line number (lines count from 1).    /regex/  This form will use the first line matching the given POSIX regex. If <start> is a regex, it will search from the end of the previous -L range, if any, otherwise from the start of file. If <start> is ^/regex/, it will search from the start of file. If <end> is a regex, it will search starting at the line given by <start>.    +offset or -offset  This is only valid for <end> and will specify a number of lines before or after the line given by <start>.      If :<funcname> is given in place of <start> and <end>, it is a regular expression that denotes the range from the first funcname line that matches <funcname>, up to the next funcname line. :<funcname> searches from the end of the previous -L range, if any, otherwise from the start of file. ^:<funcname> searches from the start of file. The function names are determined in the same way as git diff works out patch hunk headers (see Defining a custom hunk-header in gitattributes)."),
					new GitCommandOption("-M[<num>]", "-M[<num>]", @"Detect moved or copied lines within a file. When a commit moves or copies a block of lines (e.g. the original file has A and then B, and the commit changes it to B and then A), the traditional blame algorithm notices only half of the movement and typically blames the lines that were moved up (i.e. B) to the parent and assigns blame to the lines that were moved down (i.e. A) to the child commit.  With this option, both groups of lines are blamed on the parent by running extra passes of inspection.  <num> is optional but it is the lower bound on the number of alphanumeric characters that Git must detect as moving/copying within a file for it to associate those lines with the parent commit. The default value is 20."),
					new GitCommandOption("-n", "-n", @"Show the line number in the original commit (Default: off)."),
					new GitCommandOption("-p", "-p", @"Show in a format designed for machine consumption."),
					new GitCommandOption("-S", "-S <revs-file>", @"Use revisions from revs-file instead of calling git-rev-list."),
					new GitCommandOption("-s", "-s", @"Suppress the author name and timestamp from the output."),
					new GitCommandOption("-t", "-t", @"Show raw timestamp (Default: off)."),
					new GitCommandOption("-w", "-w", @"Ignore whitespace when comparing the parent’s version and the child’s to find where the lines came from."),
				}, 
	"branch" => new GitCommandOption[] {
					new GitCommandOption("<branchname>", "<branchname>", @"The name of the branch to create or delete. The new branch name must pass all checks defined by git-check-ref-format.  Some of these checks may restrict the characters allowed in a branch name."),
					new GitCommandOption("<newbranch>", "<newbranch>", @"The new name for an existing branch. The same restrictions as for <branchname> apply."),
					new GitCommandOption("<oldbranch>", "<oldbranch>", @"The name of an existing branch to rename."),
					new GitCommandOption("<start-point>", "<start-point>", @"The new branch head will point to this commit.  It may be given as a branch name, a commit-id, or a tag.  If this option is omitted, the current HEAD will be used instead."),
					new GitCommandOption("--abbrev", "--abbrev=<n>", @"In the verbose listing that show the commit object name, show the shortest prefix that is at least <n> hexdigits long that uniquely refers the object. The default value is 7 and can be overridden by the core.abbrev config option."),
					new GitCommandOption("--all", "--all", @"List both remote-tracking branches and local branches. Combine with --list to match optional pattern(s)."),
					new GitCommandOption("--color[", "--color[=<when>]", @"Color branches to highlight current, local, and remote-tracking branches. The value must be always (the default), never, or auto."),
					new GitCommandOption("--column[", "--column[=<options>]", @"Display branch listing in columns. See configuration variable column.branch for option syntax. --column and --no-column without options are equivalent to always and never respectively.  This option is only applicable in non-verbose mode."),
					new GitCommandOption("--contains", "--contains [<commit>]", @"Only list branches which contain the specified commit (HEAD if not specified). Implies --list."),
					new GitCommandOption("--copy", "--copy", @"Copy a branch, together with its config and reflog."),
					new GitCommandOption("--create-reflog", "--create-reflog", @"Create the branch’s reflog.  This activates recording of all changes made to the branch ref, enabling use of date based sha1 expressions such as ""<branchname>@{yesterday}"". Note that in non-bare repositories, reflogs are usually enabled by default by the core.logAllRefUpdates config option. The negated form --no-create-reflog only overrides an earlier --create-reflog, but currently does not negate the setting of core.logAllRefUpdates."),
					new GitCommandOption("--delete", "--delete", @"Delete a branch. The branch must be fully merged in its upstream branch, or in HEAD if no upstream was set with --track or --set-upstream-to."),
					new GitCommandOption("--edit-description", "--edit-description", @"Open an editor and edit the text to explain what the branch is for, to be used by various other commands (e.g. format-patch, request-pull, and merge (if enabled)). Multi-line explanations may be used."),
					new GitCommandOption("--force", "--force", @"Reset <branchname> to <startpoint>, even if <branchname> exists already. Without -f, git branch refuses to change an existing branch. In combination with -d (or --delete), allow deleting the branch irrespective of its merged status, or whether it even points to a valid commit. In combination with -m (or --move), allow renaming the branch even if the new branch name already exists, the same applies for -c (or --copy)."),
					new GitCommandOption("--format", "--format <format>", @"A string that interpolates %(fieldname) from a branch ref being shown and the object it points at.  The format is the same as that of git-for-each-ref."),
					new GitCommandOption("--ignore-case", "--ignore-case", @"Sorting and filtering branches are case insensitive."),
					new GitCommandOption("--list", "--list", @"List branches.  With optional <pattern>..., e.g. git branch --list 'maint-*', list only the branches that match the pattern(s)."),
					new GitCommandOption("--merged", "--merged [<commit>]", @"Only list branches whose tips are reachable from the specified commit (HEAD if not specified). Implies --list."),
					new GitCommandOption("--move", "--move", @"Move/rename a branch, together with its config and reflog."),
					new GitCommandOption("--no-abbrev", "--no-abbrev", @"Display the full sha1s in the output listing rather than abbreviating them."),
					new GitCommandOption("--no-color", "--no-color", @"Turn off branch colors, even when the configuration file gives the default to color output. Same as --color=never."),
					new GitCommandOption("--no-column", "--no-column", @"Display branch listing in columns. See configuration variable column.branch for option syntax. --column and --no-column without options are equivalent to always and never respectively.  This option is only applicable in non-verbose mode."),
					new GitCommandOption("--no-contains", "--no-contains [<commit>]", @"Only list branches which don’t contain the specified commit (HEAD if not specified). Implies --list."),
					new GitCommandOption("--no-merged", "--no-merged [<commit>]", @"Only list branches whose tips are not reachable from the specified commit (HEAD if not specified). Implies --list."),
					new GitCommandOption("--no-track", "--no-track", @"Do not set up ""upstream"" configuration, even if the branch.autoSetupMerge configuration variable is set."),
					new GitCommandOption("--points-at", "--points-at <object>", @"Only list branches of the given object."),
					new GitCommandOption("--quiet", "--quiet", @"Be more quiet when creating or deleting a branch, suppressing non-error messages."),
					new GitCommandOption("--recurse-submodules", "--recurse-submodules", @"THIS OPTION IS EXPERIMENTAL! Causes the current command to recurse into submodules if submodule.propagateBranches is enabled. See submodule.propagateBranches in git-config. Currently, only branch creation is supported.  When used in branch creation, a new branch <branchname> will be created in the superproject and all of the submodules in the superproject’s <start-point>. In submodules, the branch will point to the submodule commit in the superproject’s <start-point> but the branch’s tracking information will be set up based on the submodule’s branches and remotes e.g. git branch --recurse-submodules topic origin/main will create the submodule branch ""topic"" that points to the submodule commit in the superproject’s ""origin/main"", but tracks the submodule’s ""origin/main""."),
					new GitCommandOption("--remotes", "--remotes", @"List or delete (if used with -d) the remote-tracking branches. Combine with --list to match the optional pattern(s)."),
					new GitCommandOption("--set-upstream", "--set-upstream", @"As this option had confusing syntax, it is no longer supported. Please use --track or --set-upstream-to instead."),
					new GitCommandOption("--set-upstream-to", "--set-upstream-to=<upstream>", @"Set up <branchname>'s tracking information so <upstream> is considered <branchname>'s upstream branch. If no <branchname> is specified, then it defaults to the current branch."),
					new GitCommandOption("--show-current", "--show-current", @"Print the name of the current branch. In detached HEAD state, nothing is printed."),
					new GitCommandOption("--sort", "--sort=<key>", @"Sort based on the key given. Prefix - to sort in descending order of the value. You may use the --sort=<key> option multiple times, in which case the last key becomes the primary key. The keys supported are the same as those in git for-each-ref. Sort order defaults to the value configured for the branch.sort variable if exists, or to sorting based on the full refname (including refs/... prefix). This lists detached HEAD (if present) first, then local branches and finally remote-tracking branches. See git-config."),
					new GitCommandOption("--track[", "--track[=(direct|inherit)]", @"When creating a new branch, set up branch.<name>.remote and branch.<name>.merge configuration entries to set ""upstream"" tracking configuration for the new branch. This configuration will tell git to show the relationship between the two branches in git status and git branch -v. Furthermore, it directs git pull without arguments to pull from the upstream when the new branch is checked out.  The exact upstream branch is chosen depending on the optional argument: -t, --track, or --track=direct means to use the start-point branch itself as the upstream; --track=inherit means to copy the upstream configuration of the start-point branch.   --track=direct is the default when the start point is a remote-tracking branch. Set the branch.autoSetupMerge configuration variable to false if you want git switch, git checkout and git branch to always behave as if --no-track were given. Set it to always if you want this behavior when the start-point is either a local or remote-tracking branch. Set it to inherit if you want to copy the tracking configuration from the branch point.   See git-pull and git-config for additional discussion on how the branch.<name>.remote and branch.<name>.merge options are used."),
					new GitCommandOption("--unset-upstream", "--unset-upstream", @"Remove the upstream information for <branchname>. If no branch is specified it defaults to the current branch."),
					new GitCommandOption("--verbose", "--verbose", @"When in list mode, show sha1 and commit subject line for each head, along with relationship to upstream branch (if any). If given twice, print the path of the linked worktree (if any) and the name of the upstream branch, as well (see also git remote show <remote>).  Note that the current worktree’s HEAD will not have its path printed (it will always be your current directory)."),
					new GitCommandOption("-a", "-a", @"List both remote-tracking branches and local branches. Combine with --list to match optional pattern(s)."),
					new GitCommandOption("-C", "-C", @"Shortcut for --copy --force."),
					new GitCommandOption("-c", "-c", @"Copy a branch, together with its config and reflog."),
					new GitCommandOption("-d", "-d", @"Delete a branch. The branch must be fully merged in its upstream branch, or in HEAD if no upstream was set with --track or --set-upstream-to."),
					new GitCommandOption("-D", "-D", @"Shortcut for --delete --force."),
					new GitCommandOption("-f", "-f", @"Reset <branchname> to <startpoint>, even if <branchname> exists already. Without -f, git branch refuses to change an existing branch. In combination with -d (or --delete), allow deleting the branch irrespective of its merged status, or whether it even points to a valid commit. In combination with -m (or --move), allow renaming the branch even if the new branch name already exists, the same applies for -c (or --copy)."),
					new GitCommandOption("-i", "-i", @"Sorting and filtering branches are case insensitive."),
					new GitCommandOption("-l", "-l", @"List branches.  With optional <pattern>..., e.g. git branch --list 'maint-*', list only the branches that match the pattern(s)."),
					new GitCommandOption("-M", "-M", @"Shortcut for --move --force."),
					new GitCommandOption("-m", "-m", @"Move/rename a branch, together with its config and reflog."),
					new GitCommandOption("-q", "-q", @"Be more quiet when creating or deleting a branch, suppressing non-error messages."),
					new GitCommandOption("-r", "-r", @"List or delete (if used with -d) the remote-tracking branches. Combine with --list to match the optional pattern(s)."),
					new GitCommandOption("-t", "-t", @"When creating a new branch, set up branch.<name>.remote and branch.<name>.merge configuration entries to set ""upstream"" tracking configuration for the new branch. This configuration will tell git to show the relationship between the two branches in git status and git branch -v. Furthermore, it directs git pull without arguments to pull from the upstream when the new branch is checked out.  The exact upstream branch is chosen depending on the optional argument: -t, --track, or --track=direct means to use the start-point branch itself as the upstream; --track=inherit means to copy the upstream configuration of the start-point branch.   --track=direct is the default when the start point is a remote-tracking branch. Set the branch.autoSetupMerge configuration variable to false if you want git switch, git checkout and git branch to always behave as if --no-track were given. Set it to always if you want this behavior when the start-point is either a local or remote-tracking branch. Set it to inherit if you want to copy the tracking configuration from the branch point.   See git-pull and git-config for additional discussion on how the branch.<name>.remote and branch.<name>.merge options are used."),
					new GitCommandOption("-u", "-u <upstream>", @"Set up <branchname>'s tracking information so <upstream> is considered <branchname>'s upstream branch. If no <branchname> is specified, then it defaults to the current branch."),
					new GitCommandOption("-v", "-v", @"When in list mode, show sha1 and commit subject line for each head, along with relationship to upstream branch (if any). If given twice, print the path of the linked worktree (if any) and the name of the upstream branch, as well (see also git remote show <remote>).  Note that the current worktree’s HEAD will not have its path printed (it will always be your current directory)."),
					new GitCommandOption("-vv", "-vv", @"When in list mode, show sha1 and commit subject line for each head, along with relationship to upstream branch (if any). If given twice, print the path of the linked worktree (if any) and the name of the upstream branch, as well (see also git remote show <remote>).  Note that the current worktree’s HEAD will not have its path printed (it will always be your current directory)."),
				}, 
	"bugreport" => new GitCommandOption[] {
					new GitCommandOption("--output-directory", "--output-directory <path>", @"Place the resulting bug report file in <path> instead of the current directory."),
					new GitCommandOption("--suffix", "--suffix <format>", @"Specify an alternate suffix for the bugreport name, to create a file named git-bugreport-<formatted suffix>. This should take the form of a strftime format string; the current local time will be used."),
					new GitCommandOption("-o", "-o <path>", @"Place the resulting bug report file in <path> instead of the current directory."),
					new GitCommandOption("-s", "-s <format>", @"Specify an alternate suffix for the bugreport name, to create a file named git-bugreport-<formatted suffix>. This should take the form of a strftime format string; the current local time will be used."),
				}, 
	"bundle" => new GitCommandOption[] {
					new GitCommandOption("<git-rev-list-args>", "<git-rev-list-args>", @"A list of arguments, acceptable to git rev-parse and git rev-list (and containing a named ref, see SPECIFYING REFERENCES below), that specifies the specific objects and references to transport.  For example, master~10..master causes the current master reference to be packaged along with all objects added since its 10th ancestor commit.  There is no explicit limit to the number of references and objects that may be packaged."),
					new GitCommandOption("--all-progress", "--all-progress", @"When --stdout is specified then progress report is displayed during the object count and compression phases but inhibited during the write-out phase. The reason is that in some cases the output stream is directly linked to another command which may wish to display progress status of its own as it processes incoming pack data. This flag is like --progress except that it forces progress report for the write-out phase as well even if --stdout is used."),
					new GitCommandOption("--all-progress-implied", "--all-progress-implied", @"This is used to imply --all-progress whenever progress display is activated.  Unlike --all-progress this flag doesn’t actually force any progress display by itself."),
					new GitCommandOption("--progress", "--progress", @"Progress status is reported on the standard error stream by default when it is attached to a terminal, unless -q is specified. This flag forces progress status even if the standard error stream is not directed to a terminal."),
					new GitCommandOption("--quiet", "--quiet", @"This flag makes the command not to report its progress on the standard error stream."),
					new GitCommandOption("--version", "--version=<version>", @"Specify the bundle version.  Version 2 is the older format and can only be used with SHA-1 repositories; the newer version 3 contains capabilities that permit extensions. The default is the oldest supported format, based on the hash algorithm in use."),
					new GitCommandOption("-q", "-q", @"This flag makes the command not to report its progress on the standard error stream."),
					new GitCommandOption("[<refname>…​]", "[<refname>…​]", @"A list of references used to limit the references reported as available. This is principally of use to git fetch, which expects to receive only those references asked for and not necessarily everything in the pack (in this case, git bundle acts like git fetch-pack)."),
					new GitCommandOption("create", "create [options] <file> <git-rev-list-args>", @"Used to create a bundle named file.  This requires the <git-rev-list-args> arguments to define the bundle contents. options contains the options specific to the git bundle create subcommand."),
					new GitCommandOption("list-heads", "list-heads <file>", @"Lists the references defined in the bundle.  If followed by a list of references, only references matching those given are printed out."),
					new GitCommandOption("unbundle", "unbundle <file>", @"Passes the objects in the bundle to git index-pack for storage in the repository, then prints the names of all defined references. If a list of references is given, only references matching those in the list are printed. This command is really plumbing, intended to be called only by git fetch."),
					new GitCommandOption("verify", "verify <file>", @"Used to check that a bundle file is valid and will apply cleanly to the current repository.  This includes checks on the bundle format itself as well as checking that the prerequisite commits exist and are fully linked in the current repository. Then, git bundle prints a list of missing commits, if any. Finally, information about additional capabilities, such as ""object filter"", is printed. See ""Capabilities"" in link:technical/bundle-format.html for more information. The exit code is zero for success, but will be nonzero if the bundle file is invalid."),
				}, 
	"cat-file" => new GitCommandOption[] {
					new GitCommandOption("<object>", "<object>", @"The name of the object to show. For a more complete list of ways to spell object names, see the ""SPECIFYING REVISIONS"" section in gitrevisions."),
					new GitCommandOption("<type>", "<type>", @"Typically this matches the real type of <object> but asking for a type that can trivially be dereferenced from the given <object> is also permitted.  An example is to ask for a ""tree"" with <object> being a commit object that contains it, or to ask for a ""blob"" with <object> being a tag object that points at it."),
					new GitCommandOption("--allow-unknown-type", "--allow-unknown-type", @"Allow -s or -t to query broken/corrupt objects of unknown type."),
					new GitCommandOption("--batch", "--batch=<format>", @"Print object information and contents for each object provided on stdin.  May not be combined with any other options or arguments except --textconv or --filters, in which case the input lines also need to specify the path, separated by whitespace.  See the section BATCH OUTPUT below for details."),
					new GitCommandOption("--batch", "--batch", @"Print object information and contents for each object provided on stdin.  May not be combined with any other options or arguments except --textconv or --filters, in which case the input lines also need to specify the path, separated by whitespace.  See the section BATCH OUTPUT below for details."),
					new GitCommandOption("--batch-all-objects", "--batch-all-objects", @"Instead of reading a list of objects on stdin, perform the requested batch operation on all objects in the repository and any alternate object stores (not just reachable objects). Requires --batch or --batch-check be specified. By default, the objects are visited in order sorted by their hashes; see also --unordered below. Objects are presented as-is, without respecting the ""replace"" mechanism of git-replace."),
					new GitCommandOption("--batch-check", "--batch-check=<format>", @"Print object information for each object provided on stdin.  May not be combined with any other options or arguments except --textconv or --filters, in which case the input lines also need to specify the path, separated by whitespace.  See the section BATCH OUTPUT below for details."),
					new GitCommandOption("--batch-check", "--batch-check", @"Print object information for each object provided on stdin.  May not be combined with any other options or arguments except --textconv or --filters, in which case the input lines also need to specify the path, separated by whitespace.  See the section BATCH OUTPUT below for details."),
					new GitCommandOption("--batch-command", "--batch-command", @"Enter a command mode that reads commands and arguments from stdin. May only be combined with --buffer, --textconv or --filters. In the case of --textconv or --filters, the input lines also need to specify the path, separated by whitespace. See the section BATCH OUTPUT below for details.  --batch-command recognizes the following commands:      contents <object>  Print object contents for object reference <object>. This corresponds to the output of --batch.  info <object>  Print object info for object reference <object>. This corresponds to the output of --batch-check.  flush  Used with --buffer to execute all preceding commands that were issued since the beginning or since the last flush was issued. When --buffer is used, no output will come until a flush is issued. When --buffer is not used, commands are flushed each time without issuing flush."),
					new GitCommandOption("--batch-command", "--batch-command=<format>", @"Enter a command mode that reads commands and arguments from stdin. May only be combined with --buffer, --textconv or --filters. In the case of --textconv or --filters, the input lines also need to specify the path, separated by whitespace. See the section BATCH OUTPUT below for details.  --batch-command recognizes the following commands:      contents <object>  Print object contents for object reference <object>. This corresponds to the output of --batch.  info <object>  Print object info for object reference <object>. This corresponds to the output of --batch-check.  flush  Used with --buffer to execute all preceding commands that were issued since the beginning or since the last flush was issued. When --buffer is used, no output will come until a flush is issued. When --buffer is not used, commands are flushed each time without issuing flush."),
					new GitCommandOption("--buffer", "--buffer", @"Normally batch output is flushed after each object is output, so that a process can interactively read and write from cat-file. With this option, the output uses normal stdio buffering; this is much more efficient when invoking --batch-check or --batch-command on a large number of objects."),
					new GitCommandOption("--filters", "--filters", @"Show the content as converted by the filters configured in the current working tree for the given <path> (i.e. smudge filters, end-of-line conversion, etc). In this case, <object> has to be of the form <tree-ish>:<path>, or :<path>."),
					new GitCommandOption("--follow-symlinks", "--follow-symlinks", @"With --batch or --batch-check, follow symlinks inside the repository when requesting objects with extended SHA-1 expressions of the form tree-ish:path-in-tree.  Instead of providing output about the link itself, provide output about the linked-to object.  If a symlink points outside the tree-ish (e.g. a link to /foo or a root-level link to ../foo), the portion of the link which is outside the tree will be printed.  This option does not (currently) work correctly when an object in the index is specified (e.g. :link instead of HEAD:link) rather than one in the tree.   This option cannot (currently) be used unless --batch or --batch-check is used.   For example, consider a git repository containing:      f: a file containing ""hello\n"" link: a symlink to f dir/link: a symlink to ../f plink: a symlink to ../f alink: a symlink to /etc/passwd      For a regular file f, echo HEAD:f | git cat-file --batch would print      ce013625030ba8dba906f756967f9e9ca394464a blob 6      And echo HEAD:link | git cat-file --batch --follow-symlinks would print the same thing, as would HEAD:dir/link, as they both point at HEAD:f.   Without --follow-symlinks, these would print data about the symlink itself.  In the case of HEAD:link, you would see      4d1ae35ba2c8ec712fa2a379db44ad639ca277bd blob 1      Both plink and alink point outside the tree, so they would respectively print:      symlink 4 ../f     symlink 11 /etc/passwd"),
					new GitCommandOption("--path", "--path=<path>", @"For use with --textconv or --filters, to allow specifying an object name and a path separately, e.g. when it is difficult to figure out the revision from which the blob came."),
					new GitCommandOption("--textconv", "--textconv", @"Show the content as transformed by a textconv filter. In this case, <object> has to be of the form <tree-ish>:<path>, or :<path> in order to apply the filter to the content recorded in the index at <path>."),
					new GitCommandOption("--unordered", "--unordered", @"When --batch-all-objects is in use, visit objects in an order which may be more efficient for accessing the object contents than hash order. The exact details of the order are unspecified, but if you do not require a specific order, this should generally result in faster output, especially with --batch.  Note that cat-file will still show each object only once, even if it is stored multiple times in the repository."),
					new GitCommandOption("-e", "-e", @"Exit with zero status if <object> exists and is a valid object. If <object> is of an invalid format exit with non-zero and emits an error on stderr."),
					new GitCommandOption("-p", "-p", @"Pretty-print the contents of <object> based on its type."),
					new GitCommandOption("-s", "-s", @"Instead of the content, show the object size identified by <object>."),
					new GitCommandOption("-t", "-t", @"Instead of the content, show the object type identified by <object>."),
					new GitCommandOption("contents", "contents <object>", @"Print object contents for object reference <object>. This corresponds to the output of --batch."),
					new GitCommandOption("flush", "flush", @"Used with --buffer to execute all preceding commands that were issued since the beginning or since the last flush was issued. When --buffer is used, no output will come until a flush is issued. When --buffer is not used, commands are flushed each time without issuing flush."),
					new GitCommandOption("info", "info <object>", @"Print object info for object reference <object>. This corresponds to the output of --batch-check."),
				}, 
	"check-attr" => new GitCommandOption[] {
					new GitCommandOption("--", "--", @"Interpret all preceding arguments as attributes and all following arguments as path names."),
					new GitCommandOption("--cached", "--cached", @"Consider .gitattributes in the index only, ignoring the working tree."),
					new GitCommandOption("--stdin", "--stdin", @"Read pathnames from the standard input, one per line, instead of from the command-line."),
					new GitCommandOption("-a,", "-a, --all", @"List all attributes that are associated with the specified paths.  If this option is used, then unspecified attributes will not be included in the output."),
					new GitCommandOption("-z", "-z", @"The output format is modified to be machine-parsable. If --stdin is also given, input paths are separated with a NUL character instead of a linefeed character."),
				}, 
	"check-ignore" => new GitCommandOption[] {
					new GitCommandOption("--no-index", "--no-index", @"Don’t look in the index when undertaking the checks. This can be used to debug why a path became tracked by e.g. git add . and was not ignored by the rules as expected by the user or when developing patterns including negation to match a path previously added with git add -f."),
					new GitCommandOption("--stdin", "--stdin", @"Read pathnames from the standard input, one per line, instead of from the command-line."),
					new GitCommandOption("-n,", "-n, --non-matching", @"Show given paths which don’t match any pattern.	 This only makes sense when --verbose is enabled, otherwise it would not be possible to distinguish between paths which match a pattern and those which don’t."),
					new GitCommandOption("-q,", "-q, --quiet", @"Don’t output anything, just set exit status.  This is only valid with a single pathname."),
					new GitCommandOption("-v,", "-v, --verbose", @"Instead of printing the paths that are excluded, for each path that matches an exclude pattern, print the exclude pattern together with the path.  (Matching an exclude pattern usually means the path is excluded, but if the pattern begins with ""!"" then it is a negated pattern and matching it means the path is NOT excluded.)  For precedence rules within and between exclude sources, see gitignore."),
					new GitCommandOption("-z", "-z", @"The output format is modified to be machine-parsable (see below).  If --stdin is also given, input paths are separated with a NUL character instead of a linefeed character."),
				}, 
	"check-mailmap" => new GitCommandOption[] {
					new GitCommandOption("--stdin", "--stdin", @"Read contacts, one per line, from the standard input after exhausting contacts provided on the command-line."),
				}, 
	"check-ref-format" => new GitCommandOption[] {
					new GitCommandOption("--[no-]allow-onelevel", "--[no-]allow-onelevel", @"Controls whether one-level refnames are accepted (i.e., refnames that do not contain multiple /-separated components).  The default is --no-allow-onelevel."),
					new GitCommandOption("--normalize", "--normalize", @"Normalize refname by removing any leading slash (/) characters and collapsing runs of adjacent slashes between name components into a single slash.  If the normalized refname is valid then print it to standard output and exit with a status of 0, otherwise exit with a non-zero status. (--print is a deprecated way to spell --normalize.)"),
					new GitCommandOption("--refspec-pattern", "--refspec-pattern", @"Interpret <refname> as a reference name pattern for a refspec (as used with remote repositories).  If this option is enabled, <refname> is allowed to contain a single * in the refspec (e.g., foo/bar*/baz or foo/bar*baz/ but not foo/bar*/baz*)."),
				}, 
	"checkout-index" => new GitCommandOption[] {
					new GitCommandOption("--", "--", @"Do not interpret any more arguments as options."),
					new GitCommandOption("--all", "--all", @"checks out all files in the index except for those with the skip-worktree bit set (see --ignore-skip-worktree-bits). Cannot be used together with explicit filenames."),
					new GitCommandOption("--force", "--force", @"forces overwrite of existing files"),
					new GitCommandOption("--ignore-skip-worktree-bits", "--ignore-skip-worktree-bits", @"Check out all files, including those with the skip-worktree bit set."),
					new GitCommandOption("--index", "--index", @"update stat information for the checked out entries in the index file."),
					new GitCommandOption("--no-create", "--no-create", @"Don’t checkout new files, only refresh files already checked out."),
					new GitCommandOption("--prefix", "--prefix=<string>", @"When creating files, prepend <string> (usually a directory including a trailing /)"),
					new GitCommandOption("--quiet", "--quiet", @"be quiet if files exist or are not in the index"),
					new GitCommandOption("--stage", "--stage=<number>|all", @"Instead of checking out unmerged entries, copy out the files from named stage.  <number> must be between 1 and 3. Note: --stage=all automatically implies --temp."),
					new GitCommandOption("--stdin", "--stdin", @"Instead of taking list of paths from the command line, read list of paths from the standard input.  Paths are separated by LF (i.e. one path per line) by default."),
					new GitCommandOption("--temp", "--temp", @"Instead of copying the files to the working directory write the content to temporary files.  The temporary name associations will be written to stdout."),
					new GitCommandOption("-a", "-a", @"checks out all files in the index except for those with the skip-worktree bit set (see --ignore-skip-worktree-bits). Cannot be used together with explicit filenames."),
					new GitCommandOption("-f", "-f", @"forces overwrite of existing files"),
					new GitCommandOption("-n", "-n", @"Don’t checkout new files, only refresh files already checked out."),
					new GitCommandOption("-q", "-q", @"be quiet if files exist or are not in the index"),
					new GitCommandOption("-u", "-u", @"update stat information for the checked out entries in the index file."),
					new GitCommandOption("-z", "-z", @"Only meaningful with --stdin; paths are separated with NUL character instead of LF."),
				}, 
	"checkout" => new GitCommandOption[] {
					new GitCommandOption("<branch>", "<branch>", @"Branch to checkout; if it refers to a branch (i.e., a name that, when prepended with ""refs/heads/"", is a valid ref), then that branch is checked out. Otherwise, if it refers to a valid commit, your HEAD becomes ""detached"" and you are no longer on any branch (see below for details).  You can use the @{-N} syntax to refer to the N-th last branch/commit checked out using ""git checkout"" operation. You may also specify - which is synonymous to @{-1}.   As a special case, you may use A...B as a shortcut for the merge base of A and B if there is exactly one merge base. You can leave out at most one of A and B, in which case it defaults to HEAD."),
					new GitCommandOption("<new-branch>", "<new-branch>", @"Name for the new branch."),
					new GitCommandOption("<pathspec>…​", "<pathspec>…​", @"Limits the paths affected by the operation.  For more details, see the pathspec entry in gitglossary."),
					new GitCommandOption("<start-point>", "<start-point>", @"The name of a commit at which to start the new branch; see git-branch for details. Defaults to HEAD.  As a special case, you may use ""A...B"" as a shortcut for the merge base of A and B if there is exactly one merge base. You can leave out at most one of A and B, in which case it defaults to HEAD."),
					new GitCommandOption("<tree-ish>", "<tree-ish>", @"Tree to checkout from (when paths are given). If not specified, the index will be used.  As a special case, you may use ""A...B"" as a shortcut for the merge base of A and B if there is exactly one merge base. You can leave out at most one of A and B, in which case it defaults to HEAD."),
					new GitCommandOption("--", "--", @"Do not interpret any more arguments as options."),
					new GitCommandOption("--conflict", "--conflict=<style>", @"The same as --merge option above, but changes the way the conflicting hunks are presented, overriding the merge.conflictStyle configuration variable.  Possible values are ""merge"" (default), ""diff3"", and ""zdiff3""."),
					new GitCommandOption("--detach", "--detach", @"Rather than checking out a branch to work on it, check out a commit for inspection and discardable experiments. This is the default behavior of git checkout <commit> when <commit> is not a branch name.  See the ""DETACHED HEAD"" section below for details."),
					new GitCommandOption("--force", "--force", @"When switching branches, proceed even if the index or the working tree differs from HEAD, and even if there are untracked files in the way.  This is used to throw away local changes and any untracked files or directories that are in the way.  When checking out paths from the index, do not fail upon unmerged entries; instead, unmerged entries are ignored."),
					new GitCommandOption("--guess", "--guess", @"If <branch> is not found but there does exist a tracking branch in exactly one remote (call it <remote>) with a matching name, treat as equivalent to   $ git checkout -b <branch> --track <remote>/<branch>    If the branch exists in multiple remotes and one of them is named by the checkout.defaultRemote configuration variable, we’ll use that one for the purposes of disambiguation, even if the <branch> isn’t unique across all remotes. Set it to e.g. checkout.defaultRemote=origin to always checkout remote branches from there if <branch> is ambiguous but exists on the origin remote. See also checkout.defaultRemote in git-config.   --guess is the default behavior. Use --no-guess to disable it.   The default behavior can be set via the checkout.guess configuration variable."),
					new GitCommandOption("--ignore-other-worktrees", "--ignore-other-worktrees", @"git checkout refuses when the wanted ref is already checked out by another worktree. This option makes it check the ref out anyway. In other words, the ref can be held by more than one worktree."),
					new GitCommandOption("--ignore-skip-worktree-bits", "--ignore-skip-worktree-bits", @"In sparse checkout mode, git checkout -- <paths> would update only entries matched by <paths> and sparse patterns in $GIT_DIR/info/sparse-checkout. This option ignores the sparse patterns and adds back any files in <paths>."),
					new GitCommandOption("--merge", "--merge", @"When switching branches, if you have local modifications to one or more files that are different between the current branch and the branch to which you are switching, the command refuses to switch branches in order to preserve your modifications in context. However, with this option, a three-way merge between the current branch, your working tree contents, and the new branch is done, and you will be on the new branch.  When a merge conflict happens, the index entries for conflicting paths are left unmerged, and you need to resolve the conflicts and mark the resolved paths with git add (or git rm if the merge should result in deletion of the path).   When checking out paths from the index, this option lets you recreate the conflicted merge in the specified paths.   When switching branches with --merge, staged changes may be lost."),
					new GitCommandOption("--no-guess", "--no-guess", @"If <branch> is not found but there does exist a tracking branch in exactly one remote (call it <remote>) with a matching name, treat as equivalent to   $ git checkout -b <branch> --track <remote>/<branch>    If the branch exists in multiple remotes and one of them is named by the checkout.defaultRemote configuration variable, we’ll use that one for the purposes of disambiguation, even if the <branch> isn’t unique across all remotes. Set it to e.g. checkout.defaultRemote=origin to always checkout remote branches from there if <branch> is ambiguous but exists on the origin remote. See also checkout.defaultRemote in git-config.   --guess is the default behavior. Use --no-guess to disable it.   The default behavior can be set via the checkout.guess configuration variable."),
					new GitCommandOption("--no-overlay", "--no-overlay", @"In the default overlay mode, git checkout never removes files from the index or the working tree.  When specifying --no-overlay, files that appear in the index and working tree, but not in <tree-ish> are removed, to make them match <tree-ish> exactly."),
					new GitCommandOption("--no-overwrite-ignore", "--no-overwrite-ignore", @"Silently overwrite ignored files when switching branches. This is the default behavior. Use --no-overwrite-ignore to abort the operation when the new branch contains ignored files."),
					new GitCommandOption("--no-progress", "--no-progress", @"Progress status is reported on the standard error stream by default when it is attached to a terminal, unless --quiet is specified. This flag enables progress reporting even if not attached to a terminal, regardless of --quiet."),
					new GitCommandOption("--no-recurse-submodules", "--no-recurse-submodules", @"Using --recurse-submodules will update the content of all active submodules according to the commit recorded in the superproject. If local modifications in a submodule would be overwritten the checkout will fail unless -f is used. If nothing (or --no-recurse-submodules) is used, submodules working trees will not be updated. Just like git-submodule, this will detach HEAD of the submodule."),
					new GitCommandOption("--no-track", "--no-track", @"Do not set up ""upstream"" configuration, even if the branch.autoSetupMerge configuration variable is true."),
					new GitCommandOption("--orphan", "--orphan <new-branch>", @"Create a new orphan branch, named <new-branch>, started from <start-point> and switch to it.  The first commit made on this new branch will have no parents and it will be the root of a new history totally disconnected from all the other branches and commits.  The index and the working tree are adjusted as if you had previously run git checkout <start-point>.  This allows you to start a new history that records a set of paths similar to <start-point> by easily running git commit -a to make the root commit.   This can be useful when you want to publish the tree from a commit without exposing its full history. You might want to do this to publish an open source branch of a project whose current tree is ""clean"", but whose full history contains proprietary or otherwise encumbered bits of code.   If you want to start a disconnected history that records a set of paths that is totally different from the one of <start-point>, then you should clear the index and the working tree right after creating the orphan branch by running git rm -rf . from the top level of the working tree. Afterwards you will be ready to prepare your new files, repopulating the working tree, by copying them from elsewhere, extracting a tarball, etc."),
					new GitCommandOption("--ours", "--ours", @"When checking out paths from the index, check out stage #2 (ours) or #3 (theirs) for unmerged paths.  Note that during git rebase and git pull --rebase, ours and theirs may appear swapped; --ours gives the version from the branch the changes are rebased onto, while --theirs gives the version from the branch that holds your work that is being rebased.   This is because rebase is used in a workflow that treats the history at the remote as the shared canonical one, and treats the work done on the branch you are rebasing as the third-party work to be integrated, and you are temporarily assuming the role of the keeper of the canonical history during the rebase.  As the keeper of the canonical history, you need to view the history from the remote as ours (i.e. ""our shared canonical history""), while what you did on your side branch as theirs (i.e. ""one contributor’s work on top of it"")."),
					new GitCommandOption("--overlay", "--overlay", @"In the default overlay mode, git checkout never removes files from the index or the working tree.  When specifying --no-overlay, files that appear in the index and working tree, but not in <tree-ish> are removed, to make them match <tree-ish> exactly."),
					new GitCommandOption("--overwrite-ignore", "--overwrite-ignore", @"Silently overwrite ignored files when switching branches. This is the default behavior. Use --no-overwrite-ignore to abort the operation when the new branch contains ignored files."),
					new GitCommandOption("--patch", "--patch", @"Interactively select hunks in the difference between the <tree-ish> (or the index, if unspecified) and the working tree.  The chosen hunks are then applied in reverse to the working tree (and if a <tree-ish> was specified, the index).  This means that you can use git checkout -p to selectively discard edits from your current working tree. See the “Interactive Mode” section of git-add to learn how to operate the --patch mode.   Note that this option uses the no overlay mode by default (see also --overlay), and currently doesn’t support overlay mode."),
					new GitCommandOption("--pathspec-file-nul", "--pathspec-file-nul", @"Only meaningful with --pathspec-from-file. Pathspec elements are separated with NUL character and all other characters are taken literally (including newlines and quotes)."),
					new GitCommandOption("--pathspec-from-file", "--pathspec-from-file=<file>", @"Pathspec is passed in <file> instead of commandline args. If <file> is exactly - then standard input is used. Pathspec elements are separated by LF or CR/LF. Pathspec elements can be quoted as explained for the configuration variable core.quotePath (see git-config). See also --pathspec-file-nul and global --literal-pathspecs."),
					new GitCommandOption("--progress", "--progress", @"Progress status is reported on the standard error stream by default when it is attached to a terminal, unless --quiet is specified. This flag enables progress reporting even if not attached to a terminal, regardless of --quiet."),
					new GitCommandOption("--quiet", "--quiet", @"Quiet, suppress feedback messages."),
					new GitCommandOption("--recurse-submodules", "--recurse-submodules", @"Using --recurse-submodules will update the content of all active submodules according to the commit recorded in the superproject. If local modifications in a submodule would be overwritten the checkout will fail unless -f is used. If nothing (or --no-recurse-submodules) is used, submodules working trees will not be updated. Just like git-submodule, this will detach HEAD of the submodule."),
					new GitCommandOption("--theirs", "--theirs", @"When checking out paths from the index, check out stage #2 (ours) or #3 (theirs) for unmerged paths.  Note that during git rebase and git pull --rebase, ours and theirs may appear swapped; --ours gives the version from the branch the changes are rebased onto, while --theirs gives the version from the branch that holds your work that is being rebased.   This is because rebase is used in a workflow that treats the history at the remote as the shared canonical one, and treats the work done on the branch you are rebasing as the third-party work to be integrated, and you are temporarily assuming the role of the keeper of the canonical history during the rebase.  As the keeper of the canonical history, you need to view the history from the remote as ours (i.e. ""our shared canonical history""), while what you did on your side branch as theirs (i.e. ""one contributor’s work on top of it"")."),
					new GitCommandOption("--track[", "--track[=(direct|inherit)]", @"When creating a new branch, set up ""upstream"" configuration. See ""--track"" in git-branch for details.  If no -b option is given, the name of the new branch will be derived from the remote-tracking branch, by looking at the local part of the refspec configured for the corresponding remote, and then stripping the initial part up to the ""*"". This would tell us to use hack as the local branch when branching off of origin/hack (or remotes/origin/hack, or even refs/remotes/origin/hack).  If the given name has no slash, or the above guessing results in an empty name, the guessing is aborted.  You can explicitly give a name with -b in such a case."),
					new GitCommandOption("-b", "-b <new-branch>", @"Create a new branch named <new-branch> and start it at <start-point>; see git-branch for details."),
					new GitCommandOption("-B", "-B <new-branch>", @"Creates the branch <new-branch> and start it at <start-point>; if it already exists, then reset it to <start-point>. This is equivalent to running ""git branch"" with ""-f""; see git-branch for details."),
					new GitCommandOption("-d", "-d", @"Rather than checking out a branch to work on it, check out a commit for inspection and discardable experiments. This is the default behavior of git checkout <commit> when <commit> is not a branch name.  See the ""DETACHED HEAD"" section below for details."),
					new GitCommandOption("-f", "-f", @"When switching branches, proceed even if the index or the working tree differs from HEAD, and even if there are untracked files in the way.  This is used to throw away local changes and any untracked files or directories that are in the way.  When checking out paths from the index, do not fail upon unmerged entries; instead, unmerged entries are ignored."),
					new GitCommandOption("-l", "-l", @"Create the new branch’s reflog; see git-branch for details."),
					new GitCommandOption("-m", "-m", @"When switching branches, if you have local modifications to one or more files that are different between the current branch and the branch to which you are switching, the command refuses to switch branches in order to preserve your modifications in context. However, with this option, a three-way merge between the current branch, your working tree contents, and the new branch is done, and you will be on the new branch.  When a merge conflict happens, the index entries for conflicting paths are left unmerged, and you need to resolve the conflicts and mark the resolved paths with git add (or git rm if the merge should result in deletion of the path).   When checking out paths from the index, this option lets you recreate the conflicted merge in the specified paths.   When switching branches with --merge, staged changes may be lost."),
					new GitCommandOption("-p", "-p", @"Interactively select hunks in the difference between the <tree-ish> (or the index, if unspecified) and the working tree.  The chosen hunks are then applied in reverse to the working tree (and if a <tree-ish> was specified, the index).  This means that you can use git checkout -p to selectively discard edits from your current working tree. See the “Interactive Mode” section of git-add to learn how to operate the --patch mode.   Note that this option uses the no overlay mode by default (see also --overlay), and currently doesn’t support overlay mode."),
					new GitCommandOption("-q", "-q", @"Quiet, suppress feedback messages."),
					new GitCommandOption("-t", "-t", @"When creating a new branch, set up ""upstream"" configuration. See ""--track"" in git-branch for details.  If no -b option is given, the name of the new branch will be derived from the remote-tracking branch, by looking at the local part of the refspec configured for the corresponding remote, and then stripping the initial part up to the ""*"". This would tell us to use hack as the local branch when branching off of origin/hack (or remotes/origin/hack, or even refs/remotes/origin/hack).  If the given name has no slash, or the above guessing results in an empty name, the guessing is aborted.  You can explicitly give a name with -b in such a case."),
				}, 
	"cherry-pick" => new GitCommandOption[] {
					new GitCommandOption("<commit>…​", "<commit>…​", @"Commits to cherry-pick. For a more complete list of ways to spell commits, see gitrevisions. Sets of commits can be passed but no traversal is done by default, as if the --no-walk option was specified, see git-rev-list. Note that specifying a range will feed all <commit>…​ arguments to a single revision walk (see a later example that uses maint master..next)."),
					new GitCommandOption("--allow-empty", "--allow-empty", @"By default, cherry-picking an empty commit will fail, indicating that an explicit invocation of git commit --allow-empty is required. This option overrides that behavior, allowing empty commits to be preserved automatically in a cherry-pick. Note that when ""--ff"" is in effect, empty commits that meet the ""fast-forward"" requirement will be kept even without this option.  Note also, that use of this option only keeps commits that were initially empty (i.e. the commit recorded the same tree as its parent).  Commits which are made empty due to a previous commit are dropped.  To force the inclusion of those commits use --keep-redundant-commits."),
					new GitCommandOption("--allow-empty-message", "--allow-empty-message", @"By default, cherry-picking a commit with an empty message will fail. This option overrides that behavior, allowing commits with empty messages to be cherry picked."),
					new GitCommandOption("--cleanup", "--cleanup=<mode>", @"This option determines how the commit message will be cleaned up before being passed on to the commit machinery. See git-commit for more details. In particular, if the <mode> is given a value of scissors, scissors will be appended to MERGE_MSG before being passed on in the case of a conflict."),
					new GitCommandOption("--edit", "--edit", @"With this option, git cherry-pick will let you edit the commit message prior to committing."),
					new GitCommandOption("--ff", "--ff", @"If the current HEAD is the same as the parent of the cherry-pick’ed commit, then a fast forward to this commit will be performed."),
					new GitCommandOption("--gpg-sign[", "--gpg-sign[=<keyid>]", @"GPG-sign commits. The keyid argument is optional and defaults to the committer identity; if specified, it must be stuck to the option without a space. --no-gpg-sign is useful to countermand both commit.gpgSign configuration variable, and earlier --gpg-sign."),
					new GitCommandOption("--keep-redundant-commits", "--keep-redundant-commits", @"If a commit being cherry picked duplicates a commit already in the current history, it will become empty.  By default these redundant commits cause cherry-pick to stop so the user can examine the commit. This option overrides that behavior and creates an empty commit object.  Implies --allow-empty."),
					new GitCommandOption("--mainline", "--mainline <parent-number>", @"Usually you cannot cherry-pick a merge because you do not know which side of the merge should be considered the mainline.  This option specifies the parent number (starting from 1) of the mainline and allows cherry-pick to replay the change relative to the specified parent."),
					new GitCommandOption("--no-commit", "--no-commit", @"Usually the command automatically creates a sequence of commits. This flag applies the changes necessary to cherry-pick each named commit to your working tree and the index, without making any commit.  In addition, when this option is used, your index does not have to match the HEAD commit.  The cherry-pick is done against the beginning state of your index.  This is useful when cherry-picking more than one commits' effect to your index in a row."),
					new GitCommandOption("--no-gpg-sign", "--no-gpg-sign", @"GPG-sign commits. The keyid argument is optional and defaults to the committer identity; if specified, it must be stuck to the option without a space. --no-gpg-sign is useful to countermand both commit.gpgSign configuration variable, and earlier --gpg-sign."),
					new GitCommandOption("--no-rerere-autoupdate", "--no-rerere-autoupdate", @"Allow the rerere mechanism to update the index with the result of auto-conflict resolution if possible."),
					new GitCommandOption("--rerere-autoupdate", "--rerere-autoupdate", @"Allow the rerere mechanism to update the index with the result of auto-conflict resolution if possible."),
					new GitCommandOption("--signoff", "--signoff", @"Add a Signed-off-by trailer at the end of the commit message. See the signoff option in git-commit for more information."),
					new GitCommandOption("--strategy", "--strategy=<strategy>", @"Use the given merge strategy.  Should only be used once. See the MERGE STRATEGIES section in git-merge for details."),
					new GitCommandOption("--strategy-option", "--strategy-option=<option>", @"Pass the merge strategy-specific option through to the merge strategy.  See git-merge for details."),
					new GitCommandOption("-e", "-e", @"With this option, git cherry-pick will let you edit the commit message prior to committing."),
					new GitCommandOption("-m", "-m <parent-number>", @"Usually you cannot cherry-pick a merge because you do not know which side of the merge should be considered the mainline.  This option specifies the parent number (starting from 1) of the mainline and allows cherry-pick to replay the change relative to the specified parent."),
					new GitCommandOption("-n", "-n", @"Usually the command automatically creates a sequence of commits. This flag applies the changes necessary to cherry-pick each named commit to your working tree and the index, without making any commit.  In addition, when this option is used, your index does not have to match the HEAD commit.  The cherry-pick is done against the beginning state of your index.  This is useful when cherry-picking more than one commits' effect to your index in a row."),
					new GitCommandOption("-r", "-r", @"It used to be that the command defaulted to do -x described above, and -r was to disable it.  Now the default is not to do -x so this option is a no-op."),
					new GitCommandOption("-s", "-s", @"Add a Signed-off-by trailer at the end of the commit message. See the signoff option in git-commit for more information."),
					new GitCommandOption("-S[<keyid>]", "-S[<keyid>]", @"GPG-sign commits. The keyid argument is optional and defaults to the committer identity; if specified, it must be stuck to the option without a space. --no-gpg-sign is useful to countermand both commit.gpgSign configuration variable, and earlier --gpg-sign."),
					new GitCommandOption("-x", "-x", @"When recording the commit, append a line that says ""(cherry picked from commit …​)"" to the original commit message in order to indicate which commit this change was cherry-picked from.  This is done only for cherry picks without conflicts.  Do not use this option if you are cherry-picking from your private branch because the information is useless to the recipient.  If on the other hand you are cherry-picking between two publicly visible branches (e.g. backporting a fix to a maintenance branch for an older release from a development branch), adding this information can be useful."),
					new GitCommandOption("-X<option>", "-X<option>", @"Pass the merge strategy-specific option through to the merge strategy.  See git-merge for details."),
				}, 
	"cherry" => new GitCommandOption[] {
					new GitCommandOption("<head>", "<head>", @"Working branch; defaults to HEAD."),
					new GitCommandOption("<limit>", "<limit>", @"Do not report commits up to (and including) limit."),
					new GitCommandOption("<upstream>", "<upstream>", @"Upstream branch to search for equivalent commits. Defaults to the upstream branch of HEAD."),
					new GitCommandOption("-v", "-v", @"Show the commit subjects next to the SHA1s."),
				}, 
	"citool" => new GitCommandOption[] {
				}, 
	"clean" => new GitCommandOption[] {
					new GitCommandOption("--dry-run", "--dry-run", @"Don’t actually remove anything, just show what would be done."),
					new GitCommandOption("--exclude", "--exclude=<pattern>", @"Use the given exclude pattern in addition to the standard ignore rules (see gitignore)."),
					new GitCommandOption("--force", "--force", @"If the Git configuration variable clean.requireForce is not set to false, git clean will refuse to delete files or directories unless given -f or -i.  Git will refuse to modify untracked nested git repositories (directories with a .git subdirectory) unless a second -f is given."),
					new GitCommandOption("--interactive", "--interactive", @"Show what would be done and clean files interactively. See “Interactive mode” for details."),
					new GitCommandOption("--quiet", "--quiet", @"Be quiet, only report errors, but not the files that are successfully removed."),
					new GitCommandOption("-d", "-d", @"Normally, when no <path> is specified, git clean will not recurse into untracked directories to avoid removing too much. Specify -d to have it recurse into such directories as well. If any paths are specified, -d is irrelevant; all untracked files matching the specified paths (with exceptions for nested git directories mentioned under --force) will be removed."),
					new GitCommandOption("-e", "-e <pattern>", @"Use the given exclude pattern in addition to the standard ignore rules (see gitignore)."),
					new GitCommandOption("-f", "-f", @"If the Git configuration variable clean.requireForce is not set to false, git clean will refuse to delete files or directories unless given -f or -i.  Git will refuse to modify untracked nested git repositories (directories with a .git subdirectory) unless a second -f is given."),
					new GitCommandOption("-i", "-i", @"Show what would be done and clean files interactively. See “Interactive mode” for details."),
					new GitCommandOption("-n", "-n", @"Don’t actually remove anything, just show what would be done."),
					new GitCommandOption("-q", "-q", @"Be quiet, only report errors, but not the files that are successfully removed."),
					new GitCommandOption("-x", "-x", @"Don’t use the standard ignore rules (see gitignore), but still use the ignore rules given with -e options from the command line.  This allows removing all untracked files, including build products.  This can be used (possibly in conjunction with git restore or git reset) to create a pristine working directory to test a clean build."),
					new GitCommandOption("-X", "-X", @"Remove only files ignored by Git.  This may be useful to rebuild everything from scratch, but keep manually created files."),
				}, 
	"clone" => new GitCommandOption[] {
					new GitCommandOption("<directory>", "<directory>", @"The name of a new directory to clone into.  The ""humanish"" part of the source repository is used if no directory is explicitly given (repo for /path/to/repo.git and foo for host.xz:foo/.git).  Cloning into an existing directory is only allowed if the directory is empty."),
					new GitCommandOption("<repository>", "<repository>", @"The (possibly remote) repository to clone from.  See the GIT URLS section below for more information on specifying repositories."),
					new GitCommandOption("--[no-]reject-shallow", "--[no-]reject-shallow", @"Fail if the source repository is a shallow repository. The clone.rejectShallow configuration variable can be used to specify the default."),
					new GitCommandOption("--[no-]remote-submodules", "--[no-]remote-submodules", @"All submodules which are cloned will use the status of the submodule’s remote-tracking branch to update the submodule, rather than the superproject’s recorded SHA-1. Equivalent to passing --remote to git submodule update."),
					new GitCommandOption("--[no-]shallow-submodules", "--[no-]shallow-submodules", @"All submodules which are cloned will be shallow with a depth of 1."),
					new GitCommandOption("--[no-]single-branch", "--[no-]single-branch", @"Clone only the history leading to the tip of a single branch, either specified by the --branch option or the primary branch remote’s HEAD points at. Further fetches into the resulting repository will only update the remote-tracking branch for the branch this option was used for the initial cloning.  If the HEAD at the remote did not point at any branch when --single-branch clone was made, no remote-tracking branch is created."),
					new GitCommandOption("--also-filter-submodules", "--also-filter-submodules", @"Also apply the partial clone filter to any submodules in the repository. Requires --filter and --recurse-submodules. This can be turned on by default by setting the clone.filterSubmodules config option."),
					new GitCommandOption("--bare", "--bare", @"Make a bare Git repository.  That is, instead of creating <directory> and placing the administrative files in <directory>/.git, make the <directory> itself the $GIT_DIR. This obviously implies the --no-checkout because there is nowhere to check out the working tree. Also the branch heads at the remote are copied directly to corresponding local branch heads, without mapping them to refs/remotes/origin/.  When this option is used, neither remote-tracking branches nor the related configuration variables are created."),
					new GitCommandOption("--branch", "--branch <name>", @"Instead of pointing the newly created HEAD to the branch pointed to by the cloned repository’s HEAD, point to <name> branch instead. In a non-bare repository, this is the branch that will be checked out. --branch can also take tags and detaches the HEAD at that commit in the resulting repository."),
					new GitCommandOption("--config", "--config <key>=<value>", @"Set a configuration variable in the newly-created repository; this takes effect immediately after the repository is initialized, but before the remote history is fetched or any files checked out.  The key is in the same format as expected by git-config (e.g., core.eol=true). If multiple values are given for the same key, each value will be written to the config file. This makes it safe, for example, to add additional fetch refspecs to the origin remote.  Due to limitations of the current implementation, some configuration variables do not take effect until after the initial fetch and checkout. Configuration variables known to not take effect are: remote.<name>.mirror and remote.<name>.tagOpt.  Use the corresponding --mirror and --no-tags options instead."),
					new GitCommandOption("--depth", "--depth <depth>", @"Create a shallow clone with a history truncated to the specified number of commits. Implies --single-branch unless --no-single-branch is given to fetch the histories near the tips of all branches. If you want to clone submodules shallowly, also pass --shallow-submodules."),
					new GitCommandOption("--dissociate", "--dissociate", @"Borrow the objects from reference repositories specified with the --reference options only to reduce network transfer, and stop borrowing from them after a clone is made by making necessary local copies of borrowed objects.  This option can also be used when cloning locally from a repository that already borrows objects from another repository—​the new repository will borrow objects from the same repository, and this option can be used to stop the borrowing."),
					new GitCommandOption("--filter", "--filter=<filter-spec>", @"Use the partial clone feature and request that the server sends a subset of reachable objects according to a given object filter. When using --filter, the supplied <filter-spec> is used for the partial clone filter. For example, --filter=blob:none will filter out all blobs (file contents) until needed by Git. Also, --filter=blob:limit=<size> will filter out all blobs of size at least <size>. For more details on filter specifications, see the --filter option in git-rev-list."),
					new GitCommandOption("--jobs", "--jobs <n>", @"The number of submodules fetched at the same time. Defaults to the submodule.fetchJobs option."),
					new GitCommandOption("--local", "--local", @"When the repository to clone from is on a local machine, this flag bypasses the normal ""Git aware"" transport mechanism and clones the repository by making a copy of HEAD and everything under objects and refs directories. The files under .git/objects/ directory are hardlinked to save space when possible.  If the repository is specified as a local path (e.g., /path/to/repo), this is the default, and --local is essentially a no-op.  If the repository is specified as a URL, then this flag is ignored (and we never use the local optimizations).  Specifying --no-local will override the default when /path/to/repo is given, using the regular Git transport instead.   NOTE: this operation can race with concurrent modification to the source repository, similar to running cp -r src dst while modifying src."),
					new GitCommandOption("--mirror", "--mirror", @"Set up a mirror of the source repository.  This implies --bare. Compared to --bare, --mirror not only maps local branches of the source to local branches of the target, it maps all refs (including remote-tracking branches, notes etc.) and sets up a refspec configuration such that all these refs are overwritten by a git remote update in the target repository."),
					new GitCommandOption("--no-checkout", "--no-checkout", @"No checkout of HEAD is performed after the clone is complete."),
					new GitCommandOption("--no-hardlinks", "--no-hardlinks", @"Force the cloning process from a repository on a local filesystem to copy the files under the .git/objects directory instead of using hardlinks. This may be desirable if you are trying to make a back-up of your repository."),
					new GitCommandOption("--no-tags", "--no-tags", @"Don’t clone any tags, and set remote.<remote>.tagOpt=--no-tags in the config, ensuring that future git pull and git fetch operations won’t follow any tags. Subsequent explicit tag fetches will still work, (see git-fetch).  Can be used in conjunction with --single-branch to clone and maintain a branch with no references other than a single cloned branch. This is useful e.g. to maintain minimal clones of the default branch of some repository for search indexing."),
					new GitCommandOption("--origin", "--origin <name>", @"Instead of using the remote name origin to keep track of the upstream repository, use <name>.  Overrides clone.defaultRemoteName from the config."),
					new GitCommandOption("--progress", "--progress", @"Progress status is reported on the standard error stream by default when it is attached to a terminal, unless --quiet is specified. This flag forces progress status even if the standard error stream is not directed to a terminal."),
					new GitCommandOption("--quiet", "--quiet", @"Operate quietly.  Progress is not reported to the standard error stream."),
					new GitCommandOption("--recurse-submodules[", "--recurse-submodules[=<pathspec>]", @"After the clone is created, initialize and clone submodules within based on the provided pathspec.  If no pathspec is provided, all submodules are initialized and cloned. This option can be given multiple times for pathspecs consisting of multiple entries.  The resulting clone has submodule.active set to the provided pathspec, or ""."" (meaning all submodules) if no pathspec is provided.  Submodules are initialized and cloned using their default settings. This is equivalent to running git submodule update --init --recursive <pathspec> immediately after the clone is finished. This option is ignored if the cloned repository does not have a worktree/checkout (i.e. if any of --no-checkout/-n, --bare, or --mirror is given)"),
					new GitCommandOption("--reference[-if-able]", "--reference[-if-able] <repository>", @"If the reference repository is on the local machine, automatically setup .git/objects/info/alternates to obtain objects from the reference repository.  Using an already existing repository as an alternate will require fewer objects to be copied from the repository being cloned, reducing network and local storage costs. When using the --reference-if-able, a non existing directory is skipped with a warning instead of aborting the clone.  NOTE: see the NOTE for the --shared option, and also the --dissociate option."),
					new GitCommandOption("--separate-git-dir", "--separate-git-dir=<git-dir>", @"Instead of placing the cloned repository where it is supposed to be, place the cloned repository at the specified directory, then make a filesystem-agnostic Git symbolic link to there. The result is Git repository can be separated from working tree."),
					new GitCommandOption("--server-option", "--server-option=<option>", @"Transmit the given string to the server when communicating using protocol version 2.  The given string must not contain a NUL or LF character.  The server’s handling of server options, including unknown ones, is server-specific. When multiple --server-option=<option> are given, they are all sent to the other side in the order listed on the command line."),
					new GitCommandOption("--shallow-exclude", "--shallow-exclude=<revision>", @"Create a shallow clone with a history, excluding commits reachable from a specified remote branch or tag.  This option can be specified multiple times."),
					new GitCommandOption("--shallow-since", "--shallow-since=<date>", @"Create a shallow clone with a history after the specified time."),
					new GitCommandOption("--shared", "--shared", @"When the repository to clone is on the local machine, instead of using hard links, automatically setup .git/objects/info/alternates to share the objects with the source repository.  The resulting repository starts out without any object of its own.  NOTE: this is a possibly dangerous operation; do not use it unless you understand what it does. If you clone your repository using this option and then delete branches (or use any other Git command that makes any existing commit unreferenced) in the source repository, some objects may become unreferenced (or dangling). These objects may be removed by normal Git operations (such as git commit) which automatically call git maintenance run --auto. (See git-maintenance.) If these objects are removed and were referenced by the cloned repository, then the cloned repository will become corrupt.   Note that running git repack without the --local option in a repository cloned with --shared will copy objects from the source repository into a pack in the cloned repository, removing the disk space savings of clone --shared. It is safe, however, to run git gc, which uses the --local option by default.   If you want to break the dependency of a repository cloned with --shared on its source repository, you can simply run git repack -a to copy all objects from the source repository into a pack in the cloned repository."),
					new GitCommandOption("--sparse", "--sparse", @"Employ a sparse-checkout, with only files in the toplevel directory initially being present.  The git-sparse-checkout command can be used to grow the working directory as needed."),
					new GitCommandOption("--template", "--template=<template-directory>", @"Specify the directory from which templates will be used; (See the ""TEMPLATE DIRECTORY"" section of git-init.)"),
					new GitCommandOption("--upload-pack", "--upload-pack <upload-pack>", @"When given, and the repository to clone from is accessed via ssh, this specifies a non-default path for the command run on the other end."),
					new GitCommandOption("--verbose", "--verbose", @"Run verbosely. Does not affect the reporting of progress status to the standard error stream."),
					new GitCommandOption("-b", "-b <name>", @"Instead of pointing the newly created HEAD to the branch pointed to by the cloned repository’s HEAD, point to <name> branch instead. In a non-bare repository, this is the branch that will be checked out. --branch can also take tags and detaches the HEAD at that commit in the resulting repository."),
					new GitCommandOption("-c", "-c <key>=<value>", @"Set a configuration variable in the newly-created repository; this takes effect immediately after the repository is initialized, but before the remote history is fetched or any files checked out.  The key is in the same format as expected by git-config (e.g., core.eol=true). If multiple values are given for the same key, each value will be written to the config file. This makes it safe, for example, to add additional fetch refspecs to the origin remote.  Due to limitations of the current implementation, some configuration variables do not take effect until after the initial fetch and checkout. Configuration variables known to not take effect are: remote.<name>.mirror and remote.<name>.tagOpt.  Use the corresponding --mirror and --no-tags options instead."),
					new GitCommandOption("-j", "-j <n>", @"The number of submodules fetched at the same time. Defaults to the submodule.fetchJobs option."),
					new GitCommandOption("-l", "-l", @"When the repository to clone from is on a local machine, this flag bypasses the normal ""Git aware"" transport mechanism and clones the repository by making a copy of HEAD and everything under objects and refs directories. The files under .git/objects/ directory are hardlinked to save space when possible.  If the repository is specified as a local path (e.g., /path/to/repo), this is the default, and --local is essentially a no-op.  If the repository is specified as a URL, then this flag is ignored (and we never use the local optimizations).  Specifying --no-local will override the default when /path/to/repo is given, using the regular Git transport instead.   NOTE: this operation can race with concurrent modification to the source repository, similar to running cp -r src dst while modifying src."),
					new GitCommandOption("-n", "-n", @"No checkout of HEAD is performed after the clone is complete."),
					new GitCommandOption("-o", "-o <name>", @"Instead of using the remote name origin to keep track of the upstream repository, use <name>.  Overrides clone.defaultRemoteName from the config."),
					new GitCommandOption("-q", "-q", @"Operate quietly.  Progress is not reported to the standard error stream."),
					new GitCommandOption("-s", "-s", @"When the repository to clone is on the local machine, instead of using hard links, automatically setup .git/objects/info/alternates to share the objects with the source repository.  The resulting repository starts out without any object of its own.  NOTE: this is a possibly dangerous operation; do not use it unless you understand what it does. If you clone your repository using this option and then delete branches (or use any other Git command that makes any existing commit unreferenced) in the source repository, some objects may become unreferenced (or dangling). These objects may be removed by normal Git operations (such as git commit) which automatically call git maintenance run --auto. (See git-maintenance.) If these objects are removed and were referenced by the cloned repository, then the cloned repository will become corrupt.   Note that running git repack without the --local option in a repository cloned with --shared will copy objects from the source repository into a pack in the cloned repository, removing the disk space savings of clone --shared. It is safe, however, to run git gc, which uses the --local option by default.   If you want to break the dependency of a repository cloned with --shared on its source repository, you can simply run git repack -a to copy all objects from the source repository into a pack in the cloned repository."),
					new GitCommandOption("-u", "-u <upload-pack>", @"When given, and the repository to clone from is accessed via ssh, this specifies a non-default path for the command run on the other end."),
					new GitCommandOption("-v", "-v", @"Run verbosely. Does not affect the reporting of progress status to the standard error stream."),
				}, 
	"column" => new GitCommandOption[] {
					new GitCommandOption("--command", "--command=<name>", @"Look up layout mode using configuration variable column.<name> and column.ui."),
					new GitCommandOption("--indent", "--indent=<string>", @"String to be printed at the beginning of each line."),
					new GitCommandOption("--mode", "--mode=<mode>", @"Specify layout mode. See configuration variable column.ui for option syntax in git-config."),
					new GitCommandOption("--nl", "--nl=<string>", @"String to be printed at the end of each line, including newline character."),
					new GitCommandOption("--padding", "--padding=<N>", @"The number of spaces between columns. One space by default."),
					new GitCommandOption("--raw-mode", "--raw-mode=<n>", @"Same as --mode but take mode encoded as a number. This is mainly used by other commands that have already parsed layout mode."),
					new GitCommandOption("--width", "--width=<width>", @"Specify the terminal width. By default git column will detect the terminal width, or fall back to 80 if it is unable to do so."),
				}, 
	"commit-graph" => new GitCommandOption[] {
					new GitCommandOption("--[no-]progress", "--[no-]progress", @"Turn progress on/off explicitly. If neither is specified, progress is shown if standard error is connected to a terminal."),
					new GitCommandOption("--object-dir", "--object-dir", @"Use given directory for the location of packfiles and commit-graph file. This parameter exists to specify the location of an alternate that only has the objects directory, not a full .git directory. The commit-graph file is expected to be in the <dir>/info directory and the packfiles are expected to be in <dir>/pack. If the directory could not be made into an absolute path, or does not match any known object directory, git commit-graph ... will exit with non-zero status."),
				}, 
	"commit-tree" => new GitCommandOption[] {
					new GitCommandOption("<tree>", "<tree>", @"An existing tree object."),
					new GitCommandOption("--gpg-sign[", "--gpg-sign[=<keyid>]", @"GPG-sign commits. The keyid argument is optional and defaults to the committer identity; if specified, it must be stuck to the option without a space. --no-gpg-sign is useful to countermand a --gpg-sign option given earlier on the command line."),
					new GitCommandOption("--no-gpg-sign", "--no-gpg-sign", @"GPG-sign commits. The keyid argument is optional and defaults to the committer identity; if specified, it must be stuck to the option without a space. --no-gpg-sign is useful to countermand a --gpg-sign option given earlier on the command line."),
					new GitCommandOption("-F", "-F <file>", @"Read the commit log message from the given file. Use - to read from the standard input. This can be given more than once and the content of each file becomes its own paragraph."),
					new GitCommandOption("-m", "-m <message>", @"A paragraph in the commit log message. This can be given more than once and each <message> becomes its own paragraph."),
					new GitCommandOption("-p", "-p <parent>", @"Each -p indicates the id of a parent commit object."),
					new GitCommandOption("-S[<keyid>]", "-S[<keyid>]", @"GPG-sign commits. The keyid argument is optional and defaults to the committer identity; if specified, it must be stuck to the option without a space. --no-gpg-sign is useful to countermand a --gpg-sign option given earlier on the command line."),
				}, 
	"commit" => new GitCommandOption[] {
					new GitCommandOption("<pathspec>…​", "<pathspec>…​", @"When pathspec is given on the command line, commit the contents of the files that match the pathspec without recording the changes already added to the index. The contents of these files are also staged for the next commit on top of what have been staged before.  For more details, see the pathspec entry in gitglossary."),
					new GitCommandOption("--", "--", @"Do not interpret any more arguments as options."),
					new GitCommandOption("--[no-]verify", "--[no-]verify", @"By default, the pre-commit and commit-msg hooks are run. When any of --no-verify or -n is given, these are bypassed. See also githooks."),
					new GitCommandOption("--all", "--all", @"Tell the command to automatically stage files that have been modified and deleted, but new files you have not told Git about are not affected."),
					new GitCommandOption("--allow-empty", "--allow-empty", @"Usually recording a commit that has the exact same tree as its sole parent commit is a mistake, and the command prevents you from making such a commit.  This option bypasses the safety, and is primarily for use by foreign SCM interface scripts."),
					new GitCommandOption("--allow-empty-message", "--allow-empty-message", @"Like --allow-empty this command is primarily for use by foreign SCM interface scripts. It allows you to create a commit with an empty commit message without using plumbing commands like git-commit-tree."),
					new GitCommandOption("--amend", "--amend", @"Replace the tip of the current branch by creating a new commit. The recorded tree is prepared as usual (including the effect of the -i and -o options and explicit pathspec), and the message from the original commit is used as the starting point, instead of an empty message, when no other message is specified from the command line via options such as -m, -F, -c, etc.  The new commit has the same parents and author as the current one (the --reset-author option can countermand this).    It is a rough equivalent for:            $ git reset --soft HEAD^         $ ... do something else to come up with the right tree ...         $ git commit -c ORIG_HEAD    but can be used to amend a merge commit.     You should understand the implications of rewriting history if you amend a commit that has already been published.  (See the ""RECOVERING FROM UPSTREAM REBASE"" section in git-rebase.)"),
					new GitCommandOption("--author", "--author=<author>", @"Override the commit author. Specify an explicit author using the standard A U Thor <author@example.com> format. Otherwise <author> is assumed to be a pattern and is used to search for an existing commit by that author (i.e. rev-list --all -i --author=<author>); the commit author is then copied from the first such commit found."),
					new GitCommandOption("--branch", "--branch", @"Show the branch and tracking info even in short-format."),
					new GitCommandOption("--cleanup", "--cleanup=<mode>", @"This option determines how the supplied commit message should be cleaned up before committing.  The <mode> can be strip, whitespace, verbatim, scissors or default.     strip  Strip leading and trailing empty lines, trailing whitespace, commentary and collapse consecutive empty lines.  whitespace  Same as strip except #commentary is not removed.  verbatim  Do not change the message at all.  scissors  Same as whitespace except that everything from (and including) the line found below is truncated, if the message is to be edited. ""#"" can be customized with core.commentChar.   # ------------------------ >8 ------------------------    default  Same as strip if the message is to be edited. Otherwise whitespace.       The default can be changed by the commit.cleanup configuration variable (see git-config)."),
					new GitCommandOption("--date", "--date=<date>", @"Override the author date used in the commit."),
					new GitCommandOption("--dry-run", "--dry-run", @"Do not create a commit, but show a list of paths that are to be committed, paths with local changes that will be left uncommitted and paths that are untracked."),
					new GitCommandOption("--edit", "--edit", @"The message taken from file with -F, command line with -m, and from commit object with -C are usually used as the commit log message unmodified. This option lets you further edit the message taken from these sources."),
					new GitCommandOption("--file", "--file=<file>", @"Take the commit message from the given file.  Use - to read the message from the standard input."),
					new GitCommandOption("--fixup", "--fixup=[(amend|reword):]<commit>", @"Create a new commit which ""fixes up"" <commit> when applied with git rebase --autosquash. Plain --fixup=<commit> creates a ""fixup!"" commit which changes the content of <commit> but leaves its log message untouched. --fixup=amend:<commit> is similar but creates an ""amend!"" commit which also replaces the log message of <commit> with the log message of the ""amend!"" commit. --fixup=reword:<commit> creates an ""amend!"" commit which replaces the log message of <commit> with its own log message but makes no changes to the content of <commit>.  The commit created by plain --fixup=<commit> has a subject composed of ""fixup!"" followed by the subject line from <commit>, and is recognized specially by git rebase --autosquash. The -m option may be used to supplement the log message of the created commit, but the additional commentary will be thrown away once the ""fixup!"" commit is squashed into <commit> by git rebase --autosquash.   The commit created by --fixup=amend:<commit> is similar but its subject is instead prefixed with ""amend!"". The log message of <commit> is copied into the log message of the ""amend!"" commit and opened in an editor so it can be refined. When git rebase --autosquash squashes the ""amend!"" commit into <commit>, the log message of <commit> is replaced by the refined log message from the ""amend!"" commit. It is an error for the ""amend!"" commit’s log message to be empty unless --allow-empty-message is specified.   --fixup=reword:<commit> is shorthand for --fixup=amend:<commit> --only. It creates an ""amend!"" commit with only a log message (ignoring any changes staged in the index). When squashed by git rebase --autosquash, it replaces the log message of <commit> without making any other changes.   Neither ""fixup!"" nor ""amend!"" commits change authorship of <commit> when applied by git rebase --autosquash. See git-rebase for details."),
					new GitCommandOption("--gpg-sign[", "--gpg-sign[=<keyid>]", @"GPG-sign commits. The keyid argument is optional and defaults to the committer identity; if specified, it must be stuck to the option without a space. --no-gpg-sign is useful to countermand both commit.gpgSign configuration variable, and earlier --gpg-sign."),
					new GitCommandOption("--include", "--include", @"Before making a commit out of staged contents so far, stage the contents of paths given on the command line as well.  This is usually not what you want unless you are concluding a conflicted merge."),
					new GitCommandOption("--long", "--long", @"When doing a dry-run, give the output in the long-format. Implies --dry-run."),
					new GitCommandOption("--message", "--message=<msg>", @"Use the given <msg> as the commit message. If multiple -m options are given, their values are concatenated as separate paragraphs.  The -m option is mutually exclusive with -c, -C, and -F."),
					new GitCommandOption("--no-edit", "--no-edit", @"Use the selected commit message without launching an editor. For example, git commit --amend --no-edit amends a commit without changing its commit message."),
					new GitCommandOption("--no-gpg-sign", "--no-gpg-sign", @"GPG-sign commits. The keyid argument is optional and defaults to the committer identity; if specified, it must be stuck to the option without a space. --no-gpg-sign is useful to countermand both commit.gpgSign configuration variable, and earlier --gpg-sign."),
					new GitCommandOption("--no-post-rewrite", "--no-post-rewrite", @"Bypass the post-rewrite hook."),
					new GitCommandOption("--no-signoff", "--no-signoff", @"Add a Signed-off-by trailer by the committer at the end of the commit log message.  The meaning of a signoff depends on the project to which you’re committing.  For example, it may certify that the committer has the rights to submit the work under the project’s license or agrees to some contributor representation, such as a Developer Certificate of Origin. (See http://developercertificate.org for the one used by the Linux kernel and Git projects.)  Consult the documentation or leadership of the project to which you’re contributing to understand how the signoffs are used in that project.  The --no-signoff option can be used to countermand an earlier --signoff option on the command line."),
					new GitCommandOption("--no-status", "--no-status", @"Do not include the output of git-status in the commit message template when using an editor to prepare the default commit message."),
					new GitCommandOption("--null", "--null", @"When showing short or porcelain status output, print the filename verbatim and terminate the entries with NUL, instead of LF. If no format is given, implies the --porcelain output format. Without the -z option, filenames with ""unusual"" characters are quoted as explained for the configuration variable core.quotePath (see git-config)."),
					new GitCommandOption("--only", "--only", @"Make a commit by taking the updated working tree contents of the paths specified on the command line, disregarding any contents that have been staged for other paths. This is the default mode of operation of git commit if any paths are given on the command line, in which case this option can be omitted. If this option is specified together with --amend, then no paths need to be specified, which can be used to amend the last commit without committing changes that have already been staged. If used together with --allow-empty paths are also not required, and an empty commit will be created."),
					new GitCommandOption("--patch", "--patch", @"Use the interactive patch selection interface to choose which changes to commit. See git-add for details."),
					new GitCommandOption("--pathspec-file-nul", "--pathspec-file-nul", @"Only meaningful with --pathspec-from-file. Pathspec elements are separated with NUL character and all other characters are taken literally (including newlines and quotes)."),
					new GitCommandOption("--pathspec-from-file", "--pathspec-from-file=<file>", @"Pathspec is passed in <file> instead of commandline args. If <file> is exactly - then standard input is used. Pathspec elements are separated by LF or CR/LF. Pathspec elements can be quoted as explained for the configuration variable core.quotePath (see git-config). See also --pathspec-file-nul and global --literal-pathspecs."),
					new GitCommandOption("--porcelain", "--porcelain", @"When doing a dry-run, give the output in a porcelain-ready format. See git-status for details. Implies --dry-run."),
					new GitCommandOption("--quiet", "--quiet", @"Suppress commit summary message."),
					new GitCommandOption("--reedit-message", "--reedit-message=<commit>", @"Like -C, but with -c the editor is invoked, so that the user can further edit the commit message."),
					new GitCommandOption("--reset-author", "--reset-author", @"When used with -C/-c/--amend options, or when committing after a conflicting cherry-pick, declare that the authorship of the resulting commit now belongs to the committer. This also renews the author timestamp."),
					new GitCommandOption("--reuse-message", "--reuse-message=<commit>", @"Take an existing commit object, and reuse the log message and the authorship information (including the timestamp) when creating the commit."),
					new GitCommandOption("--short", "--short", @"When doing a dry-run, give the output in the short-format. See git-status for details. Implies --dry-run."),
					new GitCommandOption("--signoff", "--signoff", @"Add a Signed-off-by trailer by the committer at the end of the commit log message.  The meaning of a signoff depends on the project to which you’re committing.  For example, it may certify that the committer has the rights to submit the work under the project’s license or agrees to some contributor representation, such as a Developer Certificate of Origin. (See http://developercertificate.org for the one used by the Linux kernel and Git projects.)  Consult the documentation or leadership of the project to which you’re contributing to understand how the signoffs are used in that project.  The --no-signoff option can be used to countermand an earlier --signoff option on the command line."),
					new GitCommandOption("--squash", "--squash=<commit>", @"Construct a commit message for use with rebase --autosquash. The commit message subject line is taken from the specified commit with a prefix of ""squash! "".  Can be used with additional commit message options (-m/-c/-C/-F). See git-rebase for details."),
					new GitCommandOption("--status", "--status", @"Include the output of git-status in the commit message template when using an editor to prepare the commit message.  Defaults to on, but can be used to override configuration variable commit.status."),
					new GitCommandOption("--template", "--template=<file>", @"When editing the commit message, start the editor with the contents in the given file.  The commit.template configuration variable is often used to give this option implicitly to the command.  This mechanism can be used by projects that want to guide participants with some hints on what to write in the message in what order.  If the user exits the editor without editing the message, the commit is aborted.  This has no effect when a message is given by other means, e.g. with the -m or -F options."),
					new GitCommandOption("--trailer", "--trailer <token>[(=|:)<value>]", @"Specify a (<token>, <value>) pair that should be applied as a trailer. (e.g. git commit --trailer ""Signed-off-by:C O Mitter \ <committer@example.com>"" --trailer ""Helped-by:C O Mitter \ <committer@example.com>"" will add the ""Signed-off-by"" trailer and the ""Helped-by"" trailer to the commit message.) The trailer.* configuration variables (git-interpret-trailers) can be used to define if a duplicated trailer is omitted, where in the run of trailers each trailer would appear, and other details."),
					new GitCommandOption("--untracked-files[", "--untracked-files[=<mode>]", @"Show untracked files.    The mode parameter is optional (defaults to all), and is used to specify the handling of untracked files; when -u is not used, the default is normal, i.e. show untracked files and directories.   The possible options are:     no     - Show no untracked files   normal - Shows untracked files and directories   all    - Also shows individual files in untracked directories.     The default can be changed using the status.showUntrackedFiles configuration variable documented in git-config."),
					new GitCommandOption("--verbose", "--verbose", @"Show unified diff between the HEAD commit and what would be committed at the bottom of the commit message template to help the user describe the commit by reminding what changes the commit has. Note that this diff output doesn’t have its lines prefixed with #. This diff will not be a part of the commit message. See the commit.verbose configuration variable in git-config.  If specified twice, show in addition the unified diff between what would be committed and the worktree files, i.e. the unstaged changes to tracked files."),
					new GitCommandOption("-a", "-a", @"Tell the command to automatically stage files that have been modified and deleted, but new files you have not told Git about are not affected."),
					new GitCommandOption("-C", "-C <commit>", @"Take an existing commit object, and reuse the log message and the authorship information (including the timestamp) when creating the commit."),
					new GitCommandOption("-c", "-c <commit>", @"Like -C, but with -c the editor is invoked, so that the user can further edit the commit message."),
					new GitCommandOption("-e", "-e", @"The message taken from file with -F, command line with -m, and from commit object with -C are usually used as the commit log message unmodified. This option lets you further edit the message taken from these sources."),
					new GitCommandOption("-F", "-F <file>", @"Take the commit message from the given file.  Use - to read the message from the standard input."),
					new GitCommandOption("-i", "-i", @"Before making a commit out of staged contents so far, stage the contents of paths given on the command line as well.  This is usually not what you want unless you are concluding a conflicted merge."),
					new GitCommandOption("-m", "-m <msg>", @"Use the given <msg> as the commit message. If multiple -m options are given, their values are concatenated as separate paragraphs.  The -m option is mutually exclusive with -c, -C, and -F."),
					new GitCommandOption("-n", "-n", @"By default, the pre-commit and commit-msg hooks are run. When any of --no-verify or -n is given, these are bypassed. See also githooks."),
					new GitCommandOption("-o", "-o", @"Make a commit by taking the updated working tree contents of the paths specified on the command line, disregarding any contents that have been staged for other paths. This is the default mode of operation of git commit if any paths are given on the command line, in which case this option can be omitted. If this option is specified together with --amend, then no paths need to be specified, which can be used to amend the last commit without committing changes that have already been staged. If used together with --allow-empty paths are also not required, and an empty commit will be created."),
					new GitCommandOption("-p", "-p", @"Use the interactive patch selection interface to choose which changes to commit. See git-add for details."),
					new GitCommandOption("-q", "-q", @"Suppress commit summary message."),
					new GitCommandOption("-s", "-s", @"Add a Signed-off-by trailer by the committer at the end of the commit log message.  The meaning of a signoff depends on the project to which you’re committing.  For example, it may certify that the committer has the rights to submit the work under the project’s license or agrees to some contributor representation, such as a Developer Certificate of Origin. (See http://developercertificate.org for the one used by the Linux kernel and Git projects.)  Consult the documentation or leadership of the project to which you’re contributing to understand how the signoffs are used in that project.  The --no-signoff option can be used to countermand an earlier --signoff option on the command line."),
					new GitCommandOption("-S[<keyid>]", "-S[<keyid>]", @"GPG-sign commits. The keyid argument is optional and defaults to the committer identity; if specified, it must be stuck to the option without a space. --no-gpg-sign is useful to countermand both commit.gpgSign configuration variable, and earlier --gpg-sign."),
					new GitCommandOption("-t", "-t <file>", @"When editing the commit message, start the editor with the contents in the given file.  The commit.template configuration variable is often used to give this option implicitly to the command.  This mechanism can be used by projects that want to guide participants with some hints on what to write in the message in what order.  If the user exits the editor without editing the message, the commit is aborted.  This has no effect when a message is given by other means, e.g. with the -m or -F options."),
					new GitCommandOption("-u[<mode>]", "-u[<mode>]", @"Show untracked files.    The mode parameter is optional (defaults to all), and is used to specify the handling of untracked files; when -u is not used, the default is normal, i.e. show untracked files and directories.   The possible options are:     no     - Show no untracked files   normal - Shows untracked files and directories   all    - Also shows individual files in untracked directories.     The default can be changed using the status.showUntrackedFiles configuration variable documented in git-config."),
					new GitCommandOption("-v", "-v", @"Show unified diff between the HEAD commit and what would be committed at the bottom of the commit message template to help the user describe the commit by reminding what changes the commit has. Note that this diff output doesn’t have its lines prefixed with #. This diff will not be a part of the commit message. See the commit.verbose configuration variable in git-config.  If specified twice, show in addition the unified diff between what would be committed and the worktree files, i.e. the unstaged changes to tracked files."),
					new GitCommandOption("-z", "-z", @"When showing short or porcelain status output, print the filename verbatim and terminate the entries with NUL, instead of LF. If no format is given, implies the --porcelain output format. Without the -z option, filenames with ""unusual"" characters are quoted as explained for the configuration variable core.quotePath (see git-config)."),
					new GitCommandOption("default", "default", @"Same as strip if the message is to be edited. Otherwise whitespace."),
					new GitCommandOption("scissors", "scissors", @"Same as whitespace except that everything from (and including) the line found below is truncated, if the message is to be edited. ""#"" can be customized with core.commentChar.   # ------------------------ >8 ------------------------"),
					new GitCommandOption("strip", "strip", @"Strip leading and trailing empty lines, trailing whitespace, commentary and collapse consecutive empty lines."),
					new GitCommandOption("verbatim", "verbatim", @"Do not change the message at all."),
					new GitCommandOption("whitespace", "whitespace", @"Same as strip except #commentary is not removed."),
				}, 
	"config" => new GitCommandOption[] {
					new GitCommandOption("--[no-]includes", "--[no-]includes", @"Respect include.* directives in config files when looking up values. Defaults to off when a specific file is given (e.g., using --file, --global, etc) and on when searching all config files."),
					new GitCommandOption("--add", "--add", @"Adds a new line to the option without altering any existing values.  This is the same as providing ^$ as the value-pattern in --replace-all."),
					new GitCommandOption("--blob", "--blob <blob>", @"Similar to --file but use the given blob instead of a file. E.g. you can use master:.gitmodules to read values from the file .gitmodules in the master branch. See ""SPECIFYING REVISIONS"" section in gitrevisions for a more complete list of ways to spell blob names."),
					new GitCommandOption("--bool", "--bool", @"Historical options for selecting a type specifier. Prefer instead --type (see above)."),
					new GitCommandOption("--bool-or-int", "--bool-or-int", @"Historical options for selecting a type specifier. Prefer instead --type (see above)."),
					new GitCommandOption("--default", "--default <value>", @"When using --get, and the requested variable is not found, behave as if <value> were the value assigned to the that variable."),
					new GitCommandOption("--edit", "--edit", @"Opens an editor to modify the specified config file; either --system, --global, or repository (default)."),
					new GitCommandOption("--expiry-date", "--expiry-date", @"Historical options for selecting a type specifier. Prefer instead --type (see above)."),
					new GitCommandOption("--file", "--file <config-file>", @"For writing options: write to the specified file rather than the repository .git/config.  For reading options: read only from the specified file rather than from all available files.   See also FILES."),
					new GitCommandOption("--fixed-value", "--fixed-value", @"When used with the value-pattern argument, treat value-pattern as an exact string instead of a regular expression. This will restrict the name/value pairs that are matched to only those where the value is exactly equal to the value-pattern."),
					new GitCommandOption("--get", "--get", @"Get the value for a given key (optionally filtered by a regex matching the value). Returns error code 1 if the key was not found and the last value if multiple key values were found."),
					new GitCommandOption("--get-all", "--get-all", @"Like get, but returns all values for a multi-valued key."),
					new GitCommandOption("--get-color", "--get-color <name> [<default>]", @"Find the color configured for name (e.g. color.diff.new) and output it as the ANSI color escape sequence to the standard output.  The optional default parameter is used instead, if there is no color configured for name.  --type=color [--default=<default>] is preferred over --get-color (but note that --get-color will omit the trailing newline printed by --type=color)."),
					new GitCommandOption("--get-colorbool", "--get-colorbool <name> [<stdout-is-tty>]", @"Find the color setting for <name> (e.g. color.diff) and output ""true"" or ""false"".  <stdout-is-tty> should be either ""true"" or ""false"", and is taken into account when configuration says ""auto"".  If <stdout-is-tty> is missing, then checks the standard output of the command itself, and exits with status 0 if color is to be used, or exits with status 1 otherwise. When the color setting for name is undefined, the command uses color.ui as fallback."),
					new GitCommandOption("--get-regexp", "--get-regexp", @"Like --get-all, but interprets the name as a regular expression and writes out the key names.  Regular expression matching is currently case-sensitive and done against a canonicalized version of the key in which section and variable names are lowercased, but subsection names are not."),
					new GitCommandOption("--get-urlmatch", "--get-urlmatch <name> <URL>", @"When given a two-part name section.key, the value for section.<URL>.key whose <URL> part matches the best to the given URL is returned (if no such key exists, the value for section.key is used as a fallback).  When given just the section as name, do so for all the keys in the section and list them.  Returns error code 1 if no value is found."),
					new GitCommandOption("--global", "--global", @"For writing options: write to global ~/.gitconfig file rather than the repository .git/config, write to $XDG_CONFIG_HOME/git/config file if this file exists and the ~/.gitconfig file doesn’t.  For reading options: read only from global ~/.gitconfig and from $XDG_CONFIG_HOME/git/config rather than from all available files.   See also FILES."),
					new GitCommandOption("--int", "--int", @"Historical options for selecting a type specifier. Prefer instead --type (see above)."),
					new GitCommandOption("--list", "--list", @"List all variables set in config file, along with their values."),
					new GitCommandOption("--local", "--local", @"For writing options: write to the repository .git/config file. This is the default behavior.  For reading options: read only from the repository .git/config rather than from all available files.   See also FILES."),
					new GitCommandOption("--name-only", "--name-only", @"Output only the names of config variables for --list or --get-regexp."),
					new GitCommandOption("--no-type", "--no-type", @"Un-sets the previously set type specifier (if one was previously set). This option requests that git config not canonicalize the retrieved variable. --no-type has no effect without --type=<type> or --<type>."),
					new GitCommandOption("--null", "--null", @"For all options that output values and/or keys, always end values with the null character (instead of a newline). Use newline instead as a delimiter between key and value. This allows for secure parsing of the output without getting confused e.g. by values that contain line breaks."),
					new GitCommandOption("--path", "--path", @"Historical options for selecting a type specifier. Prefer instead --type (see above)."),
					new GitCommandOption("--remove-section", "--remove-section", @"Remove the given section from the configuration file."),
					new GitCommandOption("--rename-section", "--rename-section", @"Rename the given section to a new name."),
					new GitCommandOption("--replace-all", "--replace-all", @"Default behavior is to replace at most one line. This replaces all lines matching the key (and optionally the value-pattern)."),
					new GitCommandOption("--show-origin", "--show-origin", @"Augment the output of all queried config options with the origin type (file, standard input, blob, command line) and the actual origin (config file path, ref, or blob id if applicable)."),
					new GitCommandOption("--show-scope", "--show-scope", @"Similar to --show-origin in that it augments the output of all queried config options with the scope of that value (local, global, system, command)."),
					new GitCommandOption("--system", "--system", @"For writing options: write to system-wide $(prefix)/etc/gitconfig rather than the repository .git/config.  For reading options: read only from system-wide $(prefix)/etc/gitconfig rather than from all available files.   See also FILES."),
					new GitCommandOption("--type", "--type <type>", @"git config will ensure that any input or output is valid under the given type constraint(s), and will canonicalize outgoing values in <type>'s canonical form.  Valid <type>'s include:     bool: canonicalize values as either ""true"" or ""false"".   int: canonicalize values as simple decimal numbers. An optional suffix of k, m, or g will cause the value to be multiplied by 1024, 1048576, or 1073741824 upon input.   bool-or-int: canonicalize according to either bool or int, as described above.   path: canonicalize by adding a leading ~ to the value of $HOME and ~user to the home directory for the specified user. This specifier has no effect when setting the value (but you can use git config section.variable ~/ from the command line to let your shell do the expansion.)   expiry-date: canonicalize by converting from a fixed or relative date-string to a timestamp. This specifier has no effect when setting the value.   color: When getting a value, canonicalize by converting to an ANSI color escape sequence. When setting a value, a sanity-check is performed to ensure that the given value is canonicalize-able as an ANSI color, but it is written as-is."),
					new GitCommandOption("--unset", "--unset", @"Remove the line matching the key from config file."),
					new GitCommandOption("--unset-all", "--unset-all", @"Remove all lines matching the key from config file."),
					new GitCommandOption("--worktree", "--worktree", @"Similar to --local except that $GIT_DIR/config.worktree is read from or written to if extensions.worktreeConfig is enabled. If not it’s the same as --local. Note that $GIT_DIR is equal to $GIT_COMMON_DIR for the main working tree, but is of the form $GIT_DIR/worktrees/<id>/ for other working trees. See git-worktree to learn how to enable extensions.worktreeConfig."),
					new GitCommandOption("-e", "-e", @"Opens an editor to modify the specified config file; either --system, --global, or repository (default)."),
					new GitCommandOption("-f", "-f <config-file>", @"For writing options: write to the specified file rather than the repository .git/config.  For reading options: read only from the specified file rather than from all available files.   See also FILES."),
					new GitCommandOption("-l", "-l", @"List all variables set in config file, along with their values."),
					new GitCommandOption("-z", "-z", @"For all options that output values and/or keys, always end values with the null character (instead of a newline). Use newline instead as a delimiter between key and value. This allows for secure parsing of the output without getting confused e.g. by values that contain line breaks."),
				}, 
	"count-objects" => new GitCommandOption[] {
					new GitCommandOption("--human-readable", "--human-readable", @"Print sizes in human readable format"),
					new GitCommandOption("--verbose", "--verbose", @"Report in more detail:  count: the number of loose objects   size: disk space consumed by loose objects, in KiB (unless -H is specified)   in-pack: the number of in-pack objects   size-pack: disk space consumed by the packs, in KiB (unless -H is specified)   prune-packable: the number of loose objects that are also present in the packs. These objects could be pruned using git prune-packed.   garbage: the number of files in object database that are neither valid loose objects nor valid packs   size-garbage: disk space consumed by garbage files, in KiB (unless -H is specified)   alternate: absolute path of alternate object databases; may appear multiple times, one line per path. Note that if the path contains non-printable characters, it may be surrounded by double-quotes and contain C-style backslashed escape sequences."),
					new GitCommandOption("-H", "-H", @"Print sizes in human readable format"),
					new GitCommandOption("-v", "-v", @"Report in more detail:  count: the number of loose objects   size: disk space consumed by loose objects, in KiB (unless -H is specified)   in-pack: the number of in-pack objects   size-pack: disk space consumed by the packs, in KiB (unless -H is specified)   prune-packable: the number of loose objects that are also present in the packs. These objects could be pruned using git prune-packed.   garbage: the number of files in object database that are neither valid loose objects nor valid packs   size-garbage: disk space consumed by garbage files, in KiB (unless -H is specified)   alternate: absolute path of alternate object databases; may appear multiple times, one line per path. Note that if the path contains non-printable characters, it may be surrounded by double-quotes and contain C-style backslashed escape sequences."),
				}, 
	"credential-cache--daemon" => new GitCommandOption[] {
				}, 
	"credential-cache" => new GitCommandOption[] {
					new GitCommandOption("--socket", "--socket <path>", @"Use <path> to contact a running cache daemon (or start a new cache daemon if one is not started). Defaults to $XDG_CACHE_HOME/git/credential/socket unless ~/.git-credential-cache/ exists in which case ~/.git-credential-cache/socket is used instead. If your home directory is on a network-mounted filesystem, you may need to change this to a local filesystem. You must specify an absolute path."),
					new GitCommandOption("--timeout", "--timeout <seconds>", @"Number of seconds to cache credentials (default: 900)."),
				}, 
	"credential-store" => new GitCommandOption[] {
					new GitCommandOption("--file", "--file=<path>", @"Use <path> to lookup and store credentials. The file will have its filesystem permissions set to prevent other users on the system from reading it, but will not be encrypted or otherwise protected. If not specified, credentials will be searched for from ~/.git-credentials and $XDG_CONFIG_HOME/git/credentials, and credentials will be written to ~/.git-credentials if it exists, or $XDG_CONFIG_HOME/git/credentials if it exists and the former does not. See also FILES."),
				}, 
	"credential" => new GitCommandOption[] {
				}, 
	"daemon" => new GitCommandOption[] {
					new GitCommandOption("<directory>", "<directory>", @"A directory to add to the whitelist of allowed directories. Unless --strict-paths is specified this will also include subdirectories of each named directory."),
					new GitCommandOption("--[no-]informative-errors", "--[no-]informative-errors", @"When informative errors are turned on, git-daemon will report more verbose errors to the client, differentiating conditions like ""no such repository"" from ""repository not exported"". This is more convenient for clients, but may leak information about the existence of unexported repositories.  When informative errors are not enabled, all errors report ""access denied"" to the client. The default is --no-informative-errors."),
					new GitCommandOption("--access-hook", "--access-hook=<path>", @"Every time a client connects, first run an external command specified by the <path> with service name (e.g. ""upload-pack""), path to the repository, hostname (%H), canonical hostname (%CH), IP address (%IP), and TCP port (%P) as its command-line arguments. The external command can decide to decline the service by exiting with a non-zero status (or to allow it by exiting with a zero status).  It can also look at the $REMOTE_ADDR and $REMOTE_PORT environment variables to learn about the requestor when making this decision.  The external command can optionally write a single line to its standard output to be sent to the requestor as an error message when it declines the service."),
					new GitCommandOption("--allow-override", "--allow-override=<service>", @"Allow/forbid overriding the site-wide default with per repository configuration.  By default, all the services may be overridden."),
					new GitCommandOption("--base-path", "--base-path=<path>", @"Remap all the path requests as relative to the given path. This is sort of ""Git root"" - if you run git daemon with --base-path=/srv/git on example.com, then if you later try to pull git://example.com/hello.git, git daemon will interpret the path as /srv/git/hello.git."),
					new GitCommandOption("--base-path-relaxed", "--base-path-relaxed", @"If --base-path is enabled and repo lookup fails, with this option git daemon will attempt to lookup without prefixing the base path. This is useful for switching to --base-path usage, while still allowing the old paths."),
					new GitCommandOption("--detach", "--detach", @"Detach from the shell. Implies --syslog."),
					new GitCommandOption("--disable", "--disable=<service>", @"Enable/disable the service site-wide per default.  Note that a service disabled site-wide can still be enabled per repository if it is marked overridable and the repository enables the service with a configuration item."),
					new GitCommandOption("--enable", "--enable=<service>", @"Enable/disable the service site-wide per default.  Note that a service disabled site-wide can still be enabled per repository if it is marked overridable and the repository enables the service with a configuration item."),
					new GitCommandOption("--export-all", "--export-all", @"Allow pulling from all directories that look like Git repositories (have the objects and refs subdirectories), even if they do not have the git-daemon-export-ok file."),
					new GitCommandOption("--forbid-override", "--forbid-override=<service>", @"Allow/forbid overriding the site-wide default with per repository configuration.  By default, all the services may be overridden."),
					new GitCommandOption("--group", "--group=<group>", @"Change daemon’s uid and gid before entering the service loop. When only --user is given without --group, the primary group ID for the user is used.  The values of the option are given to getpwnam and getgrnam and numeric IDs are not supported.  Giving these options is an error when used with --inetd; use the facility of inet daemon to achieve the same before spawning git daemon if needed.   Like many programs that switch user id, the daemon does not reset environment variables such as $HOME when it runs git programs, e.g. upload-pack and receive-pack. When using this option, you may also want to set and export HOME to point at the home directory of <user> before starting the daemon, and make sure any Git configuration files in that directory are readable by <user>."),
					new GitCommandOption("--inetd", "--inetd", @"Have the server run as an inetd service. Implies --syslog (may be overridden with --log-destination=). Incompatible with --detach, --port, --listen, --user and --group options."),
					new GitCommandOption("--init-timeout", "--init-timeout=<n>", @"Timeout (in seconds) between the moment the connection is established and the client request is received (typically a rather low value, since that should be basically immediate)."),
					new GitCommandOption("--interpolated-path", "--interpolated-path=<pathtemplate>", @"To support virtual hosting, an interpolated path template can be used to dynamically construct alternate paths.  The template supports %H for the target hostname as supplied by the client but converted to all lowercase, %CH for the canonical hostname, %IP for the server’s IP address, %P for the port number, and %D for the absolute path of the named repository. After interpolation, the path is validated against the directory whitelist."),
					new GitCommandOption("--listen", "--listen=<host_or_ipaddr>", @"Listen on a specific IP address or hostname.  IP addresses can be either an IPv4 address or an IPv6 address if supported.  If IPv6 is not supported, then --listen=hostname is also not supported and --listen must be given an IPv4 address. Can be given more than once. Incompatible with --inetd option."),
					new GitCommandOption("--log-destination", "--log-destination=<destination>", @"Send log messages to the specified destination. Note that this option does not imply --verbose, thus by default only error conditions will be logged. The <destination> must be one of:     stderr  Write to standard error. Note that if --detach is specified, the process disconnects from the real standard error, making this destination effectively equivalent to none.  syslog  Write to syslog, using the git-daemon identifier.  none  Disable all logging.       The default destination is syslog if --inetd or --detach is specified, otherwise stderr."),
					new GitCommandOption("--max-connections", "--max-connections=<n>", @"Maximum number of concurrent clients, defaults to 32.  Set it to zero for no limit."),
					new GitCommandOption("--pid-file", "--pid-file=<file>", @"Save the process id in file.  Ignored when the daemon is run under --inetd."),
					new GitCommandOption("--port", "--port=<n>", @"Listen on an alternative port.  Incompatible with --inetd option."),
					new GitCommandOption("--reuseaddr", "--reuseaddr", @"Use SO_REUSEADDR when binding the listening socket. This allows the server to restart without waiting for old connections to time out."),
					new GitCommandOption("--strict-paths", "--strict-paths", @"Match paths exactly (i.e. don’t allow ""/foo/repo"" when the real path is ""/foo/repo.git"" or ""/foo/repo/.git"") and don’t do user-relative paths. git daemon will refuse to start when this option is enabled and no whitelist is specified."),
					new GitCommandOption("--syslog", "--syslog", @"Short for --log-destination=syslog."),
					new GitCommandOption("--timeout", "--timeout=<n>", @"Timeout (in seconds) for specific client sub-requests. This includes the time it takes for the server to process the sub-request and the time spent waiting for the next client’s request."),
					new GitCommandOption("--user", "--user=<user>", @"Change daemon’s uid and gid before entering the service loop. When only --user is given without --group, the primary group ID for the user is used.  The values of the option are given to getpwnam and getgrnam and numeric IDs are not supported.  Giving these options is an error when used with --inetd; use the facility of inet daemon to achieve the same before spawning git daemon if needed.   Like many programs that switch user id, the daemon does not reset environment variables such as $HOME when it runs git programs, e.g. upload-pack and receive-pack. When using this option, you may also want to set and export HOME to point at the home directory of <user> before starting the daemon, and make sure any Git configuration files in that directory are readable by <user>."),
					new GitCommandOption("--user-path", "--user-path=<path>", @"Allow ~user notation to be used in requests.  When specified with no parameter, requests to git://host/~alice/foo is taken as a request to access foo repository in the home directory of user alice. If --user-path=path is specified, the same request is taken as a request to access path/foo repository in the home directory of user alice."),
					new GitCommandOption("--user-path", "--user-path", @"Allow ~user notation to be used in requests.  When specified with no parameter, requests to git://host/~alice/foo is taken as a request to access foo repository in the home directory of user alice. If --user-path=path is specified, the same request is taken as a request to access path/foo repository in the home directory of user alice."),
					new GitCommandOption("--verbose", "--verbose", @"Log details about the incoming connections and requested files."),
					new GitCommandOption("none", "none", @"Disable all logging."),
					new GitCommandOption("stderr", "stderr", @"Write to standard error. Note that if --detach is specified, the process disconnects from the real standard error, making this destination effectively equivalent to none."),
					new GitCommandOption("syslog", "syslog", @"Write to syslog, using the git-daemon identifier."),
				}, 
	"describe" => new GitCommandOption[] {
					new GitCommandOption("<commit-ish>…​", "<commit-ish>…​", @"Commit-ish object names to describe.  Defaults to HEAD if omitted."),
					new GitCommandOption("--abbrev", "--abbrev=<n>", @"Instead of using the default number of hexadecimal digits (which will vary according to the number of objects in the repository with a default of 7) of the abbreviated object name, use <n> digits, or as many digits as needed to form a unique object name. An <n> of 0 will suppress long format, only showing the closest tag."),
					new GitCommandOption("--all", "--all", @"Instead of using only the annotated tags, use any ref found in refs/ namespace.  This option enables matching any known branch, remote-tracking branch, or lightweight tag."),
					new GitCommandOption("--always", "--always", @"Show uniquely abbreviated commit object as fallback."),
					new GitCommandOption("--broken[", "--broken[=<mark>]", @"Describe the state of the working tree.  When the working tree matches HEAD, the output is the same as ""git describe HEAD"".  If the working tree has local modification ""-dirty"" is appended to it.  If a repository is corrupt and Git cannot determine if there is local modification, Git will error out, unless ‘--broken’ is given, which appends the suffix ""-broken"" instead."),
					new GitCommandOption("--candidates", "--candidates=<n>", @"Instead of considering only the 10 most recent tags as candidates to describe the input commit-ish consider up to <n> candidates.  Increasing <n> above 10 will take slightly longer but may produce a more accurate result. An <n> of 0 will cause only exact matches to be output."),
					new GitCommandOption("--contains", "--contains", @"Instead of finding the tag that predates the commit, find the tag that comes after the commit, and thus contains it. Automatically implies --tags."),
					new GitCommandOption("--debug", "--debug", @"Verbosely display information about the searching strategy being employed to standard error.  The tag name will still be printed to standard out."),
					new GitCommandOption("--dirty[", "--dirty[=<mark>]", @"Describe the state of the working tree.  When the working tree matches HEAD, the output is the same as ""git describe HEAD"".  If the working tree has local modification ""-dirty"" is appended to it.  If a repository is corrupt and Git cannot determine if there is local modification, Git will error out, unless ‘--broken’ is given, which appends the suffix ""-broken"" instead."),
					new GitCommandOption("--exact-match", "--exact-match", @"Only output exact matches (a tag directly references the supplied commit).  This is a synonym for --candidates=0."),
					new GitCommandOption("--exclude", "--exclude <pattern>", @"Do not consider tags matching the given glob pattern, excluding the ""refs/tags/"" prefix. If used with --all, it also does not consider local branches and remote-tracking references matching the pattern, excluding respectively ""refs/heads/"" and ""refs/remotes/"" prefix; references of other types are never considered. If given multiple times, a list of patterns will be accumulated and tags matching any of the patterns will be excluded. When combined with --match a tag will be considered when it matches at least one --match pattern and does not match any of the --exclude patterns. Use --no-exclude to clear and reset the list of patterns."),
					new GitCommandOption("--first-parent", "--first-parent", @"Follow only the first parent commit upon seeing a merge commit. This is useful when you wish to not match tags on branches merged in the history of the target commit."),
					new GitCommandOption("--long", "--long", @"Always output the long format (the tag, the number of commits and the abbreviated commit name) even when it matches a tag. This is useful when you want to see parts of the commit object name in ""describe"" output, even when the commit in question happens to be a tagged version.  Instead of just emitting the tag name, it will describe such a commit as v1.2-0-gdeadbee (0th commit since tag v1.2 that points at object deadbee…​.)."),
					new GitCommandOption("--match", "--match <pattern>", @"Only consider tags matching the given glob pattern, excluding the ""refs/tags/"" prefix. If used with --all, it also considers local branches and remote-tracking references matching the pattern, excluding respectively ""refs/heads/"" and ""refs/remotes/"" prefix; references of other types are never considered. If given multiple times, a list of patterns will be accumulated, and tags matching any of the patterns will be considered.  Use --no-match to clear and reset the list of patterns."),
					new GitCommandOption("--tags", "--tags", @"Instead of using only the annotated tags, use any tag found in refs/tags namespace.  This option enables matching a lightweight (non-annotated) tag."),
				}, 
	"diff-files" => new GitCommandOption[] {
					new GitCommandOption("<limit>", "<limit>", @"An integer parameter specifies a cut-off percent (3% by default). Directories contributing less than this percentage of the changes are not shown in the output."),
					new GitCommandOption("--[no-]rename-empty", "--[no-]rename-empty", @"Whether to use empty blobs as rename source."),
					new GitCommandOption("--abbrev[", "--abbrev[=<n>]", @"Instead of showing the full 40-byte hexadecimal object name in diff-raw format output and diff-tree header lines, show the shortest prefix that is at least <n> hexdigits long that uniquely refers the object. In diff-patch output format, --full-index takes higher precedence, i.e. if --full-index is specified, full blob names will be shown regardless of --abbrev. Non default number of digits can be specified with --abbrev=<n>."),
					new GitCommandOption("--anchored", "--anchored=<text>", @"Generate a diff using the ""anchored diff"" algorithm.  This option may be specified more than once.   If a line exists in both the source and destination, exists only once, and starts with this text, this algorithm attempts to prevent it from appearing as a deletion or addition in the output. It uses the ""patience diff"" algorithm internally."),
					new GitCommandOption("--binary", "--binary", @"In addition to --full-index, output a binary diff that can be applied with git-apply. Implies --patch."),
					new GitCommandOption("--break-rewrites[", "--break-rewrites[=[<n>][/<m>]]", @"Break complete rewrite changes into pairs of delete and create. This serves two purposes:  It affects the way a change that amounts to a total rewrite of a file not as a series of deletion and insertion mixed together with a very few lines that happen to match textually as the context, but as a single deletion of everything old followed by a single insertion of everything new, and the number m controls this aspect of the -B option (defaults to 60%). -B/70% specifies that less than 30% of the original should remain in the result for Git to consider it a total rewrite (i.e. otherwise the resulting patch will be a series of deletion and insertion mixed together with context lines).   When used with -M, a totally-rewritten file is also considered as the source of a rename (usually -M only considers a file that disappeared as the source of a rename), and the number n controls this aspect of the -B option (defaults to 50%). -B20% specifies that a change with addition and deletion compared to 20% or more of the file’s size are eligible for being picked up as a possible source of a rename to another file."),
					new GitCommandOption("--cc", "--cc", @"This compares stage 2 (our branch), stage 3 (their branch) and the working tree file and outputs a combined diff, similar to the way diff-tree shows a merge commit with these flags."),
					new GitCommandOption("--check", "--check", @"Warn if changes introduce conflict markers or whitespace errors. What are considered whitespace errors is controlled by core.whitespace configuration.  By default, trailing whitespaces (including lines that consist solely of whitespaces) and a space character that is immediately followed by a tab character inside the initial indent of the line are considered whitespace errors. Exits with non-zero status if problems are found. Not compatible with --exit-code."),
					new GitCommandOption("--color-moved-ws", "--color-moved-ws=<modes>", @"This configures how whitespace is ignored when performing the move detection for --color-moved. These modes can be given as a comma separated list:     no  Do not ignore whitespace when performing move detection.  ignore-space-at-eol  Ignore changes in whitespace at EOL.  ignore-space-change  Ignore changes in amount of whitespace.  This ignores whitespace at line end, and considers all other sequences of one or more whitespace characters to be equivalent.  ignore-all-space  Ignore whitespace when comparing lines. This ignores differences even if one line has whitespace where the other line has none.  allow-indentation-change  Initially ignore any whitespace in the move detection, then group the moved code blocks only into a block if the change in whitespace is the same per line. This is incompatible with the other modes."),
					new GitCommandOption("--color-moved[", "--color-moved[=<mode>]", @"Moved lines of code are colored differently. The <mode> defaults to no if the option is not given and to zebra if the option with no mode is given. The mode must be one of:     no  Moved lines are not highlighted.  default  Is a synonym for zebra. This may change to a more sensible mode in the future.  plain  Any line that is added in one location and was removed in another location will be colored with color.diff.newMoved. Similarly color.diff.oldMoved will be used for removed lines that are added somewhere else in the diff. This mode picks up any moved line, but it is not very useful in a review to determine if a block of code was moved without permutation.  blocks  Blocks of moved text of at least 20 alphanumeric characters are detected greedily. The detected blocks are painted using either the color.diff.{old,new}Moved color. Adjacent blocks cannot be told apart.  zebra  Blocks of moved text are detected as in blocks mode. The blocks are painted using either the color.diff.{old,new}Moved color or color.diff.{old,new}MovedAlternative. The change between the two colors indicates that a new block was detected.  dimmed-zebra  Similar to zebra, but additional dimming of uninteresting parts of moved code is performed. The bordering lines of two adjacent blocks are considered interesting, the rest is uninteresting. dimmed_zebra is a deprecated synonym."),
					new GitCommandOption("--color-words[", "--color-words[=<regex>]", @"Equivalent to --word-diff=color plus (if a regex was specified) --word-diff-regex=<regex>."),
					new GitCommandOption("--color[", "--color[=<when>]", @"Show colored diff. --color (i.e. without =<when>) is the same as --color=always. <when> can be one of always, never, or auto."),
					new GitCommandOption("--compact-summary", "--compact-summary", @"Output a condensed summary of extended header information such as file creations or deletions (""new"" or ""gone"", optionally ""+l"" if it’s a symlink) and mode changes (""+x"" or ""-x"" for adding or removing executable bit respectively) in diffstat. The information is put between the filename part and the graph part. Implies --stat."),
					new GitCommandOption("--cumulative", "--cumulative", @"Synonym for --dirstat=cumulative"),
					new GitCommandOption("--diff-algorithm", "--diff-algorithm={patience|minimal|histogram|myers}", @"Choose a diff algorithm. The variants are as follows:     default, myers  The basic greedy diff algorithm. Currently, this is the default.  minimal  Spend extra time to make sure the smallest possible diff is produced.  patience  Use ""patience diff"" algorithm when generating patches.  histogram  This algorithm extends the patience algorithm to ""support low-occurrence common elements"".       For instance, if you configured the diff.algorithm variable to a non-default value and want to use the default one, then you have to use --diff-algorithm=default option."),
					new GitCommandOption("--diff-filter", "--diff-filter=[(A|C|D|M|R|T|U|X|B)…​[*]]", @"Select only files that are Added (A), Copied (C), Deleted (D), Modified (M), Renamed (R), have their type (i.e. regular file, symlink, submodule, …​) changed (T), are Unmerged (U), are Unknown (X), or have had their pairing Broken (B). Any combination of the filter characters (including none) can be used. When * (All-or-none) is added to the combination, all paths are selected if there is any file that matches other criteria in the comparison; if there is no file that matches other criteria, nothing is selected.  Also, these upper-case letters can be downcased to exclude.  E.g. --diff-filter=ad excludes added and deleted paths.   Note that not all diffs can feature all types. For instance, copied and renamed entries cannot appear if detection for those types is disabled."),
					new GitCommandOption("--dirstat-by-file[", "--dirstat-by-file[=<param1,param2>…​]", @"Synonym for --dirstat=files,param1,param2…​"),
					new GitCommandOption("--dirstat[", "--dirstat[=<param1,param2,…​>]", @"Output the distribution of relative amount of changes for each sub-directory. The behavior of --dirstat can be customized by passing it a comma separated list of parameters. The defaults are controlled by the diff.dirstat configuration variable (see git-config). The following parameters are available:     changes  Compute the dirstat numbers by counting the lines that have been removed from the source, or added to the destination. This ignores the amount of pure code movements within a file.  In other words, rearranging lines in a file is not counted as much as other changes. This is the default behavior when no parameter is given.  lines  Compute the dirstat numbers by doing the regular line-based diff analysis, and summing the removed/added line counts. (For binary files, count 64-byte chunks instead, since binary files have no natural concept of lines). This is a more expensive --dirstat behavior than the changes behavior, but it does count rearranged lines within a file as much as other changes. The resulting output is consistent with what you get from the other --*stat options.  files  Compute the dirstat numbers by counting the number of files changed. Each changed file counts equally in the dirstat analysis. This is the computationally cheapest --dirstat behavior, since it does not have to look at the file contents at all.  cumulative  Count changes in a child directory for the parent directory as well. Note that when using cumulative, the sum of the percentages reported may exceed 100%. The default (non-cumulative) behavior can be specified with the noncumulative parameter.  <limit>  An integer parameter specifies a cut-off percent (3% by default). Directories contributing less than this percentage of the changes are not shown in the output.       Example: The following will count changed files, while ignoring directories with less than 10% of the total amount of changed files, and accumulating child directory counts in the parent directories: --dirstat=files,10,cumulative."),
					new GitCommandOption("--dst-prefix", "--dst-prefix=<prefix>", @"Show the given destination prefix instead of ""b/""."),
					new GitCommandOption("--exit-code", "--exit-code", @"Make the program exit with codes similar to diff. That is, it exits with 1 if there were differences and 0 means no differences."),
					new GitCommandOption("--ext-diff", "--ext-diff", @"Allow an external diff helper to be executed. If you set an external diff driver with gitattributes, you need to use this option with git-log and friends."),
					new GitCommandOption("--find-copies-harder", "--find-copies-harder", @"For performance reasons, by default, -C option finds copies only if the original file of the copy was modified in the same changeset.  This flag makes the command inspect unmodified files as candidates for the source of copy.  This is a very expensive operation for large projects, so use it with caution.  Giving more than one -C option has the same effect."),
					new GitCommandOption("--find-copies[", "--find-copies[=<n>]", @"Detect copies as well as renames.  See also --find-copies-harder. If n is specified, it has the same meaning as for -M<n>."),
					new GitCommandOption("--find-object", "--find-object=<object-id>", @"Look for differences that change the number of occurrences of the specified object. Similar to -S, just the argument is different in that it doesn’t search for a specific string but for a specific object id.  The object can be a blob or a submodule commit. It implies the -t option in git-log to also find trees."),
					new GitCommandOption("--find-renames[", "--find-renames[=<n>]", @"Detect renames. If n is specified, it is a threshold on the similarity index (i.e. amount of addition/deletions compared to the file’s size). For example, -M90% means Git should consider a delete/add pair to be a rename if more than 90% of the file hasn’t changed.  Without a % sign, the number is to be read as a fraction, with a decimal point before it.  I.e., -M5 becomes 0.5, and is thus the same as -M50%.  Similarly, -M05 is the same as -M5%.  To limit detection to exact renames, use -M100%.  The default similarity index is 50%."),
					new GitCommandOption("--full-index", "--full-index", @"Instead of the first handful of characters, show the full pre- and post-image blob object names on the ""index"" line when generating patch format output."),
					new GitCommandOption("--function-context", "--function-context", @"Show whole function as context lines for each change. The function names are determined in the same way as git diff works out patch hunk headers (see Defining a custom hunk-header in gitattributes)."),
					new GitCommandOption("--histogram", "--histogram", @"Generate a diff using the ""histogram diff"" algorithm."),
					new GitCommandOption("--ignore-all-space", "--ignore-all-space", @"Ignore whitespace when comparing lines.  This ignores differences even if one line has whitespace where the other line has none."),
					new GitCommandOption("--ignore-blank-lines", "--ignore-blank-lines", @"Ignore changes whose lines are all blank."),
					new GitCommandOption("--ignore-cr-at-eol", "--ignore-cr-at-eol", @"Ignore carriage-return at the end of line when doing a comparison."),
					new GitCommandOption("--ignore-matching-lines", "--ignore-matching-lines=<regex>", @"Ignore changes whose all lines match <regex>.  This option may be specified more than once."),
					new GitCommandOption("--ignore-space-at-eol", "--ignore-space-at-eol", @"Ignore changes in whitespace at EOL."),
					new GitCommandOption("--ignore-space-change", "--ignore-space-change", @"Ignore changes in amount of whitespace.  This ignores whitespace at line end, and considers all other sequences of one or more whitespace characters to be equivalent."),
					new GitCommandOption("--ignore-submodules[", "--ignore-submodules[=<when>]", @"Ignore changes to submodules in the diff generation. <when> can be either ""none"", ""untracked"", ""dirty"" or ""all"", which is the default. Using ""none"" will consider the submodule modified when it either contains untracked or modified files or its HEAD differs from the commit recorded in the superproject and can be used to override any settings of the ignore option in git-config or gitmodules. When ""untracked"" is used submodules are not considered dirty when they only contain untracked content (but they are still scanned for modified content). Using ""dirty"" ignores all changes to the work tree of submodules, only changes to the commits stored in the superproject are shown (this was the behavior until 1.7.0). Using ""all"" hides all changes to submodules."),
					new GitCommandOption("--indent-heuristic", "--indent-heuristic", @"Enable the heuristic that shifts diff hunk boundaries to make patches easier to read. This is the default."),
					new GitCommandOption("--inter-hunk-context", "--inter-hunk-context=<lines>", @"Show the context between diff hunks, up to the specified number of lines, thereby fusing hunks that are close to each other. Defaults to diff.interHunkContext or 0 if the config option is unset."),
					new GitCommandOption("--irreversible-delete", "--irreversible-delete", @"Omit the preimage for deletes, i.e. print only the header but not the diff between the preimage and /dev/null. The resulting patch is not meant to be applied with patch or git apply; this is solely for people who want to just concentrate on reviewing the text after the change. In addition, the output obviously lacks enough information to apply such a patch in reverse, even manually, hence the name of the option.  When used together with -B, omit also the preimage in the deletion part of a delete/create pair."),
					new GitCommandOption("--ita-invisible-in-index", "--ita-invisible-in-index", @"By default entries added by ""git add -N"" appear as an existing empty file in ""git diff"" and a new file in ""git diff --cached"". This option makes the entry appear as a new file in ""git diff"" and non-existent in ""git diff --cached"". This option could be reverted with --ita-visible-in-index. Both options are experimental and could be removed in future."),
					new GitCommandOption("--line-prefix", "--line-prefix=<prefix>", @"Prepend an additional prefix to every line of output."),
					new GitCommandOption("--minimal", "--minimal", @"Spend extra time to make sure the smallest possible diff is produced."),
					new GitCommandOption("--name-only", "--name-only", @"Show only names of changed files. The file names are often encoded in UTF-8. For more information see the discussion about encoding in the git-log manual page."),
					new GitCommandOption("--name-status", "--name-status", @"Show only names and status of changed files. See the description of the --diff-filter option on what the status letters mean. Just like --name-only the file names are often encoded in UTF-8."),
					new GitCommandOption("--no-color", "--no-color", @"Turn off colored diff. It is the same as --color=never."),
					new GitCommandOption("--no-color-moved", "--no-color-moved", @"Turn off move detection. This can be used to override configuration settings. It is the same as --color-moved=no."),
					new GitCommandOption("--no-color-moved-ws", "--no-color-moved-ws", @"Do not ignore whitespace when performing move detection. This can be used to override configuration settings. It is the same as --color-moved-ws=no."),
					new GitCommandOption("--no-ext-diff", "--no-ext-diff", @"Disallow external diff drivers."),
					new GitCommandOption("--no-indent-heuristic", "--no-indent-heuristic", @"Disable the indent heuristic."),
					new GitCommandOption("--no-patch", "--no-patch", @"Suppress diff output. Useful for commands like git show that show the patch by default, or to cancel the effect of --patch."),
					new GitCommandOption("--no-prefix", "--no-prefix", @"Do not show any source or destination prefix."),
					new GitCommandOption("--no-relative", "--no-relative", @"When run from a subdirectory of the project, it can be told to exclude changes outside the directory and show pathnames relative to it with this option.  When you are not in a subdirectory (e.g. in a bare repository), you can name which subdirectory to make the output relative to by giving a <path> as an argument. --no-relative can be used to countermand both diff.relative config option and previous --relative."),
					new GitCommandOption("--no-renames", "--no-renames", @"Turn off rename detection, even when the configuration file gives the default to do so."),
					new GitCommandOption("--no-textconv", "--no-textconv", @"Allow (or disallow) external text conversion filters to be run when comparing binary files. See gitattributes for details. Because textconv filters are typically a one-way conversion, the resulting diff is suitable for human consumption, but cannot be applied. For this reason, textconv filters are enabled by default only for git-diff and git-log, but not for git-format-patch or diff plumbing commands."),
					new GitCommandOption("--numstat", "--numstat", @"Similar to --stat, but shows number of added and deleted lines in decimal notation and pathname without abbreviation, to make it more machine friendly.  For binary files, outputs two - instead of saying 0 0."),
					new GitCommandOption("--output", "--output=<file>", @"Output to a specific file instead of stdout."),
					new GitCommandOption("--output-indicator-context", "--output-indicator-context=<char>", @"Specify the character used to indicate new, old or context lines in the generated patch. Normally they are +, - and ' ' respectively."),
					new GitCommandOption("--output-indicator-new", "--output-indicator-new=<char>", @"Specify the character used to indicate new, old or context lines in the generated patch. Normally they are +, - and ' ' respectively."),
					new GitCommandOption("--output-indicator-old", "--output-indicator-old=<char>", @"Specify the character used to indicate new, old or context lines in the generated patch. Normally they are +, - and ' ' respectively."),
					new GitCommandOption("--patch", "--patch", @"Generate patch (see section on generating patches)."),
					new GitCommandOption("--patch-with-raw", "--patch-with-raw", @"Synonym for -p --raw."),
					new GitCommandOption("--patch-with-stat", "--patch-with-stat", @"Synonym for -p --stat."),
					new GitCommandOption("--patience", "--patience", @"Generate a diff using the ""patience diff"" algorithm."),
					new GitCommandOption("--pickaxe-all", "--pickaxe-all", @"When -S or -G finds a change, show all the changes in that changeset, not just the files that contain the change in <string>."),
					new GitCommandOption("--pickaxe-regex", "--pickaxe-regex", @"Treat the <string> given to -S as an extended POSIX regular expression to match."),
					new GitCommandOption("--quiet", "--quiet", @"Disable all output of the program. Implies --exit-code."),
					new GitCommandOption("--raw", "--raw", @"Generate the diff in raw format. This is the default."),
					new GitCommandOption("--relative[", "--relative[=<path>]", @"When run from a subdirectory of the project, it can be told to exclude changes outside the directory and show pathnames relative to it with this option.  When you are not in a subdirectory (e.g. in a bare repository), you can name which subdirectory to make the output relative to by giving a <path> as an argument. --no-relative can be used to countermand both diff.relative config option and previous --relative."),
					new GitCommandOption("--rotate-to", "--rotate-to=<file>", @"Discard the files before the named <file> from the output (i.e. skip to), or move them to the end of the output (i.e. rotate to).  These were invented primarily for use of the git difftool command, and may not be very useful otherwise."),
					new GitCommandOption("--shortstat", "--shortstat", @"Output only the last line of the --stat format containing total number of modified files, as well as number of added and deleted lines."),
					new GitCommandOption("--skip-to", "--skip-to=<file>", @"Discard the files before the named <file> from the output (i.e. skip to), or move them to the end of the output (i.e. rotate to).  These were invented primarily for use of the git difftool command, and may not be very useful otherwise."),
					new GitCommandOption("--src-prefix", "--src-prefix=<prefix>", @"Show the given source prefix instead of ""a/""."),
					new GitCommandOption("--stat[", "--stat[=<width>[,<name-width>[,<count>]]]", @"Generate a diffstat. By default, as much space as necessary will be used for the filename part, and the rest for the graph part. Maximum width defaults to terminal width, or 80 columns if not connected to a terminal, and can be overridden by <width>. The width of the filename part can be limited by giving another width <name-width> after a comma. The width of the graph part can be limited by using --stat-graph-width=<width> (affects all commands generating a stat graph) or by setting diff.statGraphWidth=<width> (does not affect git format-patch). By giving a third parameter <count>, you can limit the output to the first <count> lines, followed by ... if there are more.  These parameters can also be set individually with --stat-width=<width>, --stat-name-width=<name-width> and --stat-count=<count>."),
					new GitCommandOption("--submodule[", "--submodule[=<format>]", @"Specify how differences in submodules are shown.  When specifying --submodule=short the short format is used.  This format just shows the names of the commits at the beginning and end of the range. When --submodule or --submodule=log is specified, the log format is used.  This format lists the commits in the range like git-submodule summary does.  When --submodule=diff is specified, the diff format is used.  This format shows an inline diff of the changes in the submodule contents between the commit range.  Defaults to diff.submodule or the short format if the config option is unset."),
					new GitCommandOption("--summary", "--summary", @"Output a condensed summary of extended header information such as creations, renames and mode changes."),
					new GitCommandOption("--text", "--text", @"Treat all files as text."),
					new GitCommandOption("--textconv", "--textconv", @"Allow (or disallow) external text conversion filters to be run when comparing binary files. See gitattributes for details. Because textconv filters are typically a one-way conversion, the resulting diff is suitable for human consumption, but cannot be applied. For this reason, textconv filters are enabled by default only for git-diff and git-log, but not for git-format-patch or diff plumbing commands."),
					new GitCommandOption("--unified", "--unified=<n>", @"Generate diffs with <n> lines of context instead of the usual three. Implies --patch."),
					new GitCommandOption("--word-diff-regex", "--word-diff-regex=<regex>", @"Use <regex> to decide what a word is, instead of considering runs of non-whitespace to be a word.  Also implies --word-diff unless it was already enabled.  Every non-overlapping match of the <regex> is considered a word.  Anything between these matches is considered whitespace and ignored(!) for the purposes of finding differences.  You may want to append |[^[:space:]] to your regular expression to make sure that it matches all non-whitespace characters. A match that contains a newline is silently truncated(!) at the newline.   For example, --word-diff-regex=. will treat each character as a word and, correspondingly, show differences character by character.   The regex can also be set via a diff driver or configuration option, see gitattributes or git-config.  Giving it explicitly overrides any diff driver or configuration setting.  Diff drivers override configuration settings."),
					new GitCommandOption("--word-diff[", "--word-diff[=<mode>]", @"Show a word diff, using the <mode> to delimit changed words. By default, words are delimited by whitespace; see --word-diff-regex below.  The <mode> defaults to plain, and must be one of:     color  Highlight changed words using only colors.  Implies --color.  plain  Show words as [-removed-] and {+added+}.  Makes no attempts to escape the delimiters if they appear in the input, so the output may be ambiguous.  porcelain  Use a special line-based format intended for script consumption.  Added/removed/unchanged runs are printed in the usual unified diff format, starting with a +/-/` ` character at the beginning of the line and extending to the end of the line.  Newlines in the input are represented by a tilde ~ on a line of its own.  none  Disable word diff again.       Note that despite the name of the first mode, color is used to highlight the changed parts in all modes if enabled."),
					new GitCommandOption("--ws-error-highlight", "--ws-error-highlight=<kind>", @"Highlight whitespace errors in the context, old or new lines of the diff.  Multiple values are separated by comma, none resets previous values, default reset the list to new and all is a shorthand for old,new,context.  When this option is not given, and the configuration variable diff.wsErrorHighlight is not set, only whitespace errors in new lines are highlighted. The whitespace errors are colored with color.diff.whitespace."),
					new GitCommandOption("-0", "-0", @"Diff against the ""base"" version, ""our branch"" or ""their branch"" respectively.  With these options, diffs for merged entries are not shown.  The default is to diff against our branch (-2) and the cleanly resolved paths.  The option -0 can be given to omit diff output for unmerged entries and just show ""Unmerged""."),
					new GitCommandOption("-1", "-1 --base", @"Diff against the ""base"" version, ""our branch"" or ""their branch"" respectively.  With these options, diffs for merged entries are not shown.  The default is to diff against our branch (-2) and the cleanly resolved paths.  The option -0 can be given to omit diff output for unmerged entries and just show ""Unmerged""."),
					new GitCommandOption("-2", "-2 --ours", @"Diff against the ""base"" version, ""our branch"" or ""their branch"" respectively.  With these options, diffs for merged entries are not shown.  The default is to diff against our branch (-2) and the cleanly resolved paths.  The option -0 can be given to omit diff output for unmerged entries and just show ""Unmerged""."),
					new GitCommandOption("-3", "-3 --theirs", @"Diff against the ""base"" version, ""our branch"" or ""their branch"" respectively.  With these options, diffs for merged entries are not shown.  The default is to diff against our branch (-2) and the cleanly resolved paths.  The option -0 can be given to omit diff output for unmerged entries and just show ""Unmerged""."),
					new GitCommandOption("-a", "-a", @"Treat all files as text."),
					new GitCommandOption("-b", "-b", @"Ignore changes in amount of whitespace.  This ignores whitespace at line end, and considers all other sequences of one or more whitespace characters to be equivalent."),
					new GitCommandOption("-B[<n>][/<m>]", "-B[<n>][/<m>]", @"Break complete rewrite changes into pairs of delete and create. This serves two purposes:  It affects the way a change that amounts to a total rewrite of a file not as a series of deletion and insertion mixed together with a very few lines that happen to match textually as the context, but as a single deletion of everything old followed by a single insertion of everything new, and the number m controls this aspect of the -B option (defaults to 60%). -B/70% specifies that less than 30% of the original should remain in the result for Git to consider it a total rewrite (i.e. otherwise the resulting patch will be a series of deletion and insertion mixed together with context lines).   When used with -M, a totally-rewritten file is also considered as the source of a rename (usually -M only considers a file that disappeared as the source of a rename), and the number n controls this aspect of the -B option (defaults to 50%). -B20% specifies that a change with addition and deletion compared to 20% or more of the file’s size are eligible for being picked up as a possible source of a rename to another file."),
					new GitCommandOption("-c", "-c", @"This compares stage 2 (our branch), stage 3 (their branch) and the working tree file and outputs a combined diff, similar to the way diff-tree shows a merge commit with these flags."),
					new GitCommandOption("-C[<n>]", "-C[<n>]", @"Detect copies as well as renames.  See also --find-copies-harder. If n is specified, it has the same meaning as for -M<n>."),
					new GitCommandOption("-D", "-D", @"Omit the preimage for deletes, i.e. print only the header but not the diff between the preimage and /dev/null. The resulting patch is not meant to be applied with patch or git apply; this is solely for people who want to just concentrate on reviewing the text after the change. In addition, the output obviously lacks enough information to apply such a patch in reverse, even manually, hence the name of the option.  When used together with -B, omit also the preimage in the deletion part of a delete/create pair."),
					new GitCommandOption("-G<regex>", "-G<regex>", @"Look for differences whose patch text contains added/removed lines that match <regex>.  To illustrate the difference between -S<regex> --pickaxe-regex and -G<regex>, consider a commit with the following diff in the same file:    +    return frotz(nitfol, two->ptr, 1, 0); ... -    hit = frotz(nitfol, mf2.ptr, 1, 0);    While git log -G""frotz\(nitfol"" will show this commit, git log -S""frotz\(nitfol"" --pickaxe-regex will not (because the number of occurrences of that string did not change).   Unless --text is supplied patches of binary files without a textconv filter will be ignored.   See the pickaxe entry in gitdiffcore for more information."),
					new GitCommandOption("-I<regex>", "-I<regex>", @"Ignore changes whose all lines match <regex>.  This option may be specified more than once."),
					new GitCommandOption("-l<num>", "-l<num>", @"The -M and -C options involve some preliminary steps that can detect subsets of renames/copies cheaply, followed by an exhaustive fallback portion that compares all remaining unpaired destinations to all relevant sources.  (For renames, only remaining unpaired sources are relevant; for copies, all original sources are relevant.)  For N sources and destinations, this exhaustive check is O(N^2).  This option prevents the exhaustive portion of rename/copy detection from running if the number of source/destination files involved exceeds the specified number.  Defaults to diff.renameLimit. Note that a value of 0 is treated as unlimited."),
					new GitCommandOption("-M[<n>]", "-M[<n>]", @"Detect renames. If n is specified, it is a threshold on the similarity index (i.e. amount of addition/deletions compared to the file’s size). For example, -M90% means Git should consider a delete/add pair to be a rename if more than 90% of the file hasn’t changed.  Without a % sign, the number is to be read as a fraction, with a decimal point before it.  I.e., -M5 becomes 0.5, and is thus the same as -M50%.  Similarly, -M05 is the same as -M5%.  To limit detection to exact renames, use -M100%.  The default similarity index is 50%."),
					new GitCommandOption("-O<orderfile>", "-O<orderfile>", @"Control the order in which files appear in the output. This overrides the diff.orderFile configuration variable (see git-config).  To cancel diff.orderFile, use -O/dev/null.  The output order is determined by the order of glob patterns in <orderfile>. All files with pathnames that match the first pattern are output first, all files with pathnames that match the second pattern (but not the first) are output next, and so on. All files with pathnames that do not match any pattern are output last, as if there was an implicit match-all pattern at the end of the file. If multiple pathnames have the same rank (they match the same pattern but no earlier patterns), their output order relative to each other is the normal order.   <orderfile> is parsed as follows:       Blank lines are ignored, so they can be used as separators for readability.   Lines starting with a hash (""#"") are ignored, so they can be used for comments.  Add a backslash (""\"") to the beginning of the pattern if it starts with a hash.   Each other line contains a single pattern.       Patterns have the same syntax and semantics as patterns used for fnmatch without the FNM_PATHNAME flag, except a pathname also matches a pattern if removing any number of the final pathname components matches the pattern.  For example, the pattern ""foo*bar"" matches ""fooasdfbar"" and ""foo/bar/baz/asdf"" but not ""foobarx""."),
					new GitCommandOption("-p", "-p", @"Generate patch (see section on generating patches)."),
					new GitCommandOption("-q", "-q", @"Remain silent even on nonexistent files"),
					new GitCommandOption("-R", "-R", @"Swap two inputs; that is, show differences from index or on-disk file to tree contents."),
					new GitCommandOption("-s", "-s", @"Suppress diff output. Useful for commands like git show that show the patch by default, or to cancel the effect of --patch."),
					new GitCommandOption("-S<string>", "-S<string>", @"Look for differences that change the number of occurrences of the specified string (i.e. addition/deletion) in a file. Intended for the scripter’s use.  It is useful when you’re looking for an exact block of code (like a struct), and want to know the history of that block since it first came into being: use the feature iteratively to feed the interesting block in the preimage back into -S, and keep going until you get the very first version of the block.   Binary files are searched as well."),
					new GitCommandOption("-u", "-u", @"Generate patch (see section on generating patches)."),
					new GitCommandOption("-U<n>", "-U<n>", @"Generate diffs with <n> lines of context instead of the usual three. Implies --patch."),
					new GitCommandOption("-W", "-W", @"Show whole function as context lines for each change. The function names are determined in the same way as git diff works out patch hunk headers (see Defining a custom hunk-header in gitattributes)."),
					new GitCommandOption("-w", "-w", @"Ignore whitespace when comparing lines.  This ignores differences even if one line has whitespace where the other line has none."),
					new GitCommandOption("-X[<param1,param2,…​>]", "-X[<param1,param2,…​>]", @"Output the distribution of relative amount of changes for each sub-directory. The behavior of --dirstat can be customized by passing it a comma separated list of parameters. The defaults are controlled by the diff.dirstat configuration variable (see git-config). The following parameters are available:     changes  Compute the dirstat numbers by counting the lines that have been removed from the source, or added to the destination. This ignores the amount of pure code movements within a file.  In other words, rearranging lines in a file is not counted as much as other changes. This is the default behavior when no parameter is given.  lines  Compute the dirstat numbers by doing the regular line-based diff analysis, and summing the removed/added line counts. (For binary files, count 64-byte chunks instead, since binary files have no natural concept of lines). This is a more expensive --dirstat behavior than the changes behavior, but it does count rearranged lines within a file as much as other changes. The resulting output is consistent with what you get from the other --*stat options.  files  Compute the dirstat numbers by counting the number of files changed. Each changed file counts equally in the dirstat analysis. This is the computationally cheapest --dirstat behavior, since it does not have to look at the file contents at all.  cumulative  Count changes in a child directory for the parent directory as well. Note that when using cumulative, the sum of the percentages reported may exceed 100%. The default (non-cumulative) behavior can be specified with the noncumulative parameter.  <limit>  An integer parameter specifies a cut-off percent (3% by default). Directories contributing less than this percentage of the changes are not shown in the output.       Example: The following will count changed files, while ignoring directories with less than 10% of the total amount of changed files, and accumulating child directory counts in the parent directories: --dirstat=files,10,cumulative."),
					new GitCommandOption("-z", "-z", @"When --raw, --numstat, --name-only or --name-status has been given, do not munge pathnames and use NULs as output field terminators.  Without this option, pathnames with ""unusual"" characters are quoted as explained for the configuration variable core.quotePath (see git-config)."),
					new GitCommandOption("allow-indentation-change", "allow-indentation-change", @"Initially ignore any whitespace in the move detection, then group the moved code blocks only into a block if the change in whitespace is the same per line. This is incompatible with the other modes."),
					new GitCommandOption("blocks", "blocks", @"Blocks of moved text of at least 20 alphanumeric characters are detected greedily. The detected blocks are painted using either the color.diff.{old,new}Moved color. Adjacent blocks cannot be told apart."),
					new GitCommandOption("changes", "changes", @"Compute the dirstat numbers by counting the lines that have been removed from the source, or added to the destination. This ignores the amount of pure code movements within a file.  In other words, rearranging lines in a file is not counted as much as other changes. This is the default behavior when no parameter is given."),
					new GitCommandOption("color", "color", @"Highlight changed words using only colors.  Implies --color."),
					new GitCommandOption("cumulative", "cumulative", @"Count changes in a child directory for the parent directory as well. Note that when using cumulative, the sum of the percentages reported may exceed 100%. The default (non-cumulative) behavior can be specified with the noncumulative parameter."),
					new GitCommandOption("default", "default", @"Is a synonym for zebra. This may change to a more sensible mode in the future."),
					new GitCommandOption("default,", "default, myers", @"The basic greedy diff algorithm. Currently, this is the default."),
					new GitCommandOption("dimmed-zebra", "dimmed-zebra", @"Similar to zebra, but additional dimming of uninteresting parts of moved code is performed. The bordering lines of two adjacent blocks are considered interesting, the rest is uninteresting. dimmed_zebra is a deprecated synonym."),
					new GitCommandOption("files", "files", @"Compute the dirstat numbers by counting the number of files changed. Each changed file counts equally in the dirstat analysis. This is the computationally cheapest --dirstat behavior, since it does not have to look at the file contents at all."),
					new GitCommandOption("histogram", "histogram", @"This algorithm extends the patience algorithm to ""support low-occurrence common elements""."),
					new GitCommandOption("ignore-all-space", "ignore-all-space", @"Ignore whitespace when comparing lines. This ignores differences even if one line has whitespace where the other line has none."),
					new GitCommandOption("ignore-space-at-eol", "ignore-space-at-eol", @"Ignore changes in whitespace at EOL."),
					new GitCommandOption("ignore-space-change", "ignore-space-change", @"Ignore changes in amount of whitespace.  This ignores whitespace at line end, and considers all other sequences of one or more whitespace characters to be equivalent."),
					new GitCommandOption("lines", "lines", @"Compute the dirstat numbers by doing the regular line-based diff analysis, and summing the removed/added line counts. (For binary files, count 64-byte chunks instead, since binary files have no natural concept of lines). This is a more expensive --dirstat behavior than the changes behavior, but it does count rearranged lines within a file as much as other changes. The resulting output is consistent with what you get from the other --*stat options."),
					new GitCommandOption("minimal", "minimal", @"Spend extra time to make sure the smallest possible diff is produced."),
					new GitCommandOption("no", "no", @"Do not ignore whitespace when performing move detection."),
					new GitCommandOption("no", "no", @"Moved lines are not highlighted."),
					new GitCommandOption("none", "none", @"Disable word diff again."),
					new GitCommandOption("patience", "patience", @"Use ""patience diff"" algorithm when generating patches."),
					new GitCommandOption("plain", "plain", @"Show words as [-removed-] and {+added+}.  Makes no attempts to escape the delimiters if they appear in the input, so the output may be ambiguous."),
					new GitCommandOption("plain", "plain", @"Any line that is added in one location and was removed in another location will be colored with color.diff.newMoved. Similarly color.diff.oldMoved will be used for removed lines that are added somewhere else in the diff. This mode picks up any moved line, but it is not very useful in a review to determine if a block of code was moved without permutation."),
					new GitCommandOption("porcelain", "porcelain", @"Use a special line-based format intended for script consumption.  Added/removed/unchanged runs are printed in the usual unified diff format, starting with a +/-/` ` character at the beginning of the line and extending to the end of the line.  Newlines in the input are represented by a tilde ~ on a line of its own."),
					new GitCommandOption("zebra", "zebra", @"Blocks of moved text are detected as in blocks mode. The blocks are painted using either the color.diff.{old,new}Moved color or color.diff.{old,new}MovedAlternative. The change between the two colors indicates that a new block was detected."),
				}, 
	"diff-index" => new GitCommandOption[] {
					new GitCommandOption("<limit>", "<limit>", @"An integer parameter specifies a cut-off percent (3% by default). Directories contributing less than this percentage of the changes are not shown in the output."),
					new GitCommandOption("<tree-ish>", "<tree-ish>", @"The id of a tree object to diff against."),
					new GitCommandOption("--[no-]rename-empty", "--[no-]rename-empty", @"Whether to use empty blobs as rename source."),
					new GitCommandOption("--abbrev[", "--abbrev[=<n>]", @"Instead of showing the full 40-byte hexadecimal object name in diff-raw format output and diff-tree header lines, show the shortest prefix that is at least <n> hexdigits long that uniquely refers the object. In diff-patch output format, --full-index takes higher precedence, i.e. if --full-index is specified, full blob names will be shown regardless of --abbrev. Non default number of digits can be specified with --abbrev=<n>."),
					new GitCommandOption("--anchored", "--anchored=<text>", @"Generate a diff using the ""anchored diff"" algorithm.  This option may be specified more than once.   If a line exists in both the source and destination, exists only once, and starts with this text, this algorithm attempts to prevent it from appearing as a deletion or addition in the output. It uses the ""patience diff"" algorithm internally."),
					new GitCommandOption("--binary", "--binary", @"In addition to --full-index, output a binary diff that can be applied with git-apply. Implies --patch."),
					new GitCommandOption("--break-rewrites[", "--break-rewrites[=[<n>][/<m>]]", @"Break complete rewrite changes into pairs of delete and create. This serves two purposes:  It affects the way a change that amounts to a total rewrite of a file not as a series of deletion and insertion mixed together with a very few lines that happen to match textually as the context, but as a single deletion of everything old followed by a single insertion of everything new, and the number m controls this aspect of the -B option (defaults to 60%). -B/70% specifies that less than 30% of the original should remain in the result for Git to consider it a total rewrite (i.e. otherwise the resulting patch will be a series of deletion and insertion mixed together with context lines).   When used with -M, a totally-rewritten file is also considered as the source of a rename (usually -M only considers a file that disappeared as the source of a rename), and the number n controls this aspect of the -B option (defaults to 50%). -B20% specifies that a change with addition and deletion compared to 20% or more of the file’s size are eligible for being picked up as a possible source of a rename to another file."),
					new GitCommandOption("--cached", "--cached", @"Do not consider the on-disk file at all."),
					new GitCommandOption("--check", "--check", @"Warn if changes introduce conflict markers or whitespace errors. What are considered whitespace errors is controlled by core.whitespace configuration.  By default, trailing whitespaces (including lines that consist solely of whitespaces) and a space character that is immediately followed by a tab character inside the initial indent of the line are considered whitespace errors. Exits with non-zero status if problems are found. Not compatible with --exit-code."),
					new GitCommandOption("--color-moved-ws", "--color-moved-ws=<modes>", @"This configures how whitespace is ignored when performing the move detection for --color-moved. These modes can be given as a comma separated list:     no  Do not ignore whitespace when performing move detection.  ignore-space-at-eol  Ignore changes in whitespace at EOL.  ignore-space-change  Ignore changes in amount of whitespace.  This ignores whitespace at line end, and considers all other sequences of one or more whitespace characters to be equivalent.  ignore-all-space  Ignore whitespace when comparing lines. This ignores differences even if one line has whitespace where the other line has none.  allow-indentation-change  Initially ignore any whitespace in the move detection, then group the moved code blocks only into a block if the change in whitespace is the same per line. This is incompatible with the other modes."),
					new GitCommandOption("--color-moved[", "--color-moved[=<mode>]", @"Moved lines of code are colored differently. The <mode> defaults to no if the option is not given and to zebra if the option with no mode is given. The mode must be one of:     no  Moved lines are not highlighted.  default  Is a synonym for zebra. This may change to a more sensible mode in the future.  plain  Any line that is added in one location and was removed in another location will be colored with color.diff.newMoved. Similarly color.diff.oldMoved will be used for removed lines that are added somewhere else in the diff. This mode picks up any moved line, but it is not very useful in a review to determine if a block of code was moved without permutation.  blocks  Blocks of moved text of at least 20 alphanumeric characters are detected greedily. The detected blocks are painted using either the color.diff.{old,new}Moved color. Adjacent blocks cannot be told apart.  zebra  Blocks of moved text are detected as in blocks mode. The blocks are painted using either the color.diff.{old,new}Moved color or color.diff.{old,new}MovedAlternative. The change between the two colors indicates that a new block was detected.  dimmed-zebra  Similar to zebra, but additional dimming of uninteresting parts of moved code is performed. The bordering lines of two adjacent blocks are considered interesting, the rest is uninteresting. dimmed_zebra is a deprecated synonym."),
					new GitCommandOption("--color-words[", "--color-words[=<regex>]", @"Equivalent to --word-diff=color plus (if a regex was specified) --word-diff-regex=<regex>."),
					new GitCommandOption("--color[", "--color[=<when>]", @"Show colored diff. --color (i.e. without =<when>) is the same as --color=always. <when> can be one of always, never, or auto."),
					new GitCommandOption("--compact-summary", "--compact-summary", @"Output a condensed summary of extended header information such as file creations or deletions (""new"" or ""gone"", optionally ""+l"" if it’s a symlink) and mode changes (""+x"" or ""-x"" for adding or removing executable bit respectively) in diffstat. The information is put between the filename part and the graph part. Implies --stat."),
					new GitCommandOption("--cumulative", "--cumulative", @"Synonym for --dirstat=cumulative"),
					new GitCommandOption("--diff-algorithm", "--diff-algorithm={patience|minimal|histogram|myers}", @"Choose a diff algorithm. The variants are as follows:     default, myers  The basic greedy diff algorithm. Currently, this is the default.  minimal  Spend extra time to make sure the smallest possible diff is produced.  patience  Use ""patience diff"" algorithm when generating patches.  histogram  This algorithm extends the patience algorithm to ""support low-occurrence common elements"".       For instance, if you configured the diff.algorithm variable to a non-default value and want to use the default one, then you have to use --diff-algorithm=default option."),
					new GitCommandOption("--diff-filter", "--diff-filter=[(A|C|D|M|R|T|U|X|B)…​[*]]", @"Select only files that are Added (A), Copied (C), Deleted (D), Modified (M), Renamed (R), have their type (i.e. regular file, symlink, submodule, …​) changed (T), are Unmerged (U), are Unknown (X), or have had their pairing Broken (B). Any combination of the filter characters (including none) can be used. When * (All-or-none) is added to the combination, all paths are selected if there is any file that matches other criteria in the comparison; if there is no file that matches other criteria, nothing is selected.  Also, these upper-case letters can be downcased to exclude.  E.g. --diff-filter=ad excludes added and deleted paths.   Note that not all diffs can feature all types. For instance, copied and renamed entries cannot appear if detection for those types is disabled."),
					new GitCommandOption("--dirstat-by-file[", "--dirstat-by-file[=<param1,param2>…​]", @"Synonym for --dirstat=files,param1,param2…​"),
					new GitCommandOption("--dirstat[", "--dirstat[=<param1,param2,…​>]", @"Output the distribution of relative amount of changes for each sub-directory. The behavior of --dirstat can be customized by passing it a comma separated list of parameters. The defaults are controlled by the diff.dirstat configuration variable (see git-config). The following parameters are available:     changes  Compute the dirstat numbers by counting the lines that have been removed from the source, or added to the destination. This ignores the amount of pure code movements within a file.  In other words, rearranging lines in a file is not counted as much as other changes. This is the default behavior when no parameter is given.  lines  Compute the dirstat numbers by doing the regular line-based diff analysis, and summing the removed/added line counts. (For binary files, count 64-byte chunks instead, since binary files have no natural concept of lines). This is a more expensive --dirstat behavior than the changes behavior, but it does count rearranged lines within a file as much as other changes. The resulting output is consistent with what you get from the other --*stat options.  files  Compute the dirstat numbers by counting the number of files changed. Each changed file counts equally in the dirstat analysis. This is the computationally cheapest --dirstat behavior, since it does not have to look at the file contents at all.  cumulative  Count changes in a child directory for the parent directory as well. Note that when using cumulative, the sum of the percentages reported may exceed 100%. The default (non-cumulative) behavior can be specified with the noncumulative parameter.  <limit>  An integer parameter specifies a cut-off percent (3% by default). Directories contributing less than this percentage of the changes are not shown in the output.       Example: The following will count changed files, while ignoring directories with less than 10% of the total amount of changed files, and accumulating child directory counts in the parent directories: --dirstat=files,10,cumulative."),
					new GitCommandOption("--dst-prefix", "--dst-prefix=<prefix>", @"Show the given destination prefix instead of ""b/""."),
					new GitCommandOption("--exit-code", "--exit-code", @"Make the program exit with codes similar to diff. That is, it exits with 1 if there were differences and 0 means no differences."),
					new GitCommandOption("--ext-diff", "--ext-diff", @"Allow an external diff helper to be executed. If you set an external diff driver with gitattributes, you need to use this option with git-log and friends."),
					new GitCommandOption("--find-copies-harder", "--find-copies-harder", @"For performance reasons, by default, -C option finds copies only if the original file of the copy was modified in the same changeset.  This flag makes the command inspect unmodified files as candidates for the source of copy.  This is a very expensive operation for large projects, so use it with caution.  Giving more than one -C option has the same effect."),
					new GitCommandOption("--find-copies[", "--find-copies[=<n>]", @"Detect copies as well as renames.  See also --find-copies-harder. If n is specified, it has the same meaning as for -M<n>."),
					new GitCommandOption("--find-object", "--find-object=<object-id>", @"Look for differences that change the number of occurrences of the specified object. Similar to -S, just the argument is different in that it doesn’t search for a specific string but for a specific object id.  The object can be a blob or a submodule commit. It implies the -t option in git-log to also find trees."),
					new GitCommandOption("--find-renames[", "--find-renames[=<n>]", @"Detect renames. If n is specified, it is a threshold on the similarity index (i.e. amount of addition/deletions compared to the file’s size). For example, -M90% means Git should consider a delete/add pair to be a rename if more than 90% of the file hasn’t changed.  Without a % sign, the number is to be read as a fraction, with a decimal point before it.  I.e., -M5 becomes 0.5, and is thus the same as -M50%.  Similarly, -M05 is the same as -M5%.  To limit detection to exact renames, use -M100%.  The default similarity index is 50%."),
					new GitCommandOption("--full-index", "--full-index", @"Instead of the first handful of characters, show the full pre- and post-image blob object names on the ""index"" line when generating patch format output."),
					new GitCommandOption("--function-context", "--function-context", @"Show whole function as context lines for each change. The function names are determined in the same way as git diff works out patch hunk headers (see Defining a custom hunk-header in gitattributes)."),
					new GitCommandOption("--histogram", "--histogram", @"Generate a diff using the ""histogram diff"" algorithm."),
					new GitCommandOption("--ignore-all-space", "--ignore-all-space", @"Ignore whitespace when comparing lines.  This ignores differences even if one line has whitespace where the other line has none."),
					new GitCommandOption("--ignore-blank-lines", "--ignore-blank-lines", @"Ignore changes whose lines are all blank."),
					new GitCommandOption("--ignore-cr-at-eol", "--ignore-cr-at-eol", @"Ignore carriage-return at the end of line when doing a comparison."),
					new GitCommandOption("--ignore-matching-lines", "--ignore-matching-lines=<regex>", @"Ignore changes whose all lines match <regex>.  This option may be specified more than once."),
					new GitCommandOption("--ignore-space-at-eol", "--ignore-space-at-eol", @"Ignore changes in whitespace at EOL."),
					new GitCommandOption("--ignore-space-change", "--ignore-space-change", @"Ignore changes in amount of whitespace.  This ignores whitespace at line end, and considers all other sequences of one or more whitespace characters to be equivalent."),
					new GitCommandOption("--ignore-submodules[", "--ignore-submodules[=<when>]", @"Ignore changes to submodules in the diff generation. <when> can be either ""none"", ""untracked"", ""dirty"" or ""all"", which is the default. Using ""none"" will consider the submodule modified when it either contains untracked or modified files or its HEAD differs from the commit recorded in the superproject and can be used to override any settings of the ignore option in git-config or gitmodules. When ""untracked"" is used submodules are not considered dirty when they only contain untracked content (but they are still scanned for modified content). Using ""dirty"" ignores all changes to the work tree of submodules, only changes to the commits stored in the superproject are shown (this was the behavior until 1.7.0). Using ""all"" hides all changes to submodules."),
					new GitCommandOption("--indent-heuristic", "--indent-heuristic", @"Enable the heuristic that shifts diff hunk boundaries to make patches easier to read. This is the default."),
					new GitCommandOption("--inter-hunk-context", "--inter-hunk-context=<lines>", @"Show the context between diff hunks, up to the specified number of lines, thereby fusing hunks that are close to each other. Defaults to diff.interHunkContext or 0 if the config option is unset."),
					new GitCommandOption("--irreversible-delete", "--irreversible-delete", @"Omit the preimage for deletes, i.e. print only the header but not the diff between the preimage and /dev/null. The resulting patch is not meant to be applied with patch or git apply; this is solely for people who want to just concentrate on reviewing the text after the change. In addition, the output obviously lacks enough information to apply such a patch in reverse, even manually, hence the name of the option.  When used together with -B, omit also the preimage in the deletion part of a delete/create pair."),
					new GitCommandOption("--ita-invisible-in-index", "--ita-invisible-in-index", @"By default entries added by ""git add -N"" appear as an existing empty file in ""git diff"" and a new file in ""git diff --cached"". This option makes the entry appear as a new file in ""git diff"" and non-existent in ""git diff --cached"". This option could be reverted with --ita-visible-in-index. Both options are experimental and could be removed in future."),
					new GitCommandOption("--line-prefix", "--line-prefix=<prefix>", @"Prepend an additional prefix to every line of output."),
					new GitCommandOption("--merge-base", "--merge-base", @"Instead of comparing <tree-ish> directly, use the merge base between <tree-ish> and HEAD instead.  <tree-ish> must be a commit."),
					new GitCommandOption("--minimal", "--minimal", @"Spend extra time to make sure the smallest possible diff is produced."),
					new GitCommandOption("--name-only", "--name-only", @"Show only names of changed files. The file names are often encoded in UTF-8. For more information see the discussion about encoding in the git-log manual page."),
					new GitCommandOption("--name-status", "--name-status", @"Show only names and status of changed files. See the description of the --diff-filter option on what the status letters mean. Just like --name-only the file names are often encoded in UTF-8."),
					new GitCommandOption("--no-color", "--no-color", @"Turn off colored diff. It is the same as --color=never."),
					new GitCommandOption("--no-color-moved", "--no-color-moved", @"Turn off move detection. This can be used to override configuration settings. It is the same as --color-moved=no."),
					new GitCommandOption("--no-color-moved-ws", "--no-color-moved-ws", @"Do not ignore whitespace when performing move detection. This can be used to override configuration settings. It is the same as --color-moved-ws=no."),
					new GitCommandOption("--no-ext-diff", "--no-ext-diff", @"Disallow external diff drivers."),
					new GitCommandOption("--no-indent-heuristic", "--no-indent-heuristic", @"Disable the indent heuristic."),
					new GitCommandOption("--no-patch", "--no-patch", @"Suppress diff output. Useful for commands like git show that show the patch by default, or to cancel the effect of --patch."),
					new GitCommandOption("--no-prefix", "--no-prefix", @"Do not show any source or destination prefix."),
					new GitCommandOption("--no-relative", "--no-relative", @"When run from a subdirectory of the project, it can be told to exclude changes outside the directory and show pathnames relative to it with this option.  When you are not in a subdirectory (e.g. in a bare repository), you can name which subdirectory to make the output relative to by giving a <path> as an argument. --no-relative can be used to countermand both diff.relative config option and previous --relative."),
					new GitCommandOption("--no-renames", "--no-renames", @"Turn off rename detection, even when the configuration file gives the default to do so."),
					new GitCommandOption("--no-textconv", "--no-textconv", @"Allow (or disallow) external text conversion filters to be run when comparing binary files. See gitattributes for details. Because textconv filters are typically a one-way conversion, the resulting diff is suitable for human consumption, but cannot be applied. For this reason, textconv filters are enabled by default only for git-diff and git-log, but not for git-format-patch or diff plumbing commands."),
					new GitCommandOption("--numstat", "--numstat", @"Similar to --stat, but shows number of added and deleted lines in decimal notation and pathname without abbreviation, to make it more machine friendly.  For binary files, outputs two - instead of saying 0 0."),
					new GitCommandOption("--output", "--output=<file>", @"Output to a specific file instead of stdout."),
					new GitCommandOption("--output-indicator-context", "--output-indicator-context=<char>", @"Specify the character used to indicate new, old or context lines in the generated patch. Normally they are +, - and ' ' respectively."),
					new GitCommandOption("--output-indicator-new", "--output-indicator-new=<char>", @"Specify the character used to indicate new, old or context lines in the generated patch. Normally they are +, - and ' ' respectively."),
					new GitCommandOption("--output-indicator-old", "--output-indicator-old=<char>", @"Specify the character used to indicate new, old or context lines in the generated patch. Normally they are +, - and ' ' respectively."),
					new GitCommandOption("--patch", "--patch", @"Generate patch (see section on generating patches)."),
					new GitCommandOption("--patch-with-raw", "--patch-with-raw", @"Synonym for -p --raw."),
					new GitCommandOption("--patch-with-stat", "--patch-with-stat", @"Synonym for -p --stat."),
					new GitCommandOption("--patience", "--patience", @"Generate a diff using the ""patience diff"" algorithm."),
					new GitCommandOption("--pickaxe-all", "--pickaxe-all", @"When -S or -G finds a change, show all the changes in that changeset, not just the files that contain the change in <string>."),
					new GitCommandOption("--pickaxe-regex", "--pickaxe-regex", @"Treat the <string> given to -S as an extended POSIX regular expression to match."),
					new GitCommandOption("--quiet", "--quiet", @"Disable all output of the program. Implies --exit-code."),
					new GitCommandOption("--raw", "--raw", @"Generate the diff in raw format. This is the default."),
					new GitCommandOption("--relative[", "--relative[=<path>]", @"When run from a subdirectory of the project, it can be told to exclude changes outside the directory and show pathnames relative to it with this option.  When you are not in a subdirectory (e.g. in a bare repository), you can name which subdirectory to make the output relative to by giving a <path> as an argument. --no-relative can be used to countermand both diff.relative config option and previous --relative."),
					new GitCommandOption("--rotate-to", "--rotate-to=<file>", @"Discard the files before the named <file> from the output (i.e. skip to), or move them to the end of the output (i.e. rotate to).  These were invented primarily for use of the git difftool command, and may not be very useful otherwise."),
					new GitCommandOption("--shortstat", "--shortstat", @"Output only the last line of the --stat format containing total number of modified files, as well as number of added and deleted lines."),
					new GitCommandOption("--skip-to", "--skip-to=<file>", @"Discard the files before the named <file> from the output (i.e. skip to), or move them to the end of the output (i.e. rotate to).  These were invented primarily for use of the git difftool command, and may not be very useful otherwise."),
					new GitCommandOption("--src-prefix", "--src-prefix=<prefix>", @"Show the given source prefix instead of ""a/""."),
					new GitCommandOption("--stat[", "--stat[=<width>[,<name-width>[,<count>]]]", @"Generate a diffstat. By default, as much space as necessary will be used for the filename part, and the rest for the graph part. Maximum width defaults to terminal width, or 80 columns if not connected to a terminal, and can be overridden by <width>. The width of the filename part can be limited by giving another width <name-width> after a comma. The width of the graph part can be limited by using --stat-graph-width=<width> (affects all commands generating a stat graph) or by setting diff.statGraphWidth=<width> (does not affect git format-patch). By giving a third parameter <count>, you can limit the output to the first <count> lines, followed by ... if there are more.  These parameters can also be set individually with --stat-width=<width>, --stat-name-width=<name-width> and --stat-count=<count>."),
					new GitCommandOption("--submodule[", "--submodule[=<format>]", @"Specify how differences in submodules are shown.  When specifying --submodule=short the short format is used.  This format just shows the names of the commits at the beginning and end of the range. When --submodule or --submodule=log is specified, the log format is used.  This format lists the commits in the range like git-submodule summary does.  When --submodule=diff is specified, the diff format is used.  This format shows an inline diff of the changes in the submodule contents between the commit range.  Defaults to diff.submodule or the short format if the config option is unset."),
					new GitCommandOption("--summary", "--summary", @"Output a condensed summary of extended header information such as creations, renames and mode changes."),
					new GitCommandOption("--text", "--text", @"Treat all files as text."),
					new GitCommandOption("--textconv", "--textconv", @"Allow (or disallow) external text conversion filters to be run when comparing binary files. See gitattributes for details. Because textconv filters are typically a one-way conversion, the resulting diff is suitable for human consumption, but cannot be applied. For this reason, textconv filters are enabled by default only for git-diff and git-log, but not for git-format-patch or diff plumbing commands."),
					new GitCommandOption("--unified", "--unified=<n>", @"Generate diffs with <n> lines of context instead of the usual three. Implies --patch."),
					new GitCommandOption("--word-diff-regex", "--word-diff-regex=<regex>", @"Use <regex> to decide what a word is, instead of considering runs of non-whitespace to be a word.  Also implies --word-diff unless it was already enabled.  Every non-overlapping match of the <regex> is considered a word.  Anything between these matches is considered whitespace and ignored(!) for the purposes of finding differences.  You may want to append |[^[:space:]] to your regular expression to make sure that it matches all non-whitespace characters. A match that contains a newline is silently truncated(!) at the newline.   For example, --word-diff-regex=. will treat each character as a word and, correspondingly, show differences character by character.   The regex can also be set via a diff driver or configuration option, see gitattributes or git-config.  Giving it explicitly overrides any diff driver or configuration setting.  Diff drivers override configuration settings."),
					new GitCommandOption("--word-diff[", "--word-diff[=<mode>]", @"Show a word diff, using the <mode> to delimit changed words. By default, words are delimited by whitespace; see --word-diff-regex below.  The <mode> defaults to plain, and must be one of:     color  Highlight changed words using only colors.  Implies --color.  plain  Show words as [-removed-] and {+added+}.  Makes no attempts to escape the delimiters if they appear in the input, so the output may be ambiguous.  porcelain  Use a special line-based format intended for script consumption.  Added/removed/unchanged runs are printed in the usual unified diff format, starting with a +/-/` ` character at the beginning of the line and extending to the end of the line.  Newlines in the input are represented by a tilde ~ on a line of its own.  none  Disable word diff again.       Note that despite the name of the first mode, color is used to highlight the changed parts in all modes if enabled."),
					new GitCommandOption("--ws-error-highlight", "--ws-error-highlight=<kind>", @"Highlight whitespace errors in the context, old or new lines of the diff.  Multiple values are separated by comma, none resets previous values, default reset the list to new and all is a shorthand for old,new,context.  When this option is not given, and the configuration variable diff.wsErrorHighlight is not set, only whitespace errors in new lines are highlighted. The whitespace errors are colored with color.diff.whitespace."),
					new GitCommandOption("-a", "-a", @"Treat all files as text."),
					new GitCommandOption("-b", "-b", @"Ignore changes in amount of whitespace.  This ignores whitespace at line end, and considers all other sequences of one or more whitespace characters to be equivalent."),
					new GitCommandOption("-B[<n>][/<m>]", "-B[<n>][/<m>]", @"Break complete rewrite changes into pairs of delete and create. This serves two purposes:  It affects the way a change that amounts to a total rewrite of a file not as a series of deletion and insertion mixed together with a very few lines that happen to match textually as the context, but as a single deletion of everything old followed by a single insertion of everything new, and the number m controls this aspect of the -B option (defaults to 60%). -B/70% specifies that less than 30% of the original should remain in the result for Git to consider it a total rewrite (i.e. otherwise the resulting patch will be a series of deletion and insertion mixed together with context lines).   When used with -M, a totally-rewritten file is also considered as the source of a rename (usually -M only considers a file that disappeared as the source of a rename), and the number n controls this aspect of the -B option (defaults to 50%). -B20% specifies that a change with addition and deletion compared to 20% or more of the file’s size are eligible for being picked up as a possible source of a rename to another file."),
					new GitCommandOption("-C[<n>]", "-C[<n>]", @"Detect copies as well as renames.  See also --find-copies-harder. If n is specified, it has the same meaning as for -M<n>."),
					new GitCommandOption("-D", "-D", @"Omit the preimage for deletes, i.e. print only the header but not the diff between the preimage and /dev/null. The resulting patch is not meant to be applied with patch or git apply; this is solely for people who want to just concentrate on reviewing the text after the change. In addition, the output obviously lacks enough information to apply such a patch in reverse, even manually, hence the name of the option.  When used together with -B, omit also the preimage in the deletion part of a delete/create pair."),
					new GitCommandOption("-G<regex>", "-G<regex>", @"Look for differences whose patch text contains added/removed lines that match <regex>.  To illustrate the difference between -S<regex> --pickaxe-regex and -G<regex>, consider a commit with the following diff in the same file:    +    return frotz(nitfol, two->ptr, 1, 0); ... -    hit = frotz(nitfol, mf2.ptr, 1, 0);    While git log -G""frotz\(nitfol"" will show this commit, git log -S""frotz\(nitfol"" --pickaxe-regex will not (because the number of occurrences of that string did not change).   Unless --text is supplied patches of binary files without a textconv filter will be ignored.   See the pickaxe entry in gitdiffcore for more information."),
					new GitCommandOption("-I<regex>", "-I<regex>", @"Ignore changes whose all lines match <regex>.  This option may be specified more than once."),
					new GitCommandOption("-l<num>", "-l<num>", @"The -M and -C options involve some preliminary steps that can detect subsets of renames/copies cheaply, followed by an exhaustive fallback portion that compares all remaining unpaired destinations to all relevant sources.  (For renames, only remaining unpaired sources are relevant; for copies, all original sources are relevant.)  For N sources and destinations, this exhaustive check is O(N^2).  This option prevents the exhaustive portion of rename/copy detection from running if the number of source/destination files involved exceeds the specified number.  Defaults to diff.renameLimit. Note that a value of 0 is treated as unlimited."),
					new GitCommandOption("-m", "-m", @"By default, files recorded in the index but not checked out are reported as deleted.  This flag makes git diff-index say that all non-checked-out files are up to date."),
					new GitCommandOption("-M[<n>]", "-M[<n>]", @"Detect renames. If n is specified, it is a threshold on the similarity index (i.e. amount of addition/deletions compared to the file’s size). For example, -M90% means Git should consider a delete/add pair to be a rename if more than 90% of the file hasn’t changed.  Without a % sign, the number is to be read as a fraction, with a decimal point before it.  I.e., -M5 becomes 0.5, and is thus the same as -M50%.  Similarly, -M05 is the same as -M5%.  To limit detection to exact renames, use -M100%.  The default similarity index is 50%."),
					new GitCommandOption("-O<orderfile>", "-O<orderfile>", @"Control the order in which files appear in the output. This overrides the diff.orderFile configuration variable (see git-config).  To cancel diff.orderFile, use -O/dev/null.  The output order is determined by the order of glob patterns in <orderfile>. All files with pathnames that match the first pattern are output first, all files with pathnames that match the second pattern (but not the first) are output next, and so on. All files with pathnames that do not match any pattern are output last, as if there was an implicit match-all pattern at the end of the file. If multiple pathnames have the same rank (they match the same pattern but no earlier patterns), their output order relative to each other is the normal order.   <orderfile> is parsed as follows:       Blank lines are ignored, so they can be used as separators for readability.   Lines starting with a hash (""#"") are ignored, so they can be used for comments.  Add a backslash (""\"") to the beginning of the pattern if it starts with a hash.   Each other line contains a single pattern.       Patterns have the same syntax and semantics as patterns used for fnmatch without the FNM_PATHNAME flag, except a pathname also matches a pattern if removing any number of the final pathname components matches the pattern.  For example, the pattern ""foo*bar"" matches ""fooasdfbar"" and ""foo/bar/baz/asdf"" but not ""foobarx""."),
					new GitCommandOption("-p", "-p", @"Generate patch (see section on generating patches)."),
					new GitCommandOption("-R", "-R", @"Swap two inputs; that is, show differences from index or on-disk file to tree contents."),
					new GitCommandOption("-s", "-s", @"Suppress diff output. Useful for commands like git show that show the patch by default, or to cancel the effect of --patch."),
					new GitCommandOption("-S<string>", "-S<string>", @"Look for differences that change the number of occurrences of the specified string (i.e. addition/deletion) in a file. Intended for the scripter’s use.  It is useful when you’re looking for an exact block of code (like a struct), and want to know the history of that block since it first came into being: use the feature iteratively to feed the interesting block in the preimage back into -S, and keep going until you get the very first version of the block.   Binary files are searched as well."),
					new GitCommandOption("-u", "-u", @"Generate patch (see section on generating patches)."),
					new GitCommandOption("-U<n>", "-U<n>", @"Generate diffs with <n> lines of context instead of the usual three. Implies --patch."),
					new GitCommandOption("-W", "-W", @"Show whole function as context lines for each change. The function names are determined in the same way as git diff works out patch hunk headers (see Defining a custom hunk-header in gitattributes)."),
					new GitCommandOption("-w", "-w", @"Ignore whitespace when comparing lines.  This ignores differences even if one line has whitespace where the other line has none."),
					new GitCommandOption("-X[<param1,param2,…​>]", "-X[<param1,param2,…​>]", @"Output the distribution of relative amount of changes for each sub-directory. The behavior of --dirstat can be customized by passing it a comma separated list of parameters. The defaults are controlled by the diff.dirstat configuration variable (see git-config). The following parameters are available:     changes  Compute the dirstat numbers by counting the lines that have been removed from the source, or added to the destination. This ignores the amount of pure code movements within a file.  In other words, rearranging lines in a file is not counted as much as other changes. This is the default behavior when no parameter is given.  lines  Compute the dirstat numbers by doing the regular line-based diff analysis, and summing the removed/added line counts. (For binary files, count 64-byte chunks instead, since binary files have no natural concept of lines). This is a more expensive --dirstat behavior than the changes behavior, but it does count rearranged lines within a file as much as other changes. The resulting output is consistent with what you get from the other --*stat options.  files  Compute the dirstat numbers by counting the number of files changed. Each changed file counts equally in the dirstat analysis. This is the computationally cheapest --dirstat behavior, since it does not have to look at the file contents at all.  cumulative  Count changes in a child directory for the parent directory as well. Note that when using cumulative, the sum of the percentages reported may exceed 100%. The default (non-cumulative) behavior can be specified with the noncumulative parameter.  <limit>  An integer parameter specifies a cut-off percent (3% by default). Directories contributing less than this percentage of the changes are not shown in the output.       Example: The following will count changed files, while ignoring directories with less than 10% of the total amount of changed files, and accumulating child directory counts in the parent directories: --dirstat=files,10,cumulative."),
					new GitCommandOption("-z", "-z", @"When --raw, --numstat, --name-only or --name-status has been given, do not munge pathnames and use NULs as output field terminators.  Without this option, pathnames with ""unusual"" characters are quoted as explained for the configuration variable core.quotePath (see git-config)."),
					new GitCommandOption("allow-indentation-change", "allow-indentation-change", @"Initially ignore any whitespace in the move detection, then group the moved code blocks only into a block if the change in whitespace is the same per line. This is incompatible with the other modes."),
					new GitCommandOption("blocks", "blocks", @"Blocks of moved text of at least 20 alphanumeric characters are detected greedily. The detected blocks are painted using either the color.diff.{old,new}Moved color. Adjacent blocks cannot be told apart."),
					new GitCommandOption("changes", "changes", @"Compute the dirstat numbers by counting the lines that have been removed from the source, or added to the destination. This ignores the amount of pure code movements within a file.  In other words, rearranging lines in a file is not counted as much as other changes. This is the default behavior when no parameter is given."),
					new GitCommandOption("color", "color", @"Highlight changed words using only colors.  Implies --color."),
					new GitCommandOption("cumulative", "cumulative", @"Count changes in a child directory for the parent directory as well. Note that when using cumulative, the sum of the percentages reported may exceed 100%. The default (non-cumulative) behavior can be specified with the noncumulative parameter."),
					new GitCommandOption("default", "default", @"Is a synonym for zebra. This may change to a more sensible mode in the future."),
					new GitCommandOption("default,", "default, myers", @"The basic greedy diff algorithm. Currently, this is the default."),
					new GitCommandOption("dimmed-zebra", "dimmed-zebra", @"Similar to zebra, but additional dimming of uninteresting parts of moved code is performed. The bordering lines of two adjacent blocks are considered interesting, the rest is uninteresting. dimmed_zebra is a deprecated synonym."),
					new GitCommandOption("files", "files", @"Compute the dirstat numbers by counting the number of files changed. Each changed file counts equally in the dirstat analysis. This is the computationally cheapest --dirstat behavior, since it does not have to look at the file contents at all."),
					new GitCommandOption("histogram", "histogram", @"This algorithm extends the patience algorithm to ""support low-occurrence common elements""."),
					new GitCommandOption("ignore-all-space", "ignore-all-space", @"Ignore whitespace when comparing lines. This ignores differences even if one line has whitespace where the other line has none."),
					new GitCommandOption("ignore-space-at-eol", "ignore-space-at-eol", @"Ignore changes in whitespace at EOL."),
					new GitCommandOption("ignore-space-change", "ignore-space-change", @"Ignore changes in amount of whitespace.  This ignores whitespace at line end, and considers all other sequences of one or more whitespace characters to be equivalent."),
					new GitCommandOption("lines", "lines", @"Compute the dirstat numbers by doing the regular line-based diff analysis, and summing the removed/added line counts. (For binary files, count 64-byte chunks instead, since binary files have no natural concept of lines). This is a more expensive --dirstat behavior than the changes behavior, but it does count rearranged lines within a file as much as other changes. The resulting output is consistent with what you get from the other --*stat options."),
					new GitCommandOption("minimal", "minimal", @"Spend extra time to make sure the smallest possible diff is produced."),
					new GitCommandOption("no", "no", @"Moved lines are not highlighted."),
					new GitCommandOption("no", "no", @"Do not ignore whitespace when performing move detection."),
					new GitCommandOption("none", "none", @"Disable word diff again."),
					new GitCommandOption("patience", "patience", @"Use ""patience diff"" algorithm when generating patches."),
					new GitCommandOption("plain", "plain", @"Any line that is added in one location and was removed in another location will be colored with color.diff.newMoved. Similarly color.diff.oldMoved will be used for removed lines that are added somewhere else in the diff. This mode picks up any moved line, but it is not very useful in a review to determine if a block of code was moved without permutation."),
					new GitCommandOption("plain", "plain", @"Show words as [-removed-] and {+added+}.  Makes no attempts to escape the delimiters if they appear in the input, so the output may be ambiguous."),
					new GitCommandOption("porcelain", "porcelain", @"Use a special line-based format intended for script consumption.  Added/removed/unchanged runs are printed in the usual unified diff format, starting with a +/-/` ` character at the beginning of the line and extending to the end of the line.  Newlines in the input are represented by a tilde ~ on a line of its own."),
					new GitCommandOption("zebra", "zebra", @"Blocks of moved text are detected as in blocks mode. The blocks are painted using either the color.diff.{old,new}Moved color or color.diff.{old,new}MovedAlternative. The change between the two colors indicates that a new block was detected."),
				}, 
	"diff-tree" => new GitCommandOption[] {
					new GitCommandOption("<limit>", "<limit>", @"An integer parameter specifies a cut-off percent (3% by default). Directories contributing less than this percentage of the changes are not shown in the output."),
					new GitCommandOption("<path>…​", "<path>…​", @"If provided, the results are limited to a subset of files matching one of the provided pathspecs."),
					new GitCommandOption("<tree-ish>", "<tree-ish>", @"The id of a tree object."),
					new GitCommandOption("--[no-]rename-empty", "--[no-]rename-empty", @"Whether to use empty blobs as rename source."),
					new GitCommandOption("--[no-]standard-notes", "--[no-]standard-notes", @"These options are deprecated. Use the above --notes/--no-notes options instead."),
					new GitCommandOption("--abbrev-commit", "--abbrev-commit", @"Instead of showing the full 40-byte hexadecimal commit object name, show a prefix that names the object uniquely. ""--abbrev=<n>"" (which also modifies diff output, if it is displayed) option can be used to specify the minimum length of the prefix.  This should make ""--pretty=oneline"" a whole lot more readable for people using 80-column terminals."),
					new GitCommandOption("--abbrev[", "--abbrev[=<n>]", @"Instead of showing the full 40-byte hexadecimal object name in diff-raw format output and diff-tree header lines, show the shortest prefix that is at least <n> hexdigits long that uniquely refers the object. In diff-patch output format, --full-index takes higher precedence, i.e. if --full-index is specified, full blob names will be shown regardless of --abbrev. Non default number of digits can be specified with --abbrev=<n>."),
					new GitCommandOption("--always", "--always", @"Show the commit itself and the commit log message even if the diff itself is empty."),
					new GitCommandOption("--anchored", "--anchored=<text>", @"Generate a diff using the ""anchored diff"" algorithm.  This option may be specified more than once.   If a line exists in both the source and destination, exists only once, and starts with this text, this algorithm attempts to prevent it from appearing as a deletion or addition in the output. It uses the ""patience diff"" algorithm internally."),
					new GitCommandOption("--binary", "--binary", @"In addition to --full-index, output a binary diff that can be applied with git-apply. Implies --patch."),
					new GitCommandOption("--break-rewrites[", "--break-rewrites[=[<n>][/<m>]]", @"Break complete rewrite changes into pairs of delete and create. This serves two purposes:  It affects the way a change that amounts to a total rewrite of a file not as a series of deletion and insertion mixed together with a very few lines that happen to match textually as the context, but as a single deletion of everything old followed by a single insertion of everything new, and the number m controls this aspect of the -B option (defaults to 60%). -B/70% specifies that less than 30% of the original should remain in the result for Git to consider it a total rewrite (i.e. otherwise the resulting patch will be a series of deletion and insertion mixed together with context lines).   When used with -M, a totally-rewritten file is also considered as the source of a rename (usually -M only considers a file that disappeared as the source of a rename), and the number n controls this aspect of the -B option (defaults to 50%). -B20% specifies that a change with addition and deletion compared to 20% or more of the file’s size are eligible for being picked up as a possible source of a rename to another file."),
					new GitCommandOption("--cc", "--cc", @"This flag changes the way a merge commit patch is displayed, in a similar way to the -c option. It implies the -c and -p options and further compresses the patch output by omitting uninteresting hunks whose the contents in the parents have only two variants and the merge result picks one of them without modification.  When all hunks are uninteresting, the commit itself and the commit log message is not shown, just like in any other ""empty diff"" case."),
					new GitCommandOption("--check", "--check", @"Warn if changes introduce conflict markers or whitespace errors. What are considered whitespace errors is controlled by core.whitespace configuration.  By default, trailing whitespaces (including lines that consist solely of whitespaces) and a space character that is immediately followed by a tab character inside the initial indent of the line are considered whitespace errors. Exits with non-zero status if problems are found. Not compatible with --exit-code."),
					new GitCommandOption("--color-moved-ws", "--color-moved-ws=<modes>", @"This configures how whitespace is ignored when performing the move detection for --color-moved. These modes can be given as a comma separated list:     no  Do not ignore whitespace when performing move detection.  ignore-space-at-eol  Ignore changes in whitespace at EOL.  ignore-space-change  Ignore changes in amount of whitespace.  This ignores whitespace at line end, and considers all other sequences of one or more whitespace characters to be equivalent.  ignore-all-space  Ignore whitespace when comparing lines. This ignores differences even if one line has whitespace where the other line has none.  allow-indentation-change  Initially ignore any whitespace in the move detection, then group the moved code blocks only into a block if the change in whitespace is the same per line. This is incompatible with the other modes."),
					new GitCommandOption("--color-moved[", "--color-moved[=<mode>]", @"Moved lines of code are colored differently. The <mode> defaults to no if the option is not given and to zebra if the option with no mode is given. The mode must be one of:     no  Moved lines are not highlighted.  default  Is a synonym for zebra. This may change to a more sensible mode in the future.  plain  Any line that is added in one location and was removed in another location will be colored with color.diff.newMoved. Similarly color.diff.oldMoved will be used for removed lines that are added somewhere else in the diff. This mode picks up any moved line, but it is not very useful in a review to determine if a block of code was moved without permutation.  blocks  Blocks of moved text of at least 20 alphanumeric characters are detected greedily. The detected blocks are painted using either the color.diff.{old,new}Moved color. Adjacent blocks cannot be told apart.  zebra  Blocks of moved text are detected as in blocks mode. The blocks are painted using either the color.diff.{old,new}Moved color or color.diff.{old,new}MovedAlternative. The change between the two colors indicates that a new block was detected.  dimmed-zebra  Similar to zebra, but additional dimming of uninteresting parts of moved code is performed. The bordering lines of two adjacent blocks are considered interesting, the rest is uninteresting. dimmed_zebra is a deprecated synonym."),
					new GitCommandOption("--color-words[", "--color-words[=<regex>]", @"Equivalent to --word-diff=color plus (if a regex was specified) --word-diff-regex=<regex>."),
					new GitCommandOption("--color[", "--color[=<when>]", @"Show colored diff. --color (i.e. without =<when>) is the same as --color=always. <when> can be one of always, never, or auto."),
					new GitCommandOption("--combined-all-paths", "--combined-all-paths", @"This flag causes combined diffs (used for merge commits) to list the name of the file from all parents.  It thus only has effect when -c or --cc are specified, and is likely only useful if filename changes are detected (i.e. when either rename or copy detection have been requested)."),
					new GitCommandOption("--compact-summary", "--compact-summary", @"Output a condensed summary of extended header information such as file creations or deletions (""new"" or ""gone"", optionally ""+l"" if it’s a symlink) and mode changes (""+x"" or ""-x"" for adding or removing executable bit respectively) in diffstat. The information is put between the filename part and the graph part. Implies --stat."),
					new GitCommandOption("--cumulative", "--cumulative", @"Synonym for --dirstat=cumulative"),
					new GitCommandOption("--diff-algorithm", "--diff-algorithm={patience|minimal|histogram|myers}", @"Choose a diff algorithm. The variants are as follows:     default, myers  The basic greedy diff algorithm. Currently, this is the default.  minimal  Spend extra time to make sure the smallest possible diff is produced.  patience  Use ""patience diff"" algorithm when generating patches.  histogram  This algorithm extends the patience algorithm to ""support low-occurrence common elements"".       For instance, if you configured the diff.algorithm variable to a non-default value and want to use the default one, then you have to use --diff-algorithm=default option."),
					new GitCommandOption("--diff-filter", "--diff-filter=[(A|C|D|M|R|T|U|X|B)…​[*]]", @"Select only files that are Added (A), Copied (C), Deleted (D), Modified (M), Renamed (R), have their type (i.e. regular file, symlink, submodule, …​) changed (T), are Unmerged (U), are Unknown (X), or have had their pairing Broken (B). Any combination of the filter characters (including none) can be used. When * (All-or-none) is added to the combination, all paths are selected if there is any file that matches other criteria in the comparison; if there is no file that matches other criteria, nothing is selected.  Also, these upper-case letters can be downcased to exclude.  E.g. --diff-filter=ad excludes added and deleted paths.   Note that not all diffs can feature all types. For instance, copied and renamed entries cannot appear if detection for those types is disabled."),
					new GitCommandOption("--dirstat-by-file[", "--dirstat-by-file[=<param1,param2>…​]", @"Synonym for --dirstat=files,param1,param2…​"),
					new GitCommandOption("--dirstat[", "--dirstat[=<param1,param2,…​>]", @"Output the distribution of relative amount of changes for each sub-directory. The behavior of --dirstat can be customized by passing it a comma separated list of parameters. The defaults are controlled by the diff.dirstat configuration variable (see git-config). The following parameters are available:     changes  Compute the dirstat numbers by counting the lines that have been removed from the source, or added to the destination. This ignores the amount of pure code movements within a file.  In other words, rearranging lines in a file is not counted as much as other changes. This is the default behavior when no parameter is given.  lines  Compute the dirstat numbers by doing the regular line-based diff analysis, and summing the removed/added line counts. (For binary files, count 64-byte chunks instead, since binary files have no natural concept of lines). This is a more expensive --dirstat behavior than the changes behavior, but it does count rearranged lines within a file as much as other changes. The resulting output is consistent with what you get from the other --*stat options.  files  Compute the dirstat numbers by counting the number of files changed. Each changed file counts equally in the dirstat analysis. This is the computationally cheapest --dirstat behavior, since it does not have to look at the file contents at all.  cumulative  Count changes in a child directory for the parent directory as well. Note that when using cumulative, the sum of the percentages reported may exceed 100%. The default (non-cumulative) behavior can be specified with the noncumulative parameter.  <limit>  An integer parameter specifies a cut-off percent (3% by default). Directories contributing less than this percentage of the changes are not shown in the output.       Example: The following will count changed files, while ignoring directories with less than 10% of the total amount of changed files, and accumulating child directory counts in the parent directories: --dirstat=files,10,cumulative."),
					new GitCommandOption("--dst-prefix", "--dst-prefix=<prefix>", @"Show the given destination prefix instead of ""b/""."),
					new GitCommandOption("--encoding", "--encoding=<encoding>", @"Commit objects record the character encoding used for the log message in their encoding header; this option can be used to tell the command to re-code the commit log message in the encoding preferred by the user.  For non plumbing commands this defaults to UTF-8. Note that if an object claims to be encoded in X and we are outputting in X, we will output the object verbatim; this means that invalid sequences in the original commit may be copied to the output. Likewise, if iconv fails to convert the commit, we will quietly output the original object verbatim."),
					new GitCommandOption("--exit-code", "--exit-code", @"Make the program exit with codes similar to diff. That is, it exits with 1 if there were differences and 0 means no differences."),
					new GitCommandOption("--expand-tabs", "--expand-tabs", @"Perform a tab expansion (replace each tab with enough spaces to fill to the next display column that is multiple of <n>) in the log message before showing it in the output. --expand-tabs is a short-hand for --expand-tabs=8, and --no-expand-tabs is a short-hand for --expand-tabs=0, which disables tab expansion.  By default, tabs are expanded in pretty formats that indent the log message by 4 spaces (i.e.  medium, which is the default, full, and fuller)."),
					new GitCommandOption("--expand-tabs", "--expand-tabs=<n>", @"Perform a tab expansion (replace each tab with enough spaces to fill to the next display column that is multiple of <n>) in the log message before showing it in the output. --expand-tabs is a short-hand for --expand-tabs=8, and --no-expand-tabs is a short-hand for --expand-tabs=0, which disables tab expansion.  By default, tabs are expanded in pretty formats that indent the log message by 4 spaces (i.e.  medium, which is the default, full, and fuller)."),
					new GitCommandOption("--ext-diff", "--ext-diff", @"Allow an external diff helper to be executed. If you set an external diff driver with gitattributes, you need to use this option with git-log and friends."),
					new GitCommandOption("--find-copies-harder", "--find-copies-harder", @"For performance reasons, by default, -C option finds copies only if the original file of the copy was modified in the same changeset.  This flag makes the command inspect unmodified files as candidates for the source of copy.  This is a very expensive operation for large projects, so use it with caution.  Giving more than one -C option has the same effect."),
					new GitCommandOption("--find-copies[", "--find-copies[=<n>]", @"Detect copies as well as renames.  See also --find-copies-harder. If n is specified, it has the same meaning as for -M<n>."),
					new GitCommandOption("--find-object", "--find-object=<object-id>", @"Look for differences that change the number of occurrences of the specified object. Similar to -S, just the argument is different in that it doesn’t search for a specific string but for a specific object id.  The object can be a blob or a submodule commit. It implies the -t option in git-log to also find trees."),
					new GitCommandOption("--find-renames[", "--find-renames[=<n>]", @"Detect renames. If n is specified, it is a threshold on the similarity index (i.e. amount of addition/deletions compared to the file’s size). For example, -M90% means Git should consider a delete/add pair to be a rename if more than 90% of the file hasn’t changed.  Without a % sign, the number is to be read as a fraction, with a decimal point before it.  I.e., -M5 becomes 0.5, and is thus the same as -M50%.  Similarly, -M05 is the same as -M5%.  To limit detection to exact renames, use -M100%.  The default similarity index is 50%."),
					new GitCommandOption("--format", "--format=<format>", @"Pretty-print the contents of the commit logs in a given format, where <format> can be one of oneline, short, medium, full, fuller, reference, email, raw, format:<string> and tformat:<string>.  When <format> is none of the above, and has %placeholder in it, it acts as if --pretty=tformat:<format> were given.  See the ""PRETTY FORMATS"" section for some additional details for each format.  When =<format> part is omitted, it defaults to medium.   Note: you can specify the default pretty format in the repository configuration (see git-config)."),
					new GitCommandOption("--full-index", "--full-index", @"Instead of the first handful of characters, show the full pre- and post-image blob object names on the ""index"" line when generating patch format output."),
					new GitCommandOption("--function-context", "--function-context", @"Show whole function as context lines for each change. The function names are determined in the same way as git diff works out patch hunk headers (see Defining a custom hunk-header in gitattributes)."),
					new GitCommandOption("--histogram", "--histogram", @"Generate a diff using the ""histogram diff"" algorithm."),
					new GitCommandOption("--ignore-all-space", "--ignore-all-space", @"Ignore whitespace when comparing lines.  This ignores differences even if one line has whitespace where the other line has none."),
					new GitCommandOption("--ignore-blank-lines", "--ignore-blank-lines", @"Ignore changes whose lines are all blank."),
					new GitCommandOption("--ignore-cr-at-eol", "--ignore-cr-at-eol", @"Ignore carriage-return at the end of line when doing a comparison."),
					new GitCommandOption("--ignore-matching-lines", "--ignore-matching-lines=<regex>", @"Ignore changes whose all lines match <regex>.  This option may be specified more than once."),
					new GitCommandOption("--ignore-space-at-eol", "--ignore-space-at-eol", @"Ignore changes in whitespace at EOL."),
					new GitCommandOption("--ignore-space-change", "--ignore-space-change", @"Ignore changes in amount of whitespace.  This ignores whitespace at line end, and considers all other sequences of one or more whitespace characters to be equivalent."),
					new GitCommandOption("--ignore-submodules[", "--ignore-submodules[=<when>]", @"Ignore changes to submodules in the diff generation. <when> can be either ""none"", ""untracked"", ""dirty"" or ""all"", which is the default. Using ""none"" will consider the submodule modified when it either contains untracked or modified files or its HEAD differs from the commit recorded in the superproject and can be used to override any settings of the ignore option in git-config or gitmodules. When ""untracked"" is used submodules are not considered dirty when they only contain untracked content (but they are still scanned for modified content). Using ""dirty"" ignores all changes to the work tree of submodules, only changes to the commits stored in the superproject are shown (this was the behavior until 1.7.0). Using ""all"" hides all changes to submodules."),
					new GitCommandOption("--indent-heuristic", "--indent-heuristic", @"Enable the heuristic that shifts diff hunk boundaries to make patches easier to read. This is the default."),
					new GitCommandOption("--inter-hunk-context", "--inter-hunk-context=<lines>", @"Show the context between diff hunks, up to the specified number of lines, thereby fusing hunks that are close to each other. Defaults to diff.interHunkContext or 0 if the config option is unset."),
					new GitCommandOption("--irreversible-delete", "--irreversible-delete", @"Omit the preimage for deletes, i.e. print only the header but not the diff between the preimage and /dev/null. The resulting patch is not meant to be applied with patch or git apply; this is solely for people who want to just concentrate on reviewing the text after the change. In addition, the output obviously lacks enough information to apply such a patch in reverse, even manually, hence the name of the option.  When used together with -B, omit also the preimage in the deletion part of a delete/create pair."),
					new GitCommandOption("--ita-invisible-in-index", "--ita-invisible-in-index", @"By default entries added by ""git add -N"" appear as an existing empty file in ""git diff"" and a new file in ""git diff --cached"". This option makes the entry appear as a new file in ""git diff"" and non-existent in ""git diff --cached"". This option could be reverted with --ita-visible-in-index. Both options are experimental and could be removed in future."),
					new GitCommandOption("--line-prefix", "--line-prefix=<prefix>", @"Prepend an additional prefix to every line of output."),
					new GitCommandOption("--merge-base", "--merge-base", @"Instead of comparing the <tree-ish>s directly, use the merge base between the two <tree-ish>s as the ""before"" side.  There must be two <tree-ish>s given and they must both be commits."),
					new GitCommandOption("--minimal", "--minimal", @"Spend extra time to make sure the smallest possible diff is produced."),
					new GitCommandOption("--name-only", "--name-only", @"Show only names of changed files. The file names are often encoded in UTF-8. For more information see the discussion about encoding in the git-log manual page."),
					new GitCommandOption("--name-status", "--name-status", @"Show only names and status of changed files. See the description of the --diff-filter option on what the status letters mean. Just like --name-only the file names are often encoded in UTF-8."),
					new GitCommandOption("--no-abbrev-commit", "--no-abbrev-commit", @"Show the full 40-byte hexadecimal commit object name. This negates --abbrev-commit, either explicit or implied by other options such as ""--oneline"". It also overrides the log.abbrevCommit variable."),
					new GitCommandOption("--no-color", "--no-color", @"Turn off colored diff. It is the same as --color=never."),
					new GitCommandOption("--no-color-moved", "--no-color-moved", @"Turn off move detection. This can be used to override configuration settings. It is the same as --color-moved=no."),
					new GitCommandOption("--no-color-moved-ws", "--no-color-moved-ws", @"Do not ignore whitespace when performing move detection. This can be used to override configuration settings. It is the same as --color-moved-ws=no."),
					new GitCommandOption("--no-commit-id", "--no-commit-id", @"git diff-tree outputs a line with the commit ID when applicable.  This flag suppressed the commit ID output."),
					new GitCommandOption("--no-expand-tabs", "--no-expand-tabs", @"Perform a tab expansion (replace each tab with enough spaces to fill to the next display column that is multiple of <n>) in the log message before showing it in the output. --expand-tabs is a short-hand for --expand-tabs=8, and --no-expand-tabs is a short-hand for --expand-tabs=0, which disables tab expansion.  By default, tabs are expanded in pretty formats that indent the log message by 4 spaces (i.e.  medium, which is the default, full, and fuller)."),
					new GitCommandOption("--no-ext-diff", "--no-ext-diff", @"Disallow external diff drivers."),
					new GitCommandOption("--no-indent-heuristic", "--no-indent-heuristic", @"Disable the indent heuristic."),
					new GitCommandOption("--no-notes", "--no-notes", @"Do not show notes. This negates the above --notes option, by resetting the list of notes refs from which notes are shown. Options are parsed in the order given on the command line, so e.g. ""--notes --notes=foo --no-notes --notes=bar"" will only show notes from ""refs/notes/bar""."),
					new GitCommandOption("--no-patch", "--no-patch", @"Suppress diff output. Useful for commands like git show that show the patch by default, or to cancel the effect of --patch."),
					new GitCommandOption("--no-prefix", "--no-prefix", @"Do not show any source or destination prefix."),
					new GitCommandOption("--no-relative", "--no-relative", @"When run from a subdirectory of the project, it can be told to exclude changes outside the directory and show pathnames relative to it with this option.  When you are not in a subdirectory (e.g. in a bare repository), you can name which subdirectory to make the output relative to by giving a <path> as an argument. --no-relative can be used to countermand both diff.relative config option and previous --relative."),
					new GitCommandOption("--no-renames", "--no-renames", @"Turn off rename detection, even when the configuration file gives the default to do so."),
					new GitCommandOption("--no-textconv", "--no-textconv", @"Allow (or disallow) external text conversion filters to be run when comparing binary files. See gitattributes for details. Because textconv filters are typically a one-way conversion, the resulting diff is suitable for human consumption, but cannot be applied. For this reason, textconv filters are enabled by default only for git-diff and git-log, but not for git-format-patch or diff plumbing commands."),
					new GitCommandOption("--notes[", "--notes[=<ref>]", @"Show the notes (see git-notes) that annotate the commit, when showing the commit log message.  This is the default for git log, git show and git whatchanged commands when there is no --pretty, --format, or --oneline option given on the command line.  By default, the notes shown are from the notes refs listed in the core.notesRef and notes.displayRef variables (or corresponding environment overrides). See git-config for more details.   With an optional <ref> argument, use the ref to find the notes to display.  The ref can specify the full refname when it begins with refs/notes/; when it begins with notes/, refs/ and otherwise refs/notes/ is prefixed to form a full name of the ref.   Multiple --notes options can be combined to control which notes are being displayed. Examples: ""--notes=foo"" will show only notes from ""refs/notes/foo""; ""--notes=foo --notes"" will show both notes from ""refs/notes/foo"" and from the default notes ref(s)."),
					new GitCommandOption("--numstat", "--numstat", @"Similar to --stat, but shows number of added and deleted lines in decimal notation and pathname without abbreviation, to make it more machine friendly.  For binary files, outputs two - instead of saying 0 0."),
					new GitCommandOption("--oneline", "--oneline", @"This is a shorthand for ""--pretty=oneline --abbrev-commit"" used together."),
					new GitCommandOption("--output", "--output=<file>", @"Output to a specific file instead of stdout."),
					new GitCommandOption("--output-indicator-context", "--output-indicator-context=<char>", @"Specify the character used to indicate new, old or context lines in the generated patch. Normally they are +, - and ' ' respectively."),
					new GitCommandOption("--output-indicator-new", "--output-indicator-new=<char>", @"Specify the character used to indicate new, old or context lines in the generated patch. Normally they are +, - and ' ' respectively."),
					new GitCommandOption("--output-indicator-old", "--output-indicator-old=<char>", @"Specify the character used to indicate new, old or context lines in the generated patch. Normally they are +, - and ' ' respectively."),
					new GitCommandOption("--patch", "--patch", @"Generate patch (see section on generating patches)."),
					new GitCommandOption("--patch-with-raw", "--patch-with-raw", @"Synonym for -p --raw."),
					new GitCommandOption("--patch-with-stat", "--patch-with-stat", @"Synonym for -p --stat."),
					new GitCommandOption("--patience", "--patience", @"Generate a diff using the ""patience diff"" algorithm."),
					new GitCommandOption("--pickaxe-all", "--pickaxe-all", @"When -S or -G finds a change, show all the changes in that changeset, not just the files that contain the change in <string>."),
					new GitCommandOption("--pickaxe-regex", "--pickaxe-regex", @"Treat the <string> given to -S as an extended POSIX regular expression to match."),
					new GitCommandOption("--pretty[", "--pretty[=<format>]", @"Pretty-print the contents of the commit logs in a given format, where <format> can be one of oneline, short, medium, full, fuller, reference, email, raw, format:<string> and tformat:<string>.  When <format> is none of the above, and has %placeholder in it, it acts as if --pretty=tformat:<format> were given.  See the ""PRETTY FORMATS"" section for some additional details for each format.  When =<format> part is omitted, it defaults to medium.   Note: you can specify the default pretty format in the repository configuration (see git-config)."),
					new GitCommandOption("--quiet", "--quiet", @"Disable all output of the program. Implies --exit-code."),
					new GitCommandOption("--raw", "--raw", @"Generate the diff in raw format. This is the default."),
					new GitCommandOption("--relative[", "--relative[=<path>]", @"When run from a subdirectory of the project, it can be told to exclude changes outside the directory and show pathnames relative to it with this option.  When you are not in a subdirectory (e.g. in a bare repository), you can name which subdirectory to make the output relative to by giving a <path> as an argument. --no-relative can be used to countermand both diff.relative config option and previous --relative."),
					new GitCommandOption("--root", "--root", @"When --root is specified the initial commit will be shown as a big creation event. This is equivalent to a diff against the NULL tree."),
					new GitCommandOption("--rotate-to", "--rotate-to=<file>", @"Discard the files before the named <file> from the output (i.e. skip to), or move them to the end of the output (i.e. rotate to).  These were invented primarily for use of the git difftool command, and may not be very useful otherwise."),
					new GitCommandOption("--shortstat", "--shortstat", @"Output only the last line of the --stat format containing total number of modified files, as well as number of added and deleted lines."),
					new GitCommandOption("--show-notes[", "--show-notes[=<ref>]", @"These options are deprecated. Use the above --notes/--no-notes options instead."),
					new GitCommandOption("--show-signature", "--show-signature", @"Check the validity of a signed commit object by passing the signature to gpg --verify and show the output."),
					new GitCommandOption("--skip-to", "--skip-to=<file>", @"Discard the files before the named <file> from the output (i.e. skip to), or move them to the end of the output (i.e. rotate to).  These were invented primarily for use of the git difftool command, and may not be very useful otherwise."),
					new GitCommandOption("--src-prefix", "--src-prefix=<prefix>", @"Show the given source prefix instead of ""a/""."),
					new GitCommandOption("--stat[", "--stat[=<width>[,<name-width>[,<count>]]]", @"Generate a diffstat. By default, as much space as necessary will be used for the filename part, and the rest for the graph part. Maximum width defaults to terminal width, or 80 columns if not connected to a terminal, and can be overridden by <width>. The width of the filename part can be limited by giving another width <name-width> after a comma. The width of the graph part can be limited by using --stat-graph-width=<width> (affects all commands generating a stat graph) or by setting diff.statGraphWidth=<width> (does not affect git format-patch). By giving a third parameter <count>, you can limit the output to the first <count> lines, followed by ... if there are more.  These parameters can also be set individually with --stat-width=<width>, --stat-name-width=<name-width> and --stat-count=<count>."),
					new GitCommandOption("--stdin", "--stdin", @"When --stdin is specified, the command does not take <tree-ish> arguments from the command line.  Instead, it reads lines containing either two <tree>, one <commit>, or a list of <commit> from its standard input.  (Use a single space as separator.)  When two trees are given, it compares the first tree with the second. When a single commit is given, it compares the commit with its parents.  The remaining commits, when given, are used as if they are parents of the first commit.   When comparing two trees, the ID of both trees (separated by a space and terminated by a newline) is printed before the difference.  When comparing commits, the ID of the first (or only) commit, followed by a newline, is printed.   The following flags further affect the behavior when comparing commits (but not trees)."),
					new GitCommandOption("--submodule[", "--submodule[=<format>]", @"Specify how differences in submodules are shown.  When specifying --submodule=short the short format is used.  This format just shows the names of the commits at the beginning and end of the range. When --submodule or --submodule=log is specified, the log format is used.  This format lists the commits in the range like git-submodule summary does.  When --submodule=diff is specified, the diff format is used.  This format shows an inline diff of the changes in the submodule contents between the commit range.  Defaults to diff.submodule or the short format if the config option is unset."),
					new GitCommandOption("--summary", "--summary", @"Output a condensed summary of extended header information such as creations, renames and mode changes."),
					new GitCommandOption("--text", "--text", @"Treat all files as text."),
					new GitCommandOption("--textconv", "--textconv", @"Allow (or disallow) external text conversion filters to be run when comparing binary files. See gitattributes for details. Because textconv filters are typically a one-way conversion, the resulting diff is suitable for human consumption, but cannot be applied. For this reason, textconv filters are enabled by default only for git-diff and git-log, but not for git-format-patch or diff plumbing commands."),
					new GitCommandOption("--unified", "--unified=<n>", @"Generate diffs with <n> lines of context instead of the usual three. Implies --patch."),
					new GitCommandOption("--word-diff-regex", "--word-diff-regex=<regex>", @"Use <regex> to decide what a word is, instead of considering runs of non-whitespace to be a word.  Also implies --word-diff unless it was already enabled.  Every non-overlapping match of the <regex> is considered a word.  Anything between these matches is considered whitespace and ignored(!) for the purposes of finding differences.  You may want to append |[^[:space:]] to your regular expression to make sure that it matches all non-whitespace characters. A match that contains a newline is silently truncated(!) at the newline.   For example, --word-diff-regex=. will treat each character as a word and, correspondingly, show differences character by character.   The regex can also be set via a diff driver or configuration option, see gitattributes or git-config.  Giving it explicitly overrides any diff driver or configuration setting.  Diff drivers override configuration settings."),
					new GitCommandOption("--word-diff[", "--word-diff[=<mode>]", @"Show a word diff, using the <mode> to delimit changed words. By default, words are delimited by whitespace; see --word-diff-regex below.  The <mode> defaults to plain, and must be one of:     color  Highlight changed words using only colors.  Implies --color.  plain  Show words as [-removed-] and {+added+}.  Makes no attempts to escape the delimiters if they appear in the input, so the output may be ambiguous.  porcelain  Use a special line-based format intended for script consumption.  Added/removed/unchanged runs are printed in the usual unified diff format, starting with a +/-/` ` character at the beginning of the line and extending to the end of the line.  Newlines in the input are represented by a tilde ~ on a line of its own.  none  Disable word diff again.       Note that despite the name of the first mode, color is used to highlight the changed parts in all modes if enabled."),
					new GitCommandOption("--ws-error-highlight", "--ws-error-highlight=<kind>", @"Highlight whitespace errors in the context, old or new lines of the diff.  Multiple values are separated by comma, none resets previous values, default reset the list to new and all is a shorthand for old,new,context.  When this option is not given, and the configuration variable diff.wsErrorHighlight is not set, only whitespace errors in new lines are highlighted. The whitespace errors are colored with color.diff.whitespace."),
					new GitCommandOption("-a", "-a", @"Treat all files as text."),
					new GitCommandOption("-b", "-b", @"Ignore changes in amount of whitespace.  This ignores whitespace at line end, and considers all other sequences of one or more whitespace characters to be equivalent."),
					new GitCommandOption("-B[<n>][/<m>]", "-B[<n>][/<m>]", @"Break complete rewrite changes into pairs of delete and create. This serves two purposes:  It affects the way a change that amounts to a total rewrite of a file not as a series of deletion and insertion mixed together with a very few lines that happen to match textually as the context, but as a single deletion of everything old followed by a single insertion of everything new, and the number m controls this aspect of the -B option (defaults to 60%). -B/70% specifies that less than 30% of the original should remain in the result for Git to consider it a total rewrite (i.e. otherwise the resulting patch will be a series of deletion and insertion mixed together with context lines).   When used with -M, a totally-rewritten file is also considered as the source of a rename (usually -M only considers a file that disappeared as the source of a rename), and the number n controls this aspect of the -B option (defaults to 50%). -B20% specifies that a change with addition and deletion compared to 20% or more of the file’s size are eligible for being picked up as a possible source of a rename to another file."),
					new GitCommandOption("-c", "-c", @"This flag changes the way a merge commit is displayed (which means it is useful only when the command is given one <tree-ish>, or --stdin).  It shows the differences from each of the parents to the merge result simultaneously instead of showing pairwise diff between a parent and the result one at a time (which is what the -m option does). Furthermore, it lists only files which were modified from all parents."),
					new GitCommandOption("-C[<n>]", "-C[<n>]", @"Detect copies as well as renames.  See also --find-copies-harder. If n is specified, it has the same meaning as for -M<n>."),
					new GitCommandOption("-D", "-D", @"Omit the preimage for deletes, i.e. print only the header but not the diff between the preimage and /dev/null. The resulting patch is not meant to be applied with patch or git apply; this is solely for people who want to just concentrate on reviewing the text after the change. In addition, the output obviously lacks enough information to apply such a patch in reverse, even manually, hence the name of the option.  When used together with -B, omit also the preimage in the deletion part of a delete/create pair."),
					new GitCommandOption("-G<regex>", "-G<regex>", @"Look for differences whose patch text contains added/removed lines that match <regex>.  To illustrate the difference between -S<regex> --pickaxe-regex and -G<regex>, consider a commit with the following diff in the same file:    +    return frotz(nitfol, two->ptr, 1, 0); ... -    hit = frotz(nitfol, mf2.ptr, 1, 0);    While git log -G""frotz\(nitfol"" will show this commit, git log -S""frotz\(nitfol"" --pickaxe-regex will not (because the number of occurrences of that string did not change).   Unless --text is supplied patches of binary files without a textconv filter will be ignored.   See the pickaxe entry in gitdiffcore for more information."),
					new GitCommandOption("-I<regex>", "-I<regex>", @"Ignore changes whose all lines match <regex>.  This option may be specified more than once."),
					new GitCommandOption("-l<num>", "-l<num>", @"The -M and -C options involve some preliminary steps that can detect subsets of renames/copies cheaply, followed by an exhaustive fallback portion that compares all remaining unpaired destinations to all relevant sources.  (For renames, only remaining unpaired sources are relevant; for copies, all original sources are relevant.)  For N sources and destinations, this exhaustive check is O(N^2).  This option prevents the exhaustive portion of rename/copy detection from running if the number of source/destination files involved exceeds the specified number.  Defaults to diff.renameLimit. Note that a value of 0 is treated as unlimited."),
					new GitCommandOption("-m", "-m", @"By default, git diff-tree --stdin does not show differences for merge commits.  With this flag, it shows differences to that commit from all of its parents. See also -c."),
					new GitCommandOption("-M[<n>]", "-M[<n>]", @"Detect renames. If n is specified, it is a threshold on the similarity index (i.e. amount of addition/deletions compared to the file’s size). For example, -M90% means Git should consider a delete/add pair to be a rename if more than 90% of the file hasn’t changed.  Without a % sign, the number is to be read as a fraction, with a decimal point before it.  I.e., -M5 becomes 0.5, and is thus the same as -M50%.  Similarly, -M05 is the same as -M5%.  To limit detection to exact renames, use -M100%.  The default similarity index is 50%."),
					new GitCommandOption("-O<orderfile>", "-O<orderfile>", @"Control the order in which files appear in the output. This overrides the diff.orderFile configuration variable (see git-config).  To cancel diff.orderFile, use -O/dev/null.  The output order is determined by the order of glob patterns in <orderfile>. All files with pathnames that match the first pattern are output first, all files with pathnames that match the second pattern (but not the first) are output next, and so on. All files with pathnames that do not match any pattern are output last, as if there was an implicit match-all pattern at the end of the file. If multiple pathnames have the same rank (they match the same pattern but no earlier patterns), their output order relative to each other is the normal order.   <orderfile> is parsed as follows:       Blank lines are ignored, so they can be used as separators for readability.   Lines starting with a hash (""#"") are ignored, so they can be used for comments.  Add a backslash (""\"") to the beginning of the pattern if it starts with a hash.   Each other line contains a single pattern.       Patterns have the same syntax and semantics as patterns used for fnmatch without the FNM_PATHNAME flag, except a pathname also matches a pattern if removing any number of the final pathname components matches the pattern.  For example, the pattern ""foo*bar"" matches ""fooasdfbar"" and ""foo/bar/baz/asdf"" but not ""foobarx""."),
					new GitCommandOption("-p", "-p", @"Generate patch (see section on generating patches)."),
					new GitCommandOption("-R", "-R", @"Swap two inputs; that is, show differences from index or on-disk file to tree contents."),
					new GitCommandOption("-r", "-r", @"recurse into sub-trees"),
					new GitCommandOption("-s", "-s", @"By default, git diff-tree --stdin shows differences, either in machine-readable form (without -p) or in patch form (with -p).  This output can be suppressed.  It is only useful with -v flag."),
					new GitCommandOption("-s", "-s", @"Suppress diff output. Useful for commands like git show that show the patch by default, or to cancel the effect of --patch."),
					new GitCommandOption("-S<string>", "-S<string>", @"Look for differences that change the number of occurrences of the specified string (i.e. addition/deletion) in a file. Intended for the scripter’s use.  It is useful when you’re looking for an exact block of code (like a struct), and want to know the history of that block since it first came into being: use the feature iteratively to feed the interesting block in the preimage back into -S, and keep going until you get the very first version of the block.   Binary files are searched as well."),
					new GitCommandOption("-t", "-t", @"show tree entry itself as well as subtrees.  Implies -r."),
					new GitCommandOption("-u", "-u", @"Generate patch (see section on generating patches)."),
					new GitCommandOption("-U<n>", "-U<n>", @"Generate diffs with <n> lines of context instead of the usual three. Implies --patch."),
					new GitCommandOption("-v", "-v", @"This flag causes git diff-tree --stdin to also show the commit message before the differences."),
					new GitCommandOption("-w", "-w", @"Ignore whitespace when comparing lines.  This ignores differences even if one line has whitespace where the other line has none."),
					new GitCommandOption("-W", "-W", @"Show whole function as context lines for each change. The function names are determined in the same way as git diff works out patch hunk headers (see Defining a custom hunk-header in gitattributes)."),
					new GitCommandOption("-X[<param1,param2,…​>]", "-X[<param1,param2,…​>]", @"Output the distribution of relative amount of changes for each sub-directory. The behavior of --dirstat can be customized by passing it a comma separated list of parameters. The defaults are controlled by the diff.dirstat configuration variable (see git-config). The following parameters are available:     changes  Compute the dirstat numbers by counting the lines that have been removed from the source, or added to the destination. This ignores the amount of pure code movements within a file.  In other words, rearranging lines in a file is not counted as much as other changes. This is the default behavior when no parameter is given.  lines  Compute the dirstat numbers by doing the regular line-based diff analysis, and summing the removed/added line counts. (For binary files, count 64-byte chunks instead, since binary files have no natural concept of lines). This is a more expensive --dirstat behavior than the changes behavior, but it does count rearranged lines within a file as much as other changes. The resulting output is consistent with what you get from the other --*stat options.  files  Compute the dirstat numbers by counting the number of files changed. Each changed file counts equally in the dirstat analysis. This is the computationally cheapest --dirstat behavior, since it does not have to look at the file contents at all.  cumulative  Count changes in a child directory for the parent directory as well. Note that when using cumulative, the sum of the percentages reported may exceed 100%. The default (non-cumulative) behavior can be specified with the noncumulative parameter.  <limit>  An integer parameter specifies a cut-off percent (3% by default). Directories contributing less than this percentage of the changes are not shown in the output.       Example: The following will count changed files, while ignoring directories with less than 10% of the total amount of changed files, and accumulating child directory counts in the parent directories: --dirstat=files,10,cumulative."),
					new GitCommandOption("-z", "-z", @"When --raw, --numstat, --name-only or --name-status has been given, do not munge pathnames and use NULs as output field terminators.  Without this option, pathnames with ""unusual"" characters are quoted as explained for the configuration variable core.quotePath (see git-config)."),
					new GitCommandOption("allow-indentation-change", "allow-indentation-change", @"Initially ignore any whitespace in the move detection, then group the moved code blocks only into a block if the change in whitespace is the same per line. This is incompatible with the other modes."),
					new GitCommandOption("blocks", "blocks", @"Blocks of moved text of at least 20 alphanumeric characters are detected greedily. The detected blocks are painted using either the color.diff.{old,new}Moved color. Adjacent blocks cannot be told apart."),
					new GitCommandOption("changes", "changes", @"Compute the dirstat numbers by counting the lines that have been removed from the source, or added to the destination. This ignores the amount of pure code movements within a file.  In other words, rearranging lines in a file is not counted as much as other changes. This is the default behavior when no parameter is given."),
					new GitCommandOption("color", "color", @"Highlight changed words using only colors.  Implies --color."),
					new GitCommandOption("cumulative", "cumulative", @"Count changes in a child directory for the parent directory as well. Note that when using cumulative, the sum of the percentages reported may exceed 100%. The default (non-cumulative) behavior can be specified with the noncumulative parameter."),
					new GitCommandOption("default", "default", @"Is a synonym for zebra. This may change to a more sensible mode in the future."),
					new GitCommandOption("default,", "default, myers", @"The basic greedy diff algorithm. Currently, this is the default."),
					new GitCommandOption("dimmed-zebra", "dimmed-zebra", @"Similar to zebra, but additional dimming of uninteresting parts of moved code is performed. The bordering lines of two adjacent blocks are considered interesting, the rest is uninteresting. dimmed_zebra is a deprecated synonym."),
					new GitCommandOption("files", "files", @"Compute the dirstat numbers by counting the number of files changed. Each changed file counts equally in the dirstat analysis. This is the computationally cheapest --dirstat behavior, since it does not have to look at the file contents at all."),
					new GitCommandOption("histogram", "histogram", @"This algorithm extends the patience algorithm to ""support low-occurrence common elements""."),
					new GitCommandOption("ignore-all-space", "ignore-all-space", @"Ignore whitespace when comparing lines. This ignores differences even if one line has whitespace where the other line has none."),
					new GitCommandOption("ignore-space-at-eol", "ignore-space-at-eol", @"Ignore changes in whitespace at EOL."),
					new GitCommandOption("ignore-space-change", "ignore-space-change", @"Ignore changes in amount of whitespace.  This ignores whitespace at line end, and considers all other sequences of one or more whitespace characters to be equivalent."),
					new GitCommandOption("lines", "lines", @"Compute the dirstat numbers by doing the regular line-based diff analysis, and summing the removed/added line counts. (For binary files, count 64-byte chunks instead, since binary files have no natural concept of lines). This is a more expensive --dirstat behavior than the changes behavior, but it does count rearranged lines within a file as much as other changes. The resulting output is consistent with what you get from the other --*stat options."),
					new GitCommandOption("minimal", "minimal", @"Spend extra time to make sure the smallest possible diff is produced."),
					new GitCommandOption("no", "no", @"Do not ignore whitespace when performing move detection."),
					new GitCommandOption("no", "no", @"Moved lines are not highlighted."),
					new GitCommandOption("none", "none", @"Disable word diff again."),
					new GitCommandOption("patience", "patience", @"Use ""patience diff"" algorithm when generating patches."),
					new GitCommandOption("plain", "plain", @"Any line that is added in one location and was removed in another location will be colored with color.diff.newMoved. Similarly color.diff.oldMoved will be used for removed lines that are added somewhere else in the diff. This mode picks up any moved line, but it is not very useful in a review to determine if a block of code was moved without permutation."),
					new GitCommandOption("plain", "plain", @"Show words as [-removed-] and {+added+}.  Makes no attempts to escape the delimiters if they appear in the input, so the output may be ambiguous."),
					new GitCommandOption("porcelain", "porcelain", @"Use a special line-based format intended for script consumption.  Added/removed/unchanged runs are printed in the usual unified diff format, starting with a +/-/` ` character at the beginning of the line and extending to the end of the line.  Newlines in the input are represented by a tilde ~ on a line of its own."),
					new GitCommandOption("zebra", "zebra", @"Blocks of moved text are detected as in blocks mode. The blocks are painted using either the color.diff.{old,new}Moved color or color.diff.{old,new}MovedAlternative. The change between the two colors indicates that a new block was detected."),
				}, 
	"diff" => new GitCommandOption[] {
					new GitCommandOption("<limit>", "<limit>", @"An integer parameter specifies a cut-off percent (3% by default). Directories contributing less than this percentage of the changes are not shown in the output."),
					new GitCommandOption("<path>…​", "<path>…​", @"The <paths> parameters, when given, are used to limit the diff to the named paths (you can give directory names and get diff for all files under them)."),
					new GitCommandOption("--[no-]rename-empty", "--[no-]rename-empty", @"Whether to use empty blobs as rename source."),
					new GitCommandOption("--abbrev[", "--abbrev[=<n>]", @"Instead of showing the full 40-byte hexadecimal object name in diff-raw format output and diff-tree header lines, show the shortest prefix that is at least <n> hexdigits long that uniquely refers the object. In diff-patch output format, --full-index takes higher precedence, i.e. if --full-index is specified, full blob names will be shown regardless of --abbrev. Non default number of digits can be specified with --abbrev=<n>."),
					new GitCommandOption("--anchored", "--anchored=<text>", @"Generate a diff using the ""anchored diff"" algorithm.  This option may be specified more than once.   If a line exists in both the source and destination, exists only once, and starts with this text, this algorithm attempts to prevent it from appearing as a deletion or addition in the output. It uses the ""patience diff"" algorithm internally."),
					new GitCommandOption("--binary", "--binary", @"In addition to --full-index, output a binary diff that can be applied with git-apply. Implies --patch."),
					new GitCommandOption("--break-rewrites[", "--break-rewrites[=[<n>][/<m>]]", @"Break complete rewrite changes into pairs of delete and create. This serves two purposes:  It affects the way a change that amounts to a total rewrite of a file not as a series of deletion and insertion mixed together with a very few lines that happen to match textually as the context, but as a single deletion of everything old followed by a single insertion of everything new, and the number m controls this aspect of the -B option (defaults to 60%). -B/70% specifies that less than 30% of the original should remain in the result for Git to consider it a total rewrite (i.e. otherwise the resulting patch will be a series of deletion and insertion mixed together with context lines).   When used with -M, a totally-rewritten file is also considered as the source of a rename (usually -M only considers a file that disappeared as the source of a rename), and the number n controls this aspect of the -B option (defaults to 50%). -B20% specifies that a change with addition and deletion compared to 20% or more of the file’s size are eligible for being picked up as a possible source of a rename to another file."),
					new GitCommandOption("--check", "--check", @"Warn if changes introduce conflict markers or whitespace errors. What are considered whitespace errors is controlled by core.whitespace configuration.  By default, trailing whitespaces (including lines that consist solely of whitespaces) and a space character that is immediately followed by a tab character inside the initial indent of the line are considered whitespace errors. Exits with non-zero status if problems are found. Not compatible with --exit-code."),
					new GitCommandOption("--color-moved-ws", "--color-moved-ws=<modes>", @"This configures how whitespace is ignored when performing the move detection for --color-moved. It can be set by the diff.colorMovedWS configuration setting. These modes can be given as a comma separated list:     no  Do not ignore whitespace when performing move detection.  ignore-space-at-eol  Ignore changes in whitespace at EOL.  ignore-space-change  Ignore changes in amount of whitespace.  This ignores whitespace at line end, and considers all other sequences of one or more whitespace characters to be equivalent.  ignore-all-space  Ignore whitespace when comparing lines. This ignores differences even if one line has whitespace where the other line has none.  allow-indentation-change  Initially ignore any whitespace in the move detection, then group the moved code blocks only into a block if the change in whitespace is the same per line. This is incompatible with the other modes."),
					new GitCommandOption("--color-moved[", "--color-moved[=<mode>]", @"Moved lines of code are colored differently. It can be changed by the diff.colorMoved configuration setting. The <mode> defaults to no if the option is not given and to zebra if the option with no mode is given. The mode must be one of:     no  Moved lines are not highlighted.  default  Is a synonym for zebra. This may change to a more sensible mode in the future.  plain  Any line that is added in one location and was removed in another location will be colored with color.diff.newMoved. Similarly color.diff.oldMoved will be used for removed lines that are added somewhere else in the diff. This mode picks up any moved line, but it is not very useful in a review to determine if a block of code was moved without permutation.  blocks  Blocks of moved text of at least 20 alphanumeric characters are detected greedily. The detected blocks are painted using either the color.diff.{old,new}Moved color. Adjacent blocks cannot be told apart.  zebra  Blocks of moved text are detected as in blocks mode. The blocks are painted using either the color.diff.{old,new}Moved color or color.diff.{old,new}MovedAlternative. The change between the two colors indicates that a new block was detected.  dimmed-zebra  Similar to zebra, but additional dimming of uninteresting parts of moved code is performed. The bordering lines of two adjacent blocks are considered interesting, the rest is uninteresting. dimmed_zebra is a deprecated synonym."),
					new GitCommandOption("--color-words[", "--color-words[=<regex>]", @"Equivalent to --word-diff=color plus (if a regex was specified) --word-diff-regex=<regex>."),
					new GitCommandOption("--color[", "--color[=<when>]", @"Show colored diff. --color (i.e. without =<when>) is the same as --color=always. <when> can be one of always, never, or auto. It can be changed by the color.ui and color.diff configuration settings."),
					new GitCommandOption("--compact-summary", "--compact-summary", @"Output a condensed summary of extended header information such as file creations or deletions (""new"" or ""gone"", optionally ""+l"" if it’s a symlink) and mode changes (""+x"" or ""-x"" for adding or removing executable bit respectively) in diffstat. The information is put between the filename part and the graph part. Implies --stat."),
					new GitCommandOption("--cumulative", "--cumulative", @"Synonym for --dirstat=cumulative"),
					new GitCommandOption("--diff-algorithm", "--diff-algorithm={patience|minimal|histogram|myers}", @"Choose a diff algorithm. The variants are as follows:     default, myers  The basic greedy diff algorithm. Currently, this is the default.  minimal  Spend extra time to make sure the smallest possible diff is produced.  patience  Use ""patience diff"" algorithm when generating patches.  histogram  This algorithm extends the patience algorithm to ""support low-occurrence common elements"".       For instance, if you configured the diff.algorithm variable to a non-default value and want to use the default one, then you have to use --diff-algorithm=default option."),
					new GitCommandOption("--diff-filter", "--diff-filter=[(A|C|D|M|R|T|U|X|B)…​[*]]", @"Select only files that are Added (A), Copied (C), Deleted (D), Modified (M), Renamed (R), have their type (i.e. regular file, symlink, submodule, …​) changed (T), are Unmerged (U), are Unknown (X), or have had their pairing Broken (B). Any combination of the filter characters (including none) can be used. When * (All-or-none) is added to the combination, all paths are selected if there is any file that matches other criteria in the comparison; if there is no file that matches other criteria, nothing is selected.  Also, these upper-case letters can be downcased to exclude.  E.g. --diff-filter=ad excludes added and deleted paths.   Note that not all diffs can feature all types. For instance, copied and renamed entries cannot appear if detection for those types is disabled."),
					new GitCommandOption("--dirstat-by-file[", "--dirstat-by-file[=<param1,param2>…​]", @"Synonym for --dirstat=files,param1,param2…​"),
					new GitCommandOption("--dirstat[", "--dirstat[=<param1,param2,…​>]", @"Output the distribution of relative amount of changes for each sub-directory. The behavior of --dirstat can be customized by passing it a comma separated list of parameters. The defaults are controlled by the diff.dirstat configuration variable (see git-config). The following parameters are available:     changes  Compute the dirstat numbers by counting the lines that have been removed from the source, or added to the destination. This ignores the amount of pure code movements within a file.  In other words, rearranging lines in a file is not counted as much as other changes. This is the default behavior when no parameter is given.  lines  Compute the dirstat numbers by doing the regular line-based diff analysis, and summing the removed/added line counts. (For binary files, count 64-byte chunks instead, since binary files have no natural concept of lines). This is a more expensive --dirstat behavior than the changes behavior, but it does count rearranged lines within a file as much as other changes. The resulting output is consistent with what you get from the other --*stat options.  files  Compute the dirstat numbers by counting the number of files changed. Each changed file counts equally in the dirstat analysis. This is the computationally cheapest --dirstat behavior, since it does not have to look at the file contents at all.  cumulative  Count changes in a child directory for the parent directory as well. Note that when using cumulative, the sum of the percentages reported may exceed 100%. The default (non-cumulative) behavior can be specified with the noncumulative parameter.  <limit>  An integer parameter specifies a cut-off percent (3% by default). Directories contributing less than this percentage of the changes are not shown in the output.       Example: The following will count changed files, while ignoring directories with less than 10% of the total amount of changed files, and accumulating child directory counts in the parent directories: --dirstat=files,10,cumulative."),
					new GitCommandOption("--dst-prefix", "--dst-prefix=<prefix>", @"Show the given destination prefix instead of ""b/""."),
					new GitCommandOption("--exit-code", "--exit-code", @"Make the program exit with codes similar to diff. That is, it exits with 1 if there were differences and 0 means no differences."),
					new GitCommandOption("--ext-diff", "--ext-diff", @"Allow an external diff helper to be executed. If you set an external diff driver with gitattributes, you need to use this option with git-log and friends."),
					new GitCommandOption("--find-copies-harder", "--find-copies-harder", @"For performance reasons, by default, -C option finds copies only if the original file of the copy was modified in the same changeset.  This flag makes the command inspect unmodified files as candidates for the source of copy.  This is a very expensive operation for large projects, so use it with caution.  Giving more than one -C option has the same effect."),
					new GitCommandOption("--find-copies[", "--find-copies[=<n>]", @"Detect copies as well as renames.  See also --find-copies-harder. If n is specified, it has the same meaning as for -M<n>."),
					new GitCommandOption("--find-object", "--find-object=<object-id>", @"Look for differences that change the number of occurrences of the specified object. Similar to -S, just the argument is different in that it doesn’t search for a specific string but for a specific object id.  The object can be a blob or a submodule commit. It implies the -t option in git-log to also find trees."),
					new GitCommandOption("--find-renames[", "--find-renames[=<n>]", @"Detect renames. If n is specified, it is a threshold on the similarity index (i.e. amount of addition/deletions compared to the file’s size). For example, -M90% means Git should consider a delete/add pair to be a rename if more than 90% of the file hasn’t changed.  Without a % sign, the number is to be read as a fraction, with a decimal point before it.  I.e., -M5 becomes 0.5, and is thus the same as -M50%.  Similarly, -M05 is the same as -M5%.  To limit detection to exact renames, use -M100%.  The default similarity index is 50%."),
					new GitCommandOption("--full-index", "--full-index", @"Instead of the first handful of characters, show the full pre- and post-image blob object names on the ""index"" line when generating patch format output."),
					new GitCommandOption("--function-context", "--function-context", @"Show whole function as context lines for each change. The function names are determined in the same way as git diff works out patch hunk headers (see Defining a custom hunk-header in gitattributes)."),
					new GitCommandOption("--histogram", "--histogram", @"Generate a diff using the ""histogram diff"" algorithm."),
					new GitCommandOption("--ignore-all-space", "--ignore-all-space", @"Ignore whitespace when comparing lines.  This ignores differences even if one line has whitespace where the other line has none."),
					new GitCommandOption("--ignore-blank-lines", "--ignore-blank-lines", @"Ignore changes whose lines are all blank."),
					new GitCommandOption("--ignore-cr-at-eol", "--ignore-cr-at-eol", @"Ignore carriage-return at the end of line when doing a comparison."),
					new GitCommandOption("--ignore-matching-lines", "--ignore-matching-lines=<regex>", @"Ignore changes whose all lines match <regex>.  This option may be specified more than once."),
					new GitCommandOption("--ignore-space-at-eol", "--ignore-space-at-eol", @"Ignore changes in whitespace at EOL."),
					new GitCommandOption("--ignore-space-change", "--ignore-space-change", @"Ignore changes in amount of whitespace.  This ignores whitespace at line end, and considers all other sequences of one or more whitespace characters to be equivalent."),
					new GitCommandOption("--ignore-submodules[", "--ignore-submodules[=<when>]", @"Ignore changes to submodules in the diff generation. <when> can be either ""none"", ""untracked"", ""dirty"" or ""all"", which is the default. Using ""none"" will consider the submodule modified when it either contains untracked or modified files or its HEAD differs from the commit recorded in the superproject and can be used to override any settings of the ignore option in git-config or gitmodules. When ""untracked"" is used submodules are not considered dirty when they only contain untracked content (but they are still scanned for modified content). Using ""dirty"" ignores all changes to the work tree of submodules, only changes to the commits stored in the superproject are shown (this was the behavior until 1.7.0). Using ""all"" hides all changes to submodules."),
					new GitCommandOption("--indent-heuristic", "--indent-heuristic", @"Enable the heuristic that shifts diff hunk boundaries to make patches easier to read. This is the default."),
					new GitCommandOption("--inter-hunk-context", "--inter-hunk-context=<lines>", @"Show the context between diff hunks, up to the specified number of lines, thereby fusing hunks that are close to each other. Defaults to diff.interHunkContext or 0 if the config option is unset."),
					new GitCommandOption("--irreversible-delete", "--irreversible-delete", @"Omit the preimage for deletes, i.e. print only the header but not the diff between the preimage and /dev/null. The resulting patch is not meant to be applied with patch or git apply; this is solely for people who want to just concentrate on reviewing the text after the change. In addition, the output obviously lacks enough information to apply such a patch in reverse, even manually, hence the name of the option.  When used together with -B, omit also the preimage in the deletion part of a delete/create pair."),
					new GitCommandOption("--ita-invisible-in-index", "--ita-invisible-in-index", @"By default entries added by ""git add -N"" appear as an existing empty file in ""git diff"" and a new file in ""git diff --cached"". This option makes the entry appear as a new file in ""git diff"" and non-existent in ""git diff --cached"". This option could be reverted with --ita-visible-in-index. Both options are experimental and could be removed in future."),
					new GitCommandOption("--line-prefix", "--line-prefix=<prefix>", @"Prepend an additional prefix to every line of output."),
					new GitCommandOption("--minimal", "--minimal", @"Spend extra time to make sure the smallest possible diff is produced."),
					new GitCommandOption("--name-only", "--name-only", @"Show only names of changed files. The file names are often encoded in UTF-8. For more information see the discussion about encoding in the git-log manual page."),
					new GitCommandOption("--name-status", "--name-status", @"Show only names and status of changed files. See the description of the --diff-filter option on what the status letters mean. Just like --name-only the file names are often encoded in UTF-8."),
					new GitCommandOption("--no-color", "--no-color", @"Turn off colored diff. This can be used to override configuration settings. It is the same as --color=never."),
					new GitCommandOption("--no-color-moved", "--no-color-moved", @"Turn off move detection. This can be used to override configuration settings. It is the same as --color-moved=no."),
					new GitCommandOption("--no-color-moved-ws", "--no-color-moved-ws", @"Do not ignore whitespace when performing move detection. This can be used to override configuration settings. It is the same as --color-moved-ws=no."),
					new GitCommandOption("--no-ext-diff", "--no-ext-diff", @"Disallow external diff drivers."),
					new GitCommandOption("--no-indent-heuristic", "--no-indent-heuristic", @"Disable the indent heuristic."),
					new GitCommandOption("--no-patch", "--no-patch", @"Suppress diff output. Useful for commands like git show that show the patch by default, or to cancel the effect of --patch."),
					new GitCommandOption("--no-prefix", "--no-prefix", @"Do not show any source or destination prefix."),
					new GitCommandOption("--no-relative", "--no-relative", @"When run from a subdirectory of the project, it can be told to exclude changes outside the directory and show pathnames relative to it with this option.  When you are not in a subdirectory (e.g. in a bare repository), you can name which subdirectory to make the output relative to by giving a <path> as an argument. --no-relative can be used to countermand both diff.relative config option and previous --relative."),
					new GitCommandOption("--no-renames", "--no-renames", @"Turn off rename detection, even when the configuration file gives the default to do so."),
					new GitCommandOption("--no-textconv", "--no-textconv", @"Allow (or disallow) external text conversion filters to be run when comparing binary files. See gitattributes for details. Because textconv filters are typically a one-way conversion, the resulting diff is suitable for human consumption, but cannot be applied. For this reason, textconv filters are enabled by default only for git-diff and git-log, but not for git-format-patch or diff plumbing commands."),
					new GitCommandOption("--numstat", "--numstat", @"Similar to --stat, but shows number of added and deleted lines in decimal notation and pathname without abbreviation, to make it more machine friendly.  For binary files, outputs two - instead of saying 0 0."),
					new GitCommandOption("--output", "--output=<file>", @"Output to a specific file instead of stdout."),
					new GitCommandOption("--output-indicator-context", "--output-indicator-context=<char>", @"Specify the character used to indicate new, old or context lines in the generated patch. Normally they are +, - and ' ' respectively."),
					new GitCommandOption("--output-indicator-new", "--output-indicator-new=<char>", @"Specify the character used to indicate new, old or context lines in the generated patch. Normally they are +, - and ' ' respectively."),
					new GitCommandOption("--output-indicator-old", "--output-indicator-old=<char>", @"Specify the character used to indicate new, old or context lines in the generated patch. Normally they are +, - and ' ' respectively."),
					new GitCommandOption("--patch", "--patch", @"Generate patch (see section on generating patches). This is the default."),
					new GitCommandOption("--patch-with-raw", "--patch-with-raw", @"Synonym for -p --raw."),
					new GitCommandOption("--patch-with-stat", "--patch-with-stat", @"Synonym for -p --stat."),
					new GitCommandOption("--patience", "--patience", @"Generate a diff using the ""patience diff"" algorithm."),
					new GitCommandOption("--pickaxe-all", "--pickaxe-all", @"When -S or -G finds a change, show all the changes in that changeset, not just the files that contain the change in <string>."),
					new GitCommandOption("--pickaxe-regex", "--pickaxe-regex", @"Treat the <string> given to -S as an extended POSIX regular expression to match."),
					new GitCommandOption("--quiet", "--quiet", @"Disable all output of the program. Implies --exit-code."),
					new GitCommandOption("--raw", "--raw", @"Generate the diff in raw format."),
					new GitCommandOption("--relative[", "--relative[=<path>]", @"When run from a subdirectory of the project, it can be told to exclude changes outside the directory and show pathnames relative to it with this option.  When you are not in a subdirectory (e.g. in a bare repository), you can name which subdirectory to make the output relative to by giving a <path> as an argument. --no-relative can be used to countermand both diff.relative config option and previous --relative."),
					new GitCommandOption("--rotate-to", "--rotate-to=<file>", @"Discard the files before the named <file> from the output (i.e. skip to), or move them to the end of the output (i.e. rotate to).  These were invented primarily for use of the git difftool command, and may not be very useful otherwise."),
					new GitCommandOption("--shortstat", "--shortstat", @"Output only the last line of the --stat format containing total number of modified files, as well as number of added and deleted lines."),
					new GitCommandOption("--skip-to", "--skip-to=<file>", @"Discard the files before the named <file> from the output (i.e. skip to), or move them to the end of the output (i.e. rotate to).  These were invented primarily for use of the git difftool command, and may not be very useful otherwise."),
					new GitCommandOption("--src-prefix", "--src-prefix=<prefix>", @"Show the given source prefix instead of ""a/""."),
					new GitCommandOption("--stat[", "--stat[=<width>[,<name-width>[,<count>]]]", @"Generate a diffstat. By default, as much space as necessary will be used for the filename part, and the rest for the graph part. Maximum width defaults to terminal width, or 80 columns if not connected to a terminal, and can be overridden by <width>. The width of the filename part can be limited by giving another width <name-width> after a comma. The width of the graph part can be limited by using --stat-graph-width=<width> (affects all commands generating a stat graph) or by setting diff.statGraphWidth=<width> (does not affect git format-patch). By giving a third parameter <count>, you can limit the output to the first <count> lines, followed by ... if there are more.  These parameters can also be set individually with --stat-width=<width>, --stat-name-width=<name-width> and --stat-count=<count>."),
					new GitCommandOption("--submodule[", "--submodule[=<format>]", @"Specify how differences in submodules are shown.  When specifying --submodule=short the short format is used.  This format just shows the names of the commits at the beginning and end of the range. When --submodule or --submodule=log is specified, the log format is used.  This format lists the commits in the range like git-submodule summary does.  When --submodule=diff is specified, the diff format is used.  This format shows an inline diff of the changes in the submodule contents between the commit range.  Defaults to diff.submodule or the short format if the config option is unset."),
					new GitCommandOption("--summary", "--summary", @"Output a condensed summary of extended header information such as creations, renames and mode changes."),
					new GitCommandOption("--text", "--text", @"Treat all files as text."),
					new GitCommandOption("--textconv", "--textconv", @"Allow (or disallow) external text conversion filters to be run when comparing binary files. See gitattributes for details. Because textconv filters are typically a one-way conversion, the resulting diff is suitable for human consumption, but cannot be applied. For this reason, textconv filters are enabled by default only for git-diff and git-log, but not for git-format-patch or diff plumbing commands."),
					new GitCommandOption("--unified", "--unified=<n>", @"Generate diffs with <n> lines of context instead of the usual three. Implies --patch."),
					new GitCommandOption("--word-diff-regex", "--word-diff-regex=<regex>", @"Use <regex> to decide what a word is, instead of considering runs of non-whitespace to be a word.  Also implies --word-diff unless it was already enabled.  Every non-overlapping match of the <regex> is considered a word.  Anything between these matches is considered whitespace and ignored(!) for the purposes of finding differences.  You may want to append |[^[:space:]] to your regular expression to make sure that it matches all non-whitespace characters. A match that contains a newline is silently truncated(!) at the newline.   For example, --word-diff-regex=. will treat each character as a word and, correspondingly, show differences character by character.   The regex can also be set via a diff driver or configuration option, see gitattributes or git-config.  Giving it explicitly overrides any diff driver or configuration setting.  Diff drivers override configuration settings."),
					new GitCommandOption("--word-diff[", "--word-diff[=<mode>]", @"Show a word diff, using the <mode> to delimit changed words. By default, words are delimited by whitespace; see --word-diff-regex below.  The <mode> defaults to plain, and must be one of:     color  Highlight changed words using only colors.  Implies --color.  plain  Show words as [-removed-] and {+added+}.  Makes no attempts to escape the delimiters if they appear in the input, so the output may be ambiguous.  porcelain  Use a special line-based format intended for script consumption.  Added/removed/unchanged runs are printed in the usual unified diff format, starting with a +/-/` ` character at the beginning of the line and extending to the end of the line.  Newlines in the input are represented by a tilde ~ on a line of its own.  none  Disable word diff again.       Note that despite the name of the first mode, color is used to highlight the changed parts in all modes if enabled."),
					new GitCommandOption("--ws-error-highlight", "--ws-error-highlight=<kind>", @"Highlight whitespace errors in the context, old or new lines of the diff.  Multiple values are separated by comma, none resets previous values, default reset the list to new and all is a shorthand for old,new,context.  When this option is not given, and the configuration variable diff.wsErrorHighlight is not set, only whitespace errors in new lines are highlighted. The whitespace errors are colored with color.diff.whitespace."),
					new GitCommandOption("-0", "-0", @"Omit diff output for unmerged entries and just show ""Unmerged"".  Can be used only when comparing the working tree with the index."),
					new GitCommandOption("-1", "-1 --base", @"Compare the working tree with the ""base"" version (stage #1), ""our branch"" (stage #2) or ""their branch"" (stage #3).  The index contains these stages only for unmerged entries i.e. while resolving conflicts.  See git-read-tree section ""3-Way Merge"" for detailed information."),
					new GitCommandOption("-2", "-2 --ours", @"Compare the working tree with the ""base"" version (stage #1), ""our branch"" (stage #2) or ""their branch"" (stage #3).  The index contains these stages only for unmerged entries i.e. while resolving conflicts.  See git-read-tree section ""3-Way Merge"" for detailed information."),
					new GitCommandOption("-3", "-3 --theirs", @"Compare the working tree with the ""base"" version (stage #1), ""our branch"" (stage #2) or ""their branch"" (stage #3).  The index contains these stages only for unmerged entries i.e. while resolving conflicts.  See git-read-tree section ""3-Way Merge"" for detailed information."),
					new GitCommandOption("-a", "-a", @"Treat all files as text."),
					new GitCommandOption("-b", "-b", @"Ignore changes in amount of whitespace.  This ignores whitespace at line end, and considers all other sequences of one or more whitespace characters to be equivalent."),
					new GitCommandOption("-B[<n>][/<m>]", "-B[<n>][/<m>]", @"Break complete rewrite changes into pairs of delete and create. This serves two purposes:  It affects the way a change that amounts to a total rewrite of a file not as a series of deletion and insertion mixed together with a very few lines that happen to match textually as the context, but as a single deletion of everything old followed by a single insertion of everything new, and the number m controls this aspect of the -B option (defaults to 60%). -B/70% specifies that less than 30% of the original should remain in the result for Git to consider it a total rewrite (i.e. otherwise the resulting patch will be a series of deletion and insertion mixed together with context lines).   When used with -M, a totally-rewritten file is also considered as the source of a rename (usually -M only considers a file that disappeared as the source of a rename), and the number n controls this aspect of the -B option (defaults to 50%). -B20% specifies that a change with addition and deletion compared to 20% or more of the file’s size are eligible for being picked up as a possible source of a rename to another file."),
					new GitCommandOption("-C[<n>]", "-C[<n>]", @"Detect copies as well as renames.  See also --find-copies-harder. If n is specified, it has the same meaning as for -M<n>."),
					new GitCommandOption("-D", "-D", @"Omit the preimage for deletes, i.e. print only the header but not the diff between the preimage and /dev/null. The resulting patch is not meant to be applied with patch or git apply; this is solely for people who want to just concentrate on reviewing the text after the change. In addition, the output obviously lacks enough information to apply such a patch in reverse, even manually, hence the name of the option.  When used together with -B, omit also the preimage in the deletion part of a delete/create pair."),
					new GitCommandOption("-G<regex>", "-G<regex>", @"Look for differences whose patch text contains added/removed lines that match <regex>.  To illustrate the difference between -S<regex> --pickaxe-regex and -G<regex>, consider a commit with the following diff in the same file:    +    return frotz(nitfol, two->ptr, 1, 0); ... -    hit = frotz(nitfol, mf2.ptr, 1, 0);    While git log -G""frotz\(nitfol"" will show this commit, git log -S""frotz\(nitfol"" --pickaxe-regex will not (because the number of occurrences of that string did not change).   Unless --text is supplied patches of binary files without a textconv filter will be ignored.   See the pickaxe entry in gitdiffcore for more information."),
					new GitCommandOption("-I<regex>", "-I<regex>", @"Ignore changes whose all lines match <regex>.  This option may be specified more than once."),
					new GitCommandOption("-l<num>", "-l<num>", @"The -M and -C options involve some preliminary steps that can detect subsets of renames/copies cheaply, followed by an exhaustive fallback portion that compares all remaining unpaired destinations to all relevant sources.  (For renames, only remaining unpaired sources are relevant; for copies, all original sources are relevant.)  For N sources and destinations, this exhaustive check is O(N^2).  This option prevents the exhaustive portion of rename/copy detection from running if the number of source/destination files involved exceeds the specified number.  Defaults to diff.renameLimit. Note that a value of 0 is treated as unlimited."),
					new GitCommandOption("-M[<n>]", "-M[<n>]", @"Detect renames. If n is specified, it is a threshold on the similarity index (i.e. amount of addition/deletions compared to the file’s size). For example, -M90% means Git should consider a delete/add pair to be a rename if more than 90% of the file hasn’t changed.  Without a % sign, the number is to be read as a fraction, with a decimal point before it.  I.e., -M5 becomes 0.5, and is thus the same as -M50%.  Similarly, -M05 is the same as -M5%.  To limit detection to exact renames, use -M100%.  The default similarity index is 50%."),
					new GitCommandOption("-O<orderfile>", "-O<orderfile>", @"Control the order in which files appear in the output. This overrides the diff.orderFile configuration variable (see git-config).  To cancel diff.orderFile, use -O/dev/null.  The output order is determined by the order of glob patterns in <orderfile>. All files with pathnames that match the first pattern are output first, all files with pathnames that match the second pattern (but not the first) are output next, and so on. All files with pathnames that do not match any pattern are output last, as if there was an implicit match-all pattern at the end of the file. If multiple pathnames have the same rank (they match the same pattern but no earlier patterns), their output order relative to each other is the normal order.   <orderfile> is parsed as follows:       Blank lines are ignored, so they can be used as separators for readability.   Lines starting with a hash (""#"") are ignored, so they can be used for comments.  Add a backslash (""\"") to the beginning of the pattern if it starts with a hash.   Each other line contains a single pattern.       Patterns have the same syntax and semantics as patterns used for fnmatch without the FNM_PATHNAME flag, except a pathname also matches a pattern if removing any number of the final pathname components matches the pattern.  For example, the pattern ""foo*bar"" matches ""fooasdfbar"" and ""foo/bar/baz/asdf"" but not ""foobarx""."),
					new GitCommandOption("-p", "-p", @"Generate patch (see section on generating patches). This is the default."),
					new GitCommandOption("-R", "-R", @"Swap two inputs; that is, show differences from index or on-disk file to tree contents."),
					new GitCommandOption("-s", "-s", @"Suppress diff output. Useful for commands like git show that show the patch by default, or to cancel the effect of --patch."),
					new GitCommandOption("-S<string>", "-S<string>", @"Look for differences that change the number of occurrences of the specified string (i.e. addition/deletion) in a file. Intended for the scripter’s use.  It is useful when you’re looking for an exact block of code (like a struct), and want to know the history of that block since it first came into being: use the feature iteratively to feed the interesting block in the preimage back into -S, and keep going until you get the very first version of the block.   Binary files are searched as well."),
					new GitCommandOption("-u", "-u", @"Generate patch (see section on generating patches). This is the default."),
					new GitCommandOption("-U<n>", "-U<n>", @"Generate diffs with <n> lines of context instead of the usual three. Implies --patch."),
					new GitCommandOption("-W", "-W", @"Show whole function as context lines for each change. The function names are determined in the same way as git diff works out patch hunk headers (see Defining a custom hunk-header in gitattributes)."),
					new GitCommandOption("-w", "-w", @"Ignore whitespace when comparing lines.  This ignores differences even if one line has whitespace where the other line has none."),
					new GitCommandOption("-X[<param1,param2,…​>]", "-X[<param1,param2,…​>]", @"Output the distribution of relative amount of changes for each sub-directory. The behavior of --dirstat can be customized by passing it a comma separated list of parameters. The defaults are controlled by the diff.dirstat configuration variable (see git-config). The following parameters are available:     changes  Compute the dirstat numbers by counting the lines that have been removed from the source, or added to the destination. This ignores the amount of pure code movements within a file.  In other words, rearranging lines in a file is not counted as much as other changes. This is the default behavior when no parameter is given.  lines  Compute the dirstat numbers by doing the regular line-based diff analysis, and summing the removed/added line counts. (For binary files, count 64-byte chunks instead, since binary files have no natural concept of lines). This is a more expensive --dirstat behavior than the changes behavior, but it does count rearranged lines within a file as much as other changes. The resulting output is consistent with what you get from the other --*stat options.  files  Compute the dirstat numbers by counting the number of files changed. Each changed file counts equally in the dirstat analysis. This is the computationally cheapest --dirstat behavior, since it does not have to look at the file contents at all.  cumulative  Count changes in a child directory for the parent directory as well. Note that when using cumulative, the sum of the percentages reported may exceed 100%. The default (non-cumulative) behavior can be specified with the noncumulative parameter.  <limit>  An integer parameter specifies a cut-off percent (3% by default). Directories contributing less than this percentage of the changes are not shown in the output.       Example: The following will count changed files, while ignoring directories with less than 10% of the total amount of changed files, and accumulating child directory counts in the parent directories: --dirstat=files,10,cumulative."),
					new GitCommandOption("-z", "-z", @"When --raw, --numstat, --name-only or --name-status has been given, do not munge pathnames and use NULs as output field terminators.  Without this option, pathnames with ""unusual"" characters are quoted as explained for the configuration variable core.quotePath (see git-config)."),
					new GitCommandOption("allow-indentation-change", "allow-indentation-change", @"Initially ignore any whitespace in the move detection, then group the moved code blocks only into a block if the change in whitespace is the same per line. This is incompatible with the other modes."),
					new GitCommandOption("blocks", "blocks", @"Blocks of moved text of at least 20 alphanumeric characters are detected greedily. The detected blocks are painted using either the color.diff.{old,new}Moved color. Adjacent blocks cannot be told apart."),
					new GitCommandOption("changes", "changes", @"Compute the dirstat numbers by counting the lines that have been removed from the source, or added to the destination. This ignores the amount of pure code movements within a file.  In other words, rearranging lines in a file is not counted as much as other changes. This is the default behavior when no parameter is given."),
					new GitCommandOption("color", "color", @"Highlight changed words using only colors.  Implies --color."),
					new GitCommandOption("cumulative", "cumulative", @"Count changes in a child directory for the parent directory as well. Note that when using cumulative, the sum of the percentages reported may exceed 100%. The default (non-cumulative) behavior can be specified with the noncumulative parameter."),
					new GitCommandOption("default", "default", @"Is a synonym for zebra. This may change to a more sensible mode in the future."),
					new GitCommandOption("default,", "default, myers", @"The basic greedy diff algorithm. Currently, this is the default."),
					new GitCommandOption("dimmed-zebra", "dimmed-zebra", @"Similar to zebra, but additional dimming of uninteresting parts of moved code is performed. The bordering lines of two adjacent blocks are considered interesting, the rest is uninteresting. dimmed_zebra is a deprecated synonym."),
					new GitCommandOption("files", "files", @"Compute the dirstat numbers by counting the number of files changed. Each changed file counts equally in the dirstat analysis. This is the computationally cheapest --dirstat behavior, since it does not have to look at the file contents at all."),
					new GitCommandOption("histogram", "histogram", @"This algorithm extends the patience algorithm to ""support low-occurrence common elements""."),
					new GitCommandOption("ignore-all-space", "ignore-all-space", @"Ignore whitespace when comparing lines. This ignores differences even if one line has whitespace where the other line has none."),
					new GitCommandOption("ignore-space-at-eol", "ignore-space-at-eol", @"Ignore changes in whitespace at EOL."),
					new GitCommandOption("ignore-space-change", "ignore-space-change", @"Ignore changes in amount of whitespace.  This ignores whitespace at line end, and considers all other sequences of one or more whitespace characters to be equivalent."),
					new GitCommandOption("lines", "lines", @"Compute the dirstat numbers by doing the regular line-based diff analysis, and summing the removed/added line counts. (For binary files, count 64-byte chunks instead, since binary files have no natural concept of lines). This is a more expensive --dirstat behavior than the changes behavior, but it does count rearranged lines within a file as much as other changes. The resulting output is consistent with what you get from the other --*stat options."),
					new GitCommandOption("minimal", "minimal", @"Spend extra time to make sure the smallest possible diff is produced."),
					new GitCommandOption("no", "no", @"Do not ignore whitespace when performing move detection."),
					new GitCommandOption("no", "no", @"Moved lines are not highlighted."),
					new GitCommandOption("none", "none", @"Disable word diff again."),
					new GitCommandOption("patience", "patience", @"Use ""patience diff"" algorithm when generating patches."),
					new GitCommandOption("plain", "plain", @"Show words as [-removed-] and {+added+}.  Makes no attempts to escape the delimiters if they appear in the input, so the output may be ambiguous."),
					new GitCommandOption("plain", "plain", @"Any line that is added in one location and was removed in another location will be colored with color.diff.newMoved. Similarly color.diff.oldMoved will be used for removed lines that are added somewhere else in the diff. This mode picks up any moved line, but it is not very useful in a review to determine if a block of code was moved without permutation."),
					new GitCommandOption("porcelain", "porcelain", @"Use a special line-based format intended for script consumption.  Added/removed/unchanged runs are printed in the usual unified diff format, starting with a +/-/` ` character at the beginning of the line and extending to the end of the line.  Newlines in the input are represented by a tilde ~ on a line of its own."),
					new GitCommandOption("zebra", "zebra", @"Blocks of moved text are detected as in blocks mode. The blocks are painted using either the color.diff.{old,new}Moved color or color.diff.{old,new}MovedAlternative. The change between the two colors indicates that a new block was detected."),
				}, 
	"difftool" => new GitCommandOption[] {
					new GitCommandOption("--[no-]gui", "--[no-]gui", @"When git-difftool is invoked with the -g or --gui option the default diff tool will be read from the configured diff.guitool variable instead of diff.tool. The --no-gui option can be used to override this setting. If diff.guitool is not set, we will fallback in the order of merge.guitool, diff.tool, merge.tool until a tool is found."),
					new GitCommandOption("--[no-]symlinks", "--[no-]symlinks", @"git difftool's default behavior is create symlinks to the working tree when run in --dir-diff mode and the right-hand side of the comparison yields the same content as the file in the working tree.  Specifying --no-symlinks instructs git difftool to create copies instead.  --no-symlinks is the default on Windows."),
					new GitCommandOption("--[no-]trust-exit-code", "--[no-]trust-exit-code", @"git-difftool invokes a diff tool individually on each file. Errors reported by the diff tool are ignored by default. Use --trust-exit-code to make git-difftool exit when an invoked diff tool returns a non-zero exit code.  git-difftool will forward the exit code of the invoked tool when --trust-exit-code is used."),
					new GitCommandOption("--dir-diff", "--dir-diff", @"Copy the modified files to a temporary location and perform a directory diff on them. This mode never prompts before launching the diff tool."),
					new GitCommandOption("--extcmd", "--extcmd=<command>", @"Specify a custom command for viewing diffs. git-difftool ignores the configured defaults and runs $command $LOCAL $REMOTE when this option is specified. Additionally, $BASE is set in the environment."),
					new GitCommandOption("--no-prompt", "--no-prompt", @"Do not prompt before launching a diff tool."),
					new GitCommandOption("--prompt", "--prompt", @"Prompt before each invocation of the diff tool. This is the default behaviour; the option is provided to override any configuration settings."),
					new GitCommandOption("--rotate-to", "--rotate-to=<file>", @"Start showing the diff for the given path, the paths before it will move to end and output."),
					new GitCommandOption("--skip-to", "--skip-to=<file>", @"Start showing the diff for the given path, skipping all the paths before it."),
					new GitCommandOption("--tool", "--tool=<tool>", @"Use the diff tool specified by <tool>.  Valid values include emerge, kompare, meld, and vimdiff. Run git difftool --tool-help for the list of valid <tool> settings.  If a diff tool is not specified, git difftool will use the configuration variable diff.tool.  If the configuration variable diff.tool is not set, git difftool will pick a suitable default.   You can explicitly provide a full path to the tool by setting the configuration variable difftool.<tool>.path. For example, you can configure the absolute path to kdiff3 by setting difftool.kdiff3.path. Otherwise, git difftool assumes the tool is available in PATH.   Instead of running one of the known diff tools, git difftool can be customized to run an alternative program by specifying the command line to invoke in a configuration variable difftool.<tool>.cmd.   When git difftool is invoked with this tool (either through the -t or --tool option or the diff.tool configuration variable) the configured command line will be invoked with the following variables available: $LOCAL is set to the name of the temporary file containing the contents of the diff pre-image and $REMOTE is set to the name of the temporary file containing the contents of the diff post-image.  $MERGED is the name of the file which is being compared. $BASE is provided for compatibility with custom merge tool commands and has the same value as $MERGED."),
					new GitCommandOption("--tool-help", "--tool-help", @"Print a list of diff tools that may be used with --tool."),
					new GitCommandOption("-d", "-d", @"Copy the modified files to a temporary location and perform a directory diff on them. This mode never prompts before launching the diff tool."),
					new GitCommandOption("-g", "-g", @"When git-difftool is invoked with the -g or --gui option the default diff tool will be read from the configured diff.guitool variable instead of diff.tool. The --no-gui option can be used to override this setting. If diff.guitool is not set, we will fallback in the order of merge.guitool, diff.tool, merge.tool until a tool is found."),
					new GitCommandOption("-t", "-t <tool>", @"Use the diff tool specified by <tool>.  Valid values include emerge, kompare, meld, and vimdiff. Run git difftool --tool-help for the list of valid <tool> settings.  If a diff tool is not specified, git difftool will use the configuration variable diff.tool.  If the configuration variable diff.tool is not set, git difftool will pick a suitable default.   You can explicitly provide a full path to the tool by setting the configuration variable difftool.<tool>.path. For example, you can configure the absolute path to kdiff3 by setting difftool.kdiff3.path. Otherwise, git difftool assumes the tool is available in PATH.   Instead of running one of the known diff tools, git difftool can be customized to run an alternative program by specifying the command line to invoke in a configuration variable difftool.<tool>.cmd.   When git difftool is invoked with this tool (either through the -t or --tool option or the diff.tool configuration variable) the configured command line will be invoked with the following variables available: $LOCAL is set to the name of the temporary file containing the contents of the diff pre-image and $REMOTE is set to the name of the temporary file containing the contents of the diff post-image.  $MERGED is the name of the file which is being compared. $BASE is provided for compatibility with custom merge tool commands and has the same value as $MERGED."),
					new GitCommandOption("-x", "-x <command>", @"Specify a custom command for viewing diffs. git-difftool ignores the configured defaults and runs $command $LOCAL $REMOTE when this option is specified. Additionally, $BASE is set in the environment."),
					new GitCommandOption("-y", "-y", @"Do not prompt before launching a diff tool."),
				}, 
	"fast-export" => new GitCommandOption[] {
					new GitCommandOption("--anonymize", "--anonymize", @"Anonymize the contents of the repository while still retaining the shape of the history and stored tree.  See the section on ANONYMIZING below."),
					new GitCommandOption("--anonymize-map", "--anonymize-map=<from>[:<to>]", @"Convert token <from> to <to> in the anonymized output. If <to> is omitted, map <from> to itself (i.e., do not anonymize it). See the section on ANONYMIZING below."),
					new GitCommandOption("--export-marks", "--export-marks=<file>", @"Dumps the internal marks table to <file> when complete. Marks are written one per line as :markid SHA-1. Only marks for revisions are dumped; marks for blobs are ignored. Backends can use this file to validate imports after they have been completed, or to save the marks table across incremental runs.  As <file> is only opened and truncated at completion, the same path can also be safely given to --import-marks. The file will not be written if no new object has been marked/exported."),
					new GitCommandOption("--fake-missing-tagger", "--fake-missing-tagger", @"Some old repositories have tags without a tagger.  The fast-import protocol was pretty strict about that, and did not allow that.  So fake a tagger to be able to fast-import the output."),
					new GitCommandOption("--full-tree", "--full-tree", @"This option will cause fast-export to issue a ""deleteall"" directive for each commit followed by a full list of all files in the commit (as opposed to just listing the files which are different from the commit’s first parent)."),
					new GitCommandOption("--import-marks", "--import-marks=<file>", @"Before processing any input, load the marks specified in <file>.  The input file must exist, must be readable, and must use the same format as produced by --export-marks."),
					new GitCommandOption("--mark-tags", "--mark-tags", @"In addition to labelling blobs and commits with mark ids, also label tags.  This is useful in conjunction with --export-marks and --import-marks, and is also useful (and necessary) for exporting of nested tags.  It does not hurt other cases and would be the default, but many fast-import frontends are not prepared to accept tags with mark identifiers.  Any commits (or tags) that have already been marked will not be exported again.  If the backend uses a similar --import-marks file, this allows for incremental bidirectional exporting of the repository by keeping the marks the same across runs."),
					new GitCommandOption("--no-data", "--no-data", @"Skip output of blob objects and instead refer to blobs via their original SHA-1 hash.  This is useful when rewriting the directory structure or history of a repository without touching the contents of individual files.  Note that the resulting stream can only be used by a repository which already contains the necessary objects."),
					new GitCommandOption("--progress", "--progress=<n>", @"Insert progress statements every <n> objects, to be shown by git fast-import during import."),
					new GitCommandOption("--reencode", "--reencode=(yes|no|abort)", @"Specify how to handle encoding header in commit objects.  When asking to abort (which is the default), this program will die when encountering such a commit object.  With yes, the commit message will be re-encoded into UTF-8.  With no, the original encoding will be preserved."),
					new GitCommandOption("--reference-excluded-parents", "--reference-excluded-parents", @"By default, running a command such as git fast-export master~5..master will not include the commit master~5 and will make master~4 no longer have master~5 as a parent (though both the old master~4 and new master~4 will have all the same files).  Use --reference-excluded-parents to instead have the stream refer to commits in the excluded range of history by their sha1sum.  Note that the resulting stream can only be used by a repository which already contains the necessary parent commits."),
					new GitCommandOption("--refspec", "--refspec", @"Apply the specified refspec to each ref exported. Multiple of them can be specified."),
					new GitCommandOption("--show-original-ids", "--show-original-ids", @"Add an extra directive to the output for commits and blobs, original-oid <SHA1SUM>.  While such directives will likely be ignored by importers such as git-fast-import, it may be useful for intermediary filters (e.g. for rewriting commit messages which refer to older commits, or for stripping blobs by id)."),
					new GitCommandOption("--signed-tags", "--signed-tags=(verbatim|warn|warn-strip|strip|abort)", @"Specify how to handle signed tags.  Since any transformation after the export can change the tag names (which can also happen when excluding revisions) the signatures will not match.  When asking to abort (which is the default), this program will die when encountering a signed tag.  With strip, the tags will silently be made unsigned, with warn-strip they will be made unsigned but a warning will be displayed, with verbatim, they will be silently exported and with warn, they will be exported, but you will see a warning."),
					new GitCommandOption("--tag-of-filtered-object", "--tag-of-filtered-object=(abort|drop|rewrite)", @"Specify how to handle tags whose tagged object is filtered out. Since revisions and files to export can be limited by path, tagged objects may be filtered completely.  When asking to abort (which is the default), this program will die when encountering such a tag.  With drop it will omit such tags from the output.  With rewrite, if the tagged object is a commit, it will rewrite the tag to tag an ancestor commit (via parent rewriting; see git-rev-list)"),
					new GitCommandOption("--use-done-feature", "--use-done-feature", @"Start the stream with a feature done stanza, and terminate it with a done command."),
					new GitCommandOption("-C", "-C", @"Perform move and/or copy detection, as described in the git-diff manual page, and use it to generate rename and copy commands in the output dump.  Note that earlier versions of this command did not complain and produced incorrect results if you gave these options."),
					new GitCommandOption("-M", "-M", @"Perform move and/or copy detection, as described in the git-diff manual page, and use it to generate rename and copy commands in the output dump.  Note that earlier versions of this command did not complain and produced incorrect results if you gave these options."),
					new GitCommandOption("[<git-rev-list-args>…​]", "[<git-rev-list-args>…​]", @"A list of arguments, acceptable to git rev-parse and git rev-list, that specifies the specific objects and references to export.  For example, master~10..master causes the current master reference to be exported along with all objects added since its 10th ancestor commit and (unless the --reference-excluded-parents option is specified) all files common to master~9 and master~10."),
				}, 
	"fast-import" => new GitCommandOption[] {
					new GitCommandOption("--[no-]relative-marks", "--[no-]relative-marks", @"After specifying --relative-marks the paths specified with --import-marks= and --export-marks= are relative to an internal directory in the current repository. In git-fast-import this means that the paths are relative to the .git/info/fast-import directory. However, other importers may use a different location.  Relative and non-relative marks may be combined by interweaving --(no-)-relative-marks with the --(import|export)-marks= options."),
					new GitCommandOption("--active-branches", "--active-branches=<n>", @"Maximum number of branches to maintain active at once. See “Memory Utilization” below for details.  Default is 5."),
					new GitCommandOption("--allow-unsafe-features", "--allow-unsafe-features", @"Many command-line options can be provided as part of the fast-import stream itself by using the feature or option commands. However, some of these options are unsafe (e.g., allowing fast-import to access the filesystem outside of the repository). These options are disabled by default, but can be allowed by providing this option on the command line.  This currently impacts only the export-marks, import-marks, and import-marks-if-exists feature commands.   Only enable this option if you trust the program generating the fast-import stream! This option is enabled automatically for remote-helpers that use the `import` capability, as they are already trusted to run their own code."),
					new GitCommandOption("--big-file-threshold", "--big-file-threshold=<n>", @"Maximum size of a blob that fast-import will attempt to create a delta for, expressed in bytes.  The default is 512m (512 MiB).  Some importers may wish to lower this on systems with constrained memory."),
					new GitCommandOption("--cat-blob-fd", "--cat-blob-fd=<fd>", @"Write responses to get-mark, cat-blob, and ls queries to the file descriptor <fd> instead of stdout.  Allows progress output intended for the end-user to be separated from other output."),
					new GitCommandOption("--date-format", "--date-format=<fmt>", @"Specify the type of dates the frontend will supply to fast-import within author, committer and tagger commands. See “Date Formats” below for details about which formats are supported, and their syntax."),
					new GitCommandOption("--depth", "--depth=<n>", @"Maximum delta depth, for blob and tree deltification. Default is 50."),
					new GitCommandOption("--done", "--done", @"Terminate with error if there is no done command at the end of the stream.  This option might be useful for detecting errors that cause the frontend to terminate before it has started to write a stream."),
					new GitCommandOption("--export-marks", "--export-marks=<file>", @"Dumps the internal marks table to <file> when complete. Marks are written one per line as :markid SHA-1. Frontends can use this file to validate imports after they have been completed, or to save the marks table across incremental runs.  As <file> is only opened and truncated at checkpoint (or completion) the same path can also be safely given to --import-marks."),
					new GitCommandOption("--export-pack-edges", "--export-pack-edges=<file>", @"After creating a packfile, print a line of data to <file> listing the filename of the packfile and the last commit on each branch that was written to that packfile. This information may be useful after importing projects whose total object set exceeds the 4 GiB packfile limit, as these commits can be used as edge points during calls to git pack-objects."),
					new GitCommandOption("--force", "--force", @"Force updating modified existing branches, even if doing so would cause commits to be lost (as the new commit does not contain the old commit)."),
					new GitCommandOption("--import-marks", "--import-marks=<file>", @"Before processing any input, load the marks specified in <file>.  The input file must exist, must be readable, and must use the same format as produced by --export-marks. Multiple options may be supplied to import more than one set of marks.  If a mark is defined to different values, the last file wins."),
					new GitCommandOption("--import-marks-if-exists", "--import-marks-if-exists=<file>", @"Like --import-marks but instead of erroring out, silently skips the file if it does not exist."),
					new GitCommandOption("--max-pack-size", "--max-pack-size=<n>", @"Maximum size of each output packfile. The default is unlimited."),
					new GitCommandOption("--quiet", "--quiet", @"Disable the output shown by --stats, making fast-import usually be silent when it is successful.  However, if the import stream has directives intended to show user output (e.g. progress directives), the corresponding messages will still be shown."),
					new GitCommandOption("--rewrite-submodules-from", "--rewrite-submodules-from=<name>:<file>", @"Rewrite the object IDs for the submodule specified by <name> from the values used in the from <file> to those used in the to <file>. The from marks should have been created by git fast-export, and the to marks should have been created by git fast-import when importing that same submodule.  <name> may be any arbitrary string not containing a colon character, but the same value must be used with both options when specifying corresponding marks. Multiple submodules may be specified with different values for <name>. It is an error not to use these options in corresponding pairs.   These options are primarily useful when converting a repository from one hash algorithm to another; without them, fast-import will fail if it encounters a submodule because it has no way of writing the object ID into the new hash algorithm."),
					new GitCommandOption("--rewrite-submodules-to", "--rewrite-submodules-to=<name>:<file>", @"Rewrite the object IDs for the submodule specified by <name> from the values used in the from <file> to those used in the to <file>. The from marks should have been created by git fast-export, and the to marks should have been created by git fast-import when importing that same submodule.  <name> may be any arbitrary string not containing a colon character, but the same value must be used with both options when specifying corresponding marks. Multiple submodules may be specified with different values for <name>. It is an error not to use these options in corresponding pairs.   These options are primarily useful when converting a repository from one hash algorithm to another; without them, fast-import will fail if it encounters a submodule because it has no way of writing the object ID into the new hash algorithm."),
					new GitCommandOption("--stats", "--stats", @"Display some basic statistics about the objects fast-import has created, the packfiles they were stored into, and the memory used by fast-import during this run.  Showing this output is currently the default, but can be disabled with --quiet."),
					new GitCommandOption("fastimport.unpackLimit", "fastimport.unpackLimit", @"See git-config"),
				}, 
	"fetch-pack" => new GitCommandOption[] {
					new GitCommandOption("<refs>…​", "<refs>…​", @"The remote heads to update from. This is relative to $GIT_DIR (e.g. ""HEAD"", ""refs/heads/master"").  When unspecified, update from all heads the remote side has.  If the remote has enabled the options uploadpack.allowTipSHA1InWant, uploadpack.allowReachableSHA1InWant, or uploadpack.allowAnySHA1InWant, they may alternatively be 40-hex sha1s present on the remote."),
					new GitCommandOption("<repository>", "<repository>", @"The URL to the remote repository."),
					new GitCommandOption("--all", "--all", @"Fetch all remote refs."),
					new GitCommandOption("--check-self-contained-and-connected", "--check-self-contained-and-connected", @"Output ""connectivity-ok"" if the received pack is self-contained and connected."),
					new GitCommandOption("--deepen-relative", "--deepen-relative", @"Argument --depth specifies the number of commits from the current shallow boundary instead of from the tip of each remote branch history."),
					new GitCommandOption("--depth", "--depth=<n>", @"Limit fetching to ancestor-chains not longer than n. git-upload-pack treats the special depth 2147483647 as infinite even if there is an ancestor-chain that long."),
					new GitCommandOption("--exec", "--exec=<git-upload-pack>", @"Same as --upload-pack=<git-upload-pack>."),
					new GitCommandOption("--include-tag", "--include-tag", @"If the remote side supports it, annotated tags objects will be downloaded on the same connection as the other objects if the object the tag references is downloaded.  The caller must otherwise determine the tags this option made available."),
					new GitCommandOption("--keep", "--keep", @"Do not invoke git unpack-objects on received data, but create a single packfile out of it instead, and store it in the object database. If provided twice then the pack is locked against repacking."),
					new GitCommandOption("--no-progress", "--no-progress", @"Do not show the progress."),
					new GitCommandOption("--quiet", "--quiet", @"Pass -q flag to git unpack-objects; this makes the cloning process less verbose."),
					new GitCommandOption("--refetch", "--refetch", @"Skips negotiating commits with the server in order to fetch all matching objects. Use to reapply a new partial clone blob/tree filter."),
					new GitCommandOption("--shallow-exclude", "--shallow-exclude=<revision>", @"Deepen or shorten the history of a shallow repository to exclude commits reachable from a specified remote branch or tag. This option can be specified multiple times."),
					new GitCommandOption("--shallow-since", "--shallow-since=<date>", @"Deepen or shorten the history of a shallow repository to include all reachable commits after <date>."),
					new GitCommandOption("--stdin", "--stdin", @"Take the list of refs from stdin, one per line. If there are refs specified on the command line in addition to this option, then the refs from stdin are processed after those on the command line.  If --stateless-rpc is specified together with this option then the list of refs must be in packet format (pkt-line). Each ref must be in a separate packet, and the list must end with a flush packet."),
					new GitCommandOption("--thin", "--thin", @"Fetch a ""thin"" pack, which records objects in deltified form based on objects not included in the pack to reduce network traffic."),
					new GitCommandOption("--upload-pack", "--upload-pack=<git-upload-pack>", @"Use this to specify the path to git-upload-pack on the remote side, if is not found on your $PATH. Installations of sshd ignores the user’s environment setup scripts for login shells (e.g. .bash_profile) and your privately installed git may not be found on the system default $PATH.  Another workaround suggested is to set up your $PATH in "".bashrc"", but this flag is for people who do not want to pay the overhead for non-interactive shells by having a lean .bashrc file (they set most of the things up in .bash_profile)."),
					new GitCommandOption("-k", "-k", @"Do not invoke git unpack-objects on received data, but create a single packfile out of it instead, and store it in the object database. If provided twice then the pack is locked against repacking."),
					new GitCommandOption("-q", "-q", @"Pass -q flag to git unpack-objects; this makes the cloning process less verbose."),
					new GitCommandOption("-v", "-v", @"Run verbosely."),
				}, 
	"fetch" => new GitCommandOption[] {
					new GitCommandOption("<group>", "<group>", @"A name referring to a list of repositories as the value of remotes.<group> in the configuration file. (See git-config)."),
					new GitCommandOption("<refspec>", "<refspec>", @"Specifies which refs to fetch and which local refs to update. When no <refspec>s appear on the command line, the refs to fetch are read from remote.<repository>.fetch variables instead (see CONFIGURED REMOTE-TRACKING BRANCHES below).  The format of a <refspec> parameter is an optional plus +, followed by the source <src>, followed by a colon :, followed by the destination ref <dst>. The colon can be omitted when <dst> is empty.  <src> is typically a ref, but it can also be a fully spelled hex object name.   A <refspec> may contain a * in its <src> to indicate a simple pattern match. Such a refspec functions like a glob that matches any ref with the same prefix. A pattern <refspec> must have a * in both the <src> and <dst>. It will map refs to the destination by replacing the * with the contents matched from the source.   If a refspec is prefixed by ^, it will be interpreted as a negative refspec. Rather than specifying which refs to fetch or which local refs to update, such a refspec will instead specify refs to exclude. A ref will be considered to match if it matches at least one positive refspec, and does not match any negative refspec. Negative refspecs can be useful to restrict the scope of a pattern refspec so that it will not include specific refs. Negative refspecs can themselves be pattern refspecs. However, they may only contain a <src> and do not specify a <dst>. Fully spelled out hex object names are also not supported.   tag <tag> means the same as refs/tags/<tag>:refs/tags/<tag>; it requests fetching everything up to the given tag.   The remote ref that matches <src> is fetched, and if <dst> is not an empty string, an attempt is made to update the local ref that matches it.   Whether that update is allowed without --force depends on the ref namespace it’s being fetched to, the type of object being fetched, and whether the update is considered to be a fast-forward. Generally, the same rules apply for fetching as when pushing, see the <refspec>... section of git-push for what those are. Exceptions to those rules particular to git fetch are noted below.   Until Git version 2.20, and unlike when pushing with git-push, any updates to refs/tags/* would be accepted without + in the refspec (or --force). When fetching, we promiscuously considered all tag updates from a remote to be forced fetches.  Since Git version 2.20, fetching to update refs/tags/* works the same way as when pushing. I.e. any updates will be rejected without + in the refspec (or --force).   Unlike when pushing with git-push, any updates outside of refs/{tags,heads}/* will be accepted without + in the refspec (or --force), whether that’s swapping e.g. a tree object for a blob, or a commit for another commit that’s doesn’t have the previous commit as an ancestor etc.   Unlike when pushing with git-push, there is no configuration which’ll amend these rules, and nothing like a pre-fetch hook analogous to the pre-receive hook.   As with pushing with git-push, all of the rules described above about what’s not allowed as an update can be overridden by adding an the optional leading + to a refspec (or using --force command line option). The only exception to this is that no amount of forcing will make the refs/heads/* namespace accept a non-commit object.      Note   When the remote branch you want to fetch is known to be rewound and rebased regularly, it is expected that its new tip will not be descendant of its previous tip (as stored in your remote-tracking branch the last time you fetched).  You would want to use the + sign to indicate non-fast-forward updates will be needed for such branches.  There is no way to determine or declare that a branch will be made available in a repository with this behavior; the pulling user simply must know this is the expected usage pattern for a branch."),
					new GitCommandOption("<repository>", "<repository>", @"The ""remote"" repository that is the source of a fetch or pull operation.  This parameter can be either a URL (see the section GIT URLS below) or the name of a remote (see the section REMOTES below)."),
					new GitCommandOption("--[no-]auto-gc", "--[no-]auto-gc", @"Run git maintenance run --auto at the end to perform automatic repository maintenance if needed. (--[no-]auto-gc is a synonym.) This is enabled by default."),
					new GitCommandOption("--[no-]auto-maintenance", "--[no-]auto-maintenance", @"Run git maintenance run --auto at the end to perform automatic repository maintenance if needed. (--[no-]auto-gc is a synonym.) This is enabled by default."),
					new GitCommandOption("--[no-]write-commit-graph", "--[no-]write-commit-graph", @"Write a commit-graph after fetching. This overrides the config setting fetch.writeCommitGraph."),
					new GitCommandOption("--[no-]write-fetch-head", "--[no-]write-fetch-head", @"Write the list of remote refs fetched in the FETCH_HEAD file directly under $GIT_DIR.  This is the default. Passing --no-write-fetch-head from the command line tells Git not to write the file.  Under --dry-run option, the file is never written."),
					new GitCommandOption("--all", "--all", @"Fetch all remotes."),
					new GitCommandOption("--append", "--append", @"Append ref names and object names of fetched refs to the existing contents of .git/FETCH_HEAD.  Without this option old data in .git/FETCH_HEAD will be overwritten."),
					new GitCommandOption("--atomic", "--atomic", @"Use an atomic transaction to update local refs. Either all refs are updated, or on error, no refs are updated."),
					new GitCommandOption("--deepen", "--deepen=<depth>", @"Similar to --depth, except it specifies the number of commits from the current shallow boundary instead of from the tip of each remote branch history."),
					new GitCommandOption("--depth", "--depth=<depth>", @"Limit fetching to the specified number of commits from the tip of each remote branch history. If fetching to a shallow repository created by git clone with --depth=<depth> option (see git-clone), deepen or shorten the history to the specified number of commits. Tags for the deepened commits are not fetched."),
					new GitCommandOption("--dry-run", "--dry-run", @"Show what would be done, without making any changes."),
					new GitCommandOption("--force", "--force", @"When git fetch is used with <src>:<dst> refspec it may refuse to update the local branch as discussed in the <refspec> part below. This option overrides that check."),
					new GitCommandOption("--ipv4", "--ipv4", @"Use IPv4 addresses only, ignoring IPv6 addresses."),
					new GitCommandOption("--ipv6", "--ipv6", @"Use IPv6 addresses only, ignoring IPv4 addresses."),
					new GitCommandOption("--jobs", "--jobs=<n>", @"Number of parallel children to be used for all forms of fetching.  If the --multiple option was specified, the different remotes will be fetched in parallel. If multiple submodules are fetched, they will be fetched in parallel. To control them independently, use the config settings fetch.parallel and submodule.fetchJobs (see git-config).   Typically, parallel recursive and multi-remote fetches will be faster. By default fetches are performed sequentially, not in parallel."),
					new GitCommandOption("--keep", "--keep", @"Keep downloaded pack."),
					new GitCommandOption("--multiple", "--multiple", @"Allow several <repository> and <group> arguments to be specified. No <refspec>s may be specified."),
					new GitCommandOption("--negotiate-only", "--negotiate-only", @"Do not fetch anything from the server, and instead print the ancestors of the provided --negotiation-tip=* arguments, which we have in common with the server.  This is incompatible with --recurse-submodules=[yes|on-demand]. Internally this is used to implement the push.negotiate option, see git-config."),
					new GitCommandOption("--negotiation-tip", "--negotiation-tip=<commit|glob>", @"By default, Git will report, to the server, commits reachable from all local refs to find common commits in an attempt to reduce the size of the to-be-received packfile. If specified, Git will only report commits reachable from the given tips. This is useful to speed up fetches when the user knows which local ref is likely to have commits in common with the upstream ref being fetched.  This option may be specified more than once; if so, Git will report commits reachable from any of the given commits.   The argument to this option may be a glob on ref names, a ref, or the (possibly abbreviated) SHA-1 of a commit. Specifying a glob is equivalent to specifying this option multiple times, one for each matching ref name.   See also the fetch.negotiationAlgorithm and push.negotiate configuration variables documented in git-config, and the --negotiate-only option below."),
					new GitCommandOption("--no-recurse-submodules", "--no-recurse-submodules", @"Disable recursive fetching of submodules (this has the same effect as using the --recurse-submodules=no option)."),
					new GitCommandOption("--no-show-forced-updates", "--no-show-forced-updates", @"By default, git checks if a branch is force-updated during fetch. Pass --no-show-forced-updates or set fetch.showForcedUpdates to false to skip this check for performance reasons. If used during git-pull the --ff-only option will still check for forced updates before attempting a fast-forward update. See git-config."),
					new GitCommandOption("--no-tags", "--no-tags", @"By default, tags that point at objects that are downloaded from the remote repository are fetched and stored locally. This option disables this automatic tag following. The default behavior for a remote may be specified with the remote.<name>.tagOpt setting. See git-config."),
					new GitCommandOption("--prefetch", "--prefetch", @"Modify the configured refspec to place all refs into the refs/prefetch/ namespace. See the prefetch task in git-maintenance."),
					new GitCommandOption("--progress", "--progress", @"Progress status is reported on the standard error stream by default when it is attached to a terminal, unless -q is specified. This flag forces progress status even if the standard error stream is not directed to a terminal."),
					new GitCommandOption("--prune", "--prune", @"Before fetching, remove any remote-tracking references that no longer exist on the remote.  Tags are not subject to pruning if they are fetched only because of the default tag auto-following or due to a --tags option.  However, if tags are fetched due to an explicit refspec (either on the command line or in the remote configuration, for example if the remote was cloned with the --mirror option), then they are also subject to pruning. Supplying --prune-tags is a shorthand for providing the tag refspec.  See the PRUNING section below for more details."),
					new GitCommandOption("--prune-tags", "--prune-tags", @"Before fetching, remove any local tags that no longer exist on the remote if --prune is enabled. This option should be used more carefully, unlike --prune it will remove any local references (local tags) that have been created. This option is a shorthand for providing the explicit tag refspec along with --prune, see the discussion about that in its documentation.  See the PRUNING section below for more details."),
					new GitCommandOption("--quiet", "--quiet", @"Pass --quiet to git-fetch-pack and silence any other internally used git commands. Progress is not reported to the standard error stream."),
					new GitCommandOption("--recurse-submodules-default", "--recurse-submodules-default=[yes|on-demand]", @"This option is used internally to temporarily provide a non-negative default value for the --recurse-submodules option.  All other methods of configuring fetch’s submodule recursion (such as settings in gitmodules and git-config) override this option, as does specifying --[no-]recurse-submodules directly."),
					new GitCommandOption("--recurse-submodules[", "--recurse-submodules[=yes|on-demand|no]", @"This option controls if and under what conditions new commits of submodules should be fetched too. When recursing through submodules, git fetch always attempts to fetch ""changed"" submodules, that is, a submodule that has commits that are referenced by a newly fetched superproject commit but are missing in the local submodule clone. A changed submodule can be fetched as long as it is present locally e.g. in $GIT_DIR/modules/ (see gitsubmodules); if the upstream adds a new submodule, that submodule cannot be fetched until it is cloned e.g. by git submodule update.  When set to on-demand, only changed submodules are fetched. When set to yes, all populated submodules are fetched and submodules that are both unpopulated and changed are fetched. When set to no, submodules are never fetched.   When unspecified, this uses the value of fetch.recurseSubmodules if it is set (see git-config), defaulting to on-demand if unset. When this option is used without any value, it defaults to yes."),
					new GitCommandOption("--refetch", "--refetch", @"Instead of negotiating with the server to avoid transferring commits and associated objects that are already present locally, this option fetches all objects as a fresh clone would. Use this to reapply a partial clone filter from configuration or using --filter= when the filter definition has changed. Automatic post-fetch maintenance will perform object database pack consolidation to remove any duplicate objects."),
					new GitCommandOption("--refmap", "--refmap=<refspec>", @"When fetching refs listed on the command line, use the specified refspec (can be given more than once) to map the refs to remote-tracking branches, instead of the values of remote.*.fetch configuration variables for the remote repository.  Providing an empty <refspec> to the --refmap option causes Git to ignore the configured refspecs and rely entirely on the refspecs supplied as command-line arguments. See section on ""Configured Remote-tracking Branches"" for details."),
					new GitCommandOption("--server-option", "--server-option=<option>", @"Transmit the given string to the server when communicating using protocol version 2.  The given string must not contain a NUL or LF character.  The server’s handling of server options, including unknown ones, is server-specific. When multiple --server-option=<option> are given, they are all sent to the other side in the order listed on the command line."),
					new GitCommandOption("--set-upstream", "--set-upstream", @"If the remote is fetched successfully, add upstream (tracking) reference, used by argument-less git-pull and other commands. For more information, see branch.<name>.merge and branch.<name>.remote in git-config."),
					new GitCommandOption("--shallow-exclude", "--shallow-exclude=<revision>", @"Deepen or shorten the history of a shallow repository to exclude commits reachable from a specified remote branch or tag. This option can be specified multiple times."),
					new GitCommandOption("--shallow-since", "--shallow-since=<date>", @"Deepen or shorten the history of a shallow repository to include all reachable commits after <date>."),
					new GitCommandOption("--show-forced-updates", "--show-forced-updates", @"By default, git checks if a branch is force-updated during fetch. This can be disabled through fetch.showForcedUpdates, but the --show-forced-updates option guarantees this check occurs. See git-config."),
					new GitCommandOption("--stdin", "--stdin", @"Read refspecs, one per line, from stdin in addition to those provided as arguments. The ""tag <name>"" format is not supported."),
					new GitCommandOption("--submodule-prefix", "--submodule-prefix=<path>", @"Prepend <path> to paths printed in informative messages such as ""Fetching submodule foo"".  This option is used internally when recursing over submodules."),
					new GitCommandOption("--tags", "--tags", @"Fetch all tags from the remote (i.e., fetch remote tags refs/tags/* into local tags with the same name), in addition to whatever else would otherwise be fetched.  Using this option alone does not subject tags to pruning, even if --prune is used (though tags may be pruned anyway if they are also the destination of an explicit refspec; see --prune)."),
					new GitCommandOption("--unshallow", "--unshallow", @"If the source repository is complete, convert a shallow repository to a complete one, removing all the limitations imposed by shallow repositories.  If the source repository is shallow, fetch as much as possible so that the current repository has the same history as the source repository."),
					new GitCommandOption("--update-head-ok", "--update-head-ok", @"By default git fetch refuses to update the head which corresponds to the current branch.  This flag disables the check.  This is purely for the internal use for git pull to communicate with git fetch, and unless you are implementing your own Porcelain you are not supposed to use it."),
					new GitCommandOption("--update-shallow", "--update-shallow", @"By default when fetching from a shallow repository, git fetch refuses refs that require updating .git/shallow. This option updates .git/shallow and accept such refs."),
					new GitCommandOption("--upload-pack", "--upload-pack <upload-pack>", @"When given, and the repository to fetch from is handled by git fetch-pack, --exec=<upload-pack> is passed to the command to specify non-default path for the command run on the other end."),
					new GitCommandOption("--verbose", "--verbose", @"Be verbose."),
					new GitCommandOption("-4", "-4", @"Use IPv4 addresses only, ignoring IPv6 addresses."),
					new GitCommandOption("-6", "-6", @"Use IPv6 addresses only, ignoring IPv4 addresses."),
					new GitCommandOption("-a", "-a", @"Append ref names and object names of fetched refs to the existing contents of .git/FETCH_HEAD.  Without this option old data in .git/FETCH_HEAD will be overwritten."),
					new GitCommandOption("-f", "-f", @"When git fetch is used with <src>:<dst> refspec it may refuse to update the local branch as discussed in the <refspec> part below. This option overrides that check."),
					new GitCommandOption("-j", "-j", @"Number of parallel children to be used for all forms of fetching.  If the --multiple option was specified, the different remotes will be fetched in parallel. If multiple submodules are fetched, they will be fetched in parallel. To control them independently, use the config settings fetch.parallel and submodule.fetchJobs (see git-config).   Typically, parallel recursive and multi-remote fetches will be faster. By default fetches are performed sequentially, not in parallel."),
					new GitCommandOption("-k", "-k", @"Keep downloaded pack."),
					new GitCommandOption("-n", "-n", @"By default, tags that point at objects that are downloaded from the remote repository are fetched and stored locally. This option disables this automatic tag following. The default behavior for a remote may be specified with the remote.<name>.tagOpt setting. See git-config."),
					new GitCommandOption("-o", "-o <option>", @"Transmit the given string to the server when communicating using protocol version 2.  The given string must not contain a NUL or LF character.  The server’s handling of server options, including unknown ones, is server-specific. When multiple --server-option=<option> are given, they are all sent to the other side in the order listed on the command line."),
					new GitCommandOption("-P", "-P", @"Before fetching, remove any local tags that no longer exist on the remote if --prune is enabled. This option should be used more carefully, unlike --prune it will remove any local references (local tags) that have been created. This option is a shorthand for providing the explicit tag refspec along with --prune, see the discussion about that in its documentation.  See the PRUNING section below for more details."),
					new GitCommandOption("-p", "-p", @"Before fetching, remove any remote-tracking references that no longer exist on the remote.  Tags are not subject to pruning if they are fetched only because of the default tag auto-following or due to a --tags option.  However, if tags are fetched due to an explicit refspec (either on the command line or in the remote configuration, for example if the remote was cloned with the --mirror option), then they are also subject to pruning. Supplying --prune-tags is a shorthand for providing the tag refspec.  See the PRUNING section below for more details."),
					new GitCommandOption("-q", "-q", @"Pass --quiet to git-fetch-pack and silence any other internally used git commands. Progress is not reported to the standard error stream."),
					new GitCommandOption("-t", "-t", @"Fetch all tags from the remote (i.e., fetch remote tags refs/tags/* into local tags with the same name), in addition to whatever else would otherwise be fetched.  Using this option alone does not subject tags to pruning, even if --prune is used (though tags may be pruned anyway if they are also the destination of an explicit refspec; see --prune)."),
					new GitCommandOption("-u", "-u", @"By default git fetch refuses to update the head which corresponds to the current branch.  This flag disables the check.  This is purely for the internal use for git pull to communicate with git fetch, and unless you are implementing your own Porcelain you are not supposed to use it."),
					new GitCommandOption("-v", "-v", @"Be verbose."),
				}, 
	"filter-branch" => new GitCommandOption[] {
					new GitCommandOption("<rev-list", "<rev-list options>…​", @"Arguments for git rev-list.  All positive refs included by these options are rewritten.  You may also specify options such as --all, but you must use -- to separate them from the git filter-branch options. Implies Remap to ancestor."),
					new GitCommandOption("--commit-filter", "--commit-filter <command>", @"This is the filter for performing the commit. If this filter is specified, it will be called instead of the git commit-tree command, with arguments of the form ""<TREE_ID> [(-p <PARENT_COMMIT_ID>)…​]"" and the log message on stdin.  The commit id is expected on stdout.  As a special extension, the commit filter may emit multiple commit ids; in that case, the rewritten children of the original commit will have all of them as parents.   You can use the map convenience function in this filter, and other convenience functions, too.  For example, calling skip_commit ""$@"" will leave out the current commit (but not its changes! If you want that, use git rebase instead).   You can also use the git_commit_non_empty_tree ""$@"" instead of git commit-tree ""$@"" if you don’t wish to keep commits with a single parent and that makes no change to the tree."),
					new GitCommandOption("--env-filter", "--env-filter <command>", @"This filter may be used if you only need to modify the environment in which the commit will be performed.  Specifically, you might want to rewrite the author/committer name/email/time environment variables (see git-commit-tree for details)."),
					new GitCommandOption("--force", "--force", @"git filter-branch refuses to start with an existing temporary directory or when there are already refs starting with refs/original/, unless forced."),
					new GitCommandOption("--index-filter", "--index-filter <command>", @"This is the filter for rewriting the index.  It is similar to the tree filter but does not check out the tree, which makes it much faster.  Frequently used with git rm --cached --ignore-unmatch ..., see EXAMPLES below.  For hairy cases, see git-update-index."),
					new GitCommandOption("--msg-filter", "--msg-filter <command>", @"This is the filter for rewriting the commit messages. The argument is evaluated in the shell with the original commit message on standard input; its standard output is used as the new commit message."),
					new GitCommandOption("--original", "--original <namespace>", @"Use this option to set the namespace where the original commits will be stored. The default value is refs/original."),
					new GitCommandOption("--parent-filter", "--parent-filter <command>", @"This is the filter for rewriting the commit’s parent list. It will receive the parent string on stdin and shall output the new parent string on stdout.  The parent string is in the format described in git-commit-tree: empty for the initial commit, ""-p parent"" for a normal commit and ""-p parent1 -p parent2 -p parent3 …​"" for a merge commit."),
					new GitCommandOption("--prune-empty", "--prune-empty", @"Some filters will generate empty commits that leave the tree untouched. This option instructs git-filter-branch to remove such commits if they have exactly one or zero non-pruned parents; merge commits will therefore remain intact.  This option cannot be used together with --commit-filter, though the same effect can be achieved by using the provided git_commit_non_empty_tree function in a commit filter."),
					new GitCommandOption("--setup", "--setup <command>", @"This is not a real filter executed for each commit but a one time setup just before the loop. Therefore no commit-specific variables are defined yet.  Functions or variables defined here can be used or modified in the following filter steps except the commit filter, for technical reasons."),
					new GitCommandOption("--state-branch", "--state-branch <branch>", @"This option will cause the mapping from old to new objects to be loaded from named branch upon startup and saved as a new commit to that branch upon exit, enabling incremental of large trees. If <branch> does not exist it will be created."),
					new GitCommandOption("--subdirectory-filter", "--subdirectory-filter <directory>", @"Only look at the history which touches the given subdirectory. The result will contain that directory (and only that) as its project root. Implies Remap to ancestor."),
					new GitCommandOption("--tag-name-filter", "--tag-name-filter <command>", @"This is the filter for rewriting tag names. When passed, it will be called for every tag ref that points to a rewritten object (or to a tag object which points to a rewritten object). The original tag name is passed via standard input, and the new tag name is expected on standard output.  The original tags are not deleted, but can be overwritten; use ""--tag-name-filter cat"" to simply update the tags.  In this case, be very careful and make sure you have the old tags backed up in case the conversion has run afoul.   Nearly proper rewriting of tag objects is supported. If the tag has a message attached, a new tag object will be created with the same message, author, and timestamp. If the tag has a signature attached, the signature will be stripped. It is by definition impossible to preserve signatures. The reason this is ""nearly"" proper, is because ideally if the tag did not change (points to the same object, has the same name, etc.) it should retain any signature. That is not the case, signatures will always be removed, buyer beware. There is also no support for changing the author or timestamp (or the tag message for that matter). Tags which point to other tags will be rewritten to point to the underlying commit."),
					new GitCommandOption("--tree-filter", "--tree-filter <command>", @"This is the filter for rewriting the tree and its contents. The argument is evaluated in shell with the working directory set to the root of the checked out tree.  The new tree is then used as-is (new files are auto-added, disappeared files are auto-removed - neither .gitignore files nor any other ignore rules HAVE ANY EFFECT!)."),
					new GitCommandOption("-d", "-d <directory>", @"Use this option to set the path to the temporary directory used for rewriting.  When applying a tree filter, the command needs to temporarily check out the tree to some directory, which may consume considerable space in case of large projects.  By default it does this in the .git-rewrite/ directory but you can override that choice by this parameter."),
					new GitCommandOption("-f", "-f", @"git filter-branch refuses to start with an existing temporary directory or when there are already refs starting with refs/original/, unless forced."),
				}, 
	"fmt-merge-msg" => new GitCommandOption[] {
					new GitCommandOption("--[no-]summary", "--[no-]summary", @"Synonyms to --log and --no-log; these are deprecated and will be removed in the future."),
					new GitCommandOption("--file", "--file <file>", @"Take the list of merged objects from <file> instead of stdin."),
					new GitCommandOption("--into-name", "--into-name <branch>", @"Prepare the merge message as if merging to the branch <branch>, instead of the name of the real branch to which the merge is made."),
					new GitCommandOption("--log[", "--log[=<n>]", @"In addition to branch names, populate the log message with one-line descriptions from the actual commits that are being merged.  At most <n> commits from each merge parent will be used (20 if <n> is omitted).  This overrides the merge.log configuration variable."),
					new GitCommandOption("--message", "--message <message>", @"Use <message> instead of the branch names for the first line of the log message.  For use with --log."),
					new GitCommandOption("--no-log", "--no-log", @"Do not list one-line descriptions from the actual commits being merged."),
					new GitCommandOption("-F", "-F <file>", @"Take the list of merged objects from <file> instead of stdin."),
					new GitCommandOption("-m", "-m <message>", @"Use <message> instead of the branch names for the first line of the log message.  For use with --log."),
				}, 
	"for-each-ref" => new GitCommandOption[] {
					new GitCommandOption("<pattern>…​", "<pattern>…​", @"If one or more patterns are given, only refs are shown that match against at least one pattern, either using fnmatch or literally, in the latter case matching completely or from the beginning up to a slash."),
					new GitCommandOption("--color[", "--color[=<when>]", @"Respect any colors specified in the --format option. The <when> field must be one of always, never, or auto (if <when> is absent, behave as if always was given)."),
					new GitCommandOption("--contains[", "--contains[=<object>]", @"Only list refs which contain the specified commit (HEAD if not specified)."),
					new GitCommandOption("--count", "--count=<count>", @"By default the command shows all refs that match <pattern>.  This option makes it stop after showing that many refs."),
					new GitCommandOption("--format", "--format=<format>", @"A string that interpolates %(fieldname) from a ref being shown and the object it points at.  If fieldname is prefixed with an asterisk (*) and the ref points at a tag object, use the value for the field in the object which the tag object refers to (instead of the field in the tag object). When unspecified, <format> defaults to %(objectname) SPC %(objecttype) TAB %(refname). It also interpolates %% to %, and %xx where xx are hex digits interpolates to character with hex code xx; for example %00 interpolates to \0 (NUL), %09 to \t (TAB) and %0a to \n (LF)."),
					new GitCommandOption("--ignore-case", "--ignore-case", @"Sorting and filtering refs are case insensitive."),
					new GitCommandOption("--merged[", "--merged[=<object>]", @"Only list refs whose tips are reachable from the specified commit (HEAD if not specified)."),
					new GitCommandOption("--no-contains[", "--no-contains[=<object>]", @"Only list refs which don’t contain the specified commit (HEAD if not specified)."),
					new GitCommandOption("--no-merged[", "--no-merged[=<object>]", @"Only list refs whose tips are not reachable from the specified commit (HEAD if not specified)."),
					new GitCommandOption("--perl", "--perl", @"If given, strings that substitute %(fieldname) placeholders are quoted as string literals suitable for the specified host language.  This is meant to produce a scriptlet that can directly be `eval`ed."),
					new GitCommandOption("--points-at", "--points-at=<object>", @"Only list refs which points at the given object."),
					new GitCommandOption("--python", "--python", @"If given, strings that substitute %(fieldname) placeholders are quoted as string literals suitable for the specified host language.  This is meant to produce a scriptlet that can directly be `eval`ed."),
					new GitCommandOption("--shell", "--shell", @"If given, strings that substitute %(fieldname) placeholders are quoted as string literals suitable for the specified host language.  This is meant to produce a scriptlet that can directly be `eval`ed."),
					new GitCommandOption("--sort", "--sort=<key>", @"A field name to sort on.  Prefix - to sort in descending order of the value.  When unspecified, refname is used.  You may use the --sort=<key> option multiple times, in which case the last key becomes the primary key."),
					new GitCommandOption("--tcl", "--tcl", @"If given, strings that substitute %(fieldname) placeholders are quoted as string literals suitable for the specified host language.  This is meant to produce a scriptlet that can directly be `eval`ed."),
				}, 
	"for-each-repo" => new GitCommandOption[] {
					new GitCommandOption("--config", "--config=<config>", @"Use the given config variable as a multi-valued list storing absolute path names. Iterate on that list of paths to run the given arguments.  These config values are loaded from system, global, and local Git config, as available. If git for-each-repo is run in a directory that is not a Git repository, then only the system and global config is used."),
				}, 
	"format-patch" => new GitCommandOption[] {
					new GitCommandOption("<limit>", "<limit>", @"An integer parameter specifies a cut-off percent (3% by default). Directories contributing less than this percentage of the changes are not shown in the output."),
					new GitCommandOption("--[no-]base[", "--[no-]base[=<commit>]", @"Record the base tree information to identify the state the patch series applies to.  See the BASE TREE INFORMATION section below for details. If <commit> is ""auto"", a base commit is automatically chosen. The --no-base option overrides a format.useAutoBase configuration."),
					new GitCommandOption("--[no-]cover-letter", "--[no-]cover-letter", @"In addition to the patches, generate a cover letter file containing the branch description, shortlog and the overall diffstat.  You can fill in a description in the file before sending it out."),
					new GitCommandOption("--[no-]rename-empty", "--[no-]rename-empty", @"Whether to use empty blobs as rename source."),
					new GitCommandOption("--[no-]signature", "--[no-]signature=<signature>", @"Add a signature to each message produced. Per RFC 3676 the signature is separated from the body by a line with '-- ' on it. If the signature option is omitted the signature defaults to the Git version number."),
					new GitCommandOption("--abbrev[", "--abbrev[=<n>]", @"Instead of showing the full 40-byte hexadecimal object name in diff-raw format output and diff-tree header lines, show the shortest prefix that is at least <n> hexdigits long that uniquely refers the object. In diff-patch output format, --full-index takes higher precedence, i.e. if --full-index is specified, full blob names will be shown regardless of --abbrev. Non default number of digits can be specified with --abbrev=<n>."),
					new GitCommandOption("--add-header", "--add-header=<header>", @"Add an arbitrary header to the email headers.  This is in addition to any configured headers, and may be used multiple times. For example, --add-header=""Organization: git-foo"". The negated form --no-add-header discards all (To:, Cc:, and custom) headers added so far from config or command line."),
					new GitCommandOption("--always", "--always", @"Include patches for commits that do not introduce any change, which are omitted by default."),
					new GitCommandOption("--anchored", "--anchored=<text>", @"Generate a diff using the ""anchored diff"" algorithm.  This option may be specified more than once.   If a line exists in both the source and destination, exists only once, and starts with this text, this algorithm attempts to prevent it from appearing as a deletion or addition in the output. It uses the ""patience diff"" algorithm internally."),
					new GitCommandOption("--attach[", "--attach[=<boundary>]", @"Create multipart/mixed attachment, the first part of which is the commit message and the patch itself in the second part, with Content-Disposition: attachment."),
					new GitCommandOption("--binary", "--binary", @"In addition to --full-index, output a binary diff that can be applied with git-apply."),
					new GitCommandOption("--break-rewrites[", "--break-rewrites[=[<n>][/<m>]]", @"Break complete rewrite changes into pairs of delete and create. This serves two purposes:  It affects the way a change that amounts to a total rewrite of a file not as a series of deletion and insertion mixed together with a very few lines that happen to match textually as the context, but as a single deletion of everything old followed by a single insertion of everything new, and the number m controls this aspect of the -B option (defaults to 60%). -B/70% specifies that less than 30% of the original should remain in the result for Git to consider it a total rewrite (i.e. otherwise the resulting patch will be a series of deletion and insertion mixed together with context lines).   When used with -M, a totally-rewritten file is also considered as the source of a rename (usually -M only considers a file that disappeared as the source of a rename), and the number n controls this aspect of the -B option (defaults to 50%). -B20% specifies that a change with addition and deletion compared to 20% or more of the file’s size are eligible for being picked up as a possible source of a rename to another file."),
					new GitCommandOption("--cc", "--cc=<email>", @"Add a Cc: header to the email headers. This is in addition to any configured headers, and may be used multiple times. The negated form --no-cc discards all Cc: headers added so far (from config or command line)."),
					new GitCommandOption("--compact-summary", "--compact-summary", @"Output a condensed summary of extended header information such as file creations or deletions (""new"" or ""gone"", optionally ""+l"" if it’s a symlink) and mode changes (""+x"" or ""-x"" for adding or removing executable bit respectively) in diffstat. The information is put between the filename part and the graph part. Implies --stat."),
					new GitCommandOption("--cover-from-description", "--cover-from-description=<mode>", @"Controls which parts of the cover letter will be automatically populated using the branch’s description.  If <mode> is message or default, the cover letter subject will be populated with placeholder text. The body of the cover letter will be populated with the branch’s description. This is the default mode when no configuration nor command line option is specified.   If <mode> is subject, the first paragraph of the branch description will populate the cover letter subject. The remainder of the description will populate the body of the cover letter.   If <mode> is auto, if the first paragraph of the branch description is greater than 100 bytes, then the mode will be message, otherwise subject will be used.   If <mode> is none, both the cover letter subject and body will be populated with placeholder text."),
					new GitCommandOption("--creation-factor", "--creation-factor=<percent>", @"Used with --range-diff, tweak the heuristic which matches up commits between the previous and current series of patches by adjusting the creation/deletion cost fudge factor. See git-range-diff) for details."),
					new GitCommandOption("--cumulative", "--cumulative", @"Synonym for --dirstat=cumulative"),
					new GitCommandOption("--diff-algorithm", "--diff-algorithm={patience|minimal|histogram|myers}", @"Choose a diff algorithm. The variants are as follows:     default, myers  The basic greedy diff algorithm. Currently, this is the default.  minimal  Spend extra time to make sure the smallest possible diff is produced.  patience  Use ""patience diff"" algorithm when generating patches.  histogram  This algorithm extends the patience algorithm to ""support low-occurrence common elements"".       For instance, if you configured the diff.algorithm variable to a non-default value and want to use the default one, then you have to use --diff-algorithm=default option."),
					new GitCommandOption("--dirstat-by-file[", "--dirstat-by-file[=<param1,param2>…​]", @"Synonym for --dirstat=files,param1,param2…​"),
					new GitCommandOption("--dirstat[", "--dirstat[=<param1,param2,…​>]", @"Output the distribution of relative amount of changes for each sub-directory. The behavior of --dirstat can be customized by passing it a comma separated list of parameters. The defaults are controlled by the diff.dirstat configuration variable (see git-config). The following parameters are available:     changes  Compute the dirstat numbers by counting the lines that have been removed from the source, or added to the destination. This ignores the amount of pure code movements within a file.  In other words, rearranging lines in a file is not counted as much as other changes. This is the default behavior when no parameter is given.  lines  Compute the dirstat numbers by doing the regular line-based diff analysis, and summing the removed/added line counts. (For binary files, count 64-byte chunks instead, since binary files have no natural concept of lines). This is a more expensive --dirstat behavior than the changes behavior, but it does count rearranged lines within a file as much as other changes. The resulting output is consistent with what you get from the other --*stat options.  files  Compute the dirstat numbers by counting the number of files changed. Each changed file counts equally in the dirstat analysis. This is the computationally cheapest --dirstat behavior, since it does not have to look at the file contents at all.  cumulative  Count changes in a child directory for the parent directory as well. Note that when using cumulative, the sum of the percentages reported may exceed 100%. The default (non-cumulative) behavior can be specified with the noncumulative parameter.  <limit>  An integer parameter specifies a cut-off percent (3% by default). Directories contributing less than this percentage of the changes are not shown in the output.       Example: The following will count changed files, while ignoring directories with less than 10% of the total amount of changed files, and accumulating child directory counts in the parent directories: --dirstat=files,10,cumulative."),
					new GitCommandOption("--dst-prefix", "--dst-prefix=<prefix>", @"Show the given destination prefix instead of ""b/""."),
					new GitCommandOption("--encode-email-headers", "--encode-email-headers", @"Encode email headers that have non-ASCII characters with ""Q-encoding"" (described in RFC 2047), instead of outputting the headers verbatim. Defaults to the value of the format.encodeEmailHeaders configuration variable."),
					new GitCommandOption("--ext-diff", "--ext-diff", @"Allow an external diff helper to be executed. If you set an external diff driver with gitattributes, you need to use this option with git-log and friends."),
					new GitCommandOption("--filename-max-length", "--filename-max-length=<n>", @"Instead of the standard 64 bytes, chomp the generated output filenames at around <n> bytes (too short a value will be silently raised to a reasonable length).  Defaults to the value of the format.filenameMaxLength configuration variable, or 64 if unconfigured."),
					new GitCommandOption("--find-copies-harder", "--find-copies-harder", @"For performance reasons, by default, -C option finds copies only if the original file of the copy was modified in the same changeset.  This flag makes the command inspect unmodified files as candidates for the source of copy.  This is a very expensive operation for large projects, so use it with caution.  Giving more than one -C option has the same effect."),
					new GitCommandOption("--find-copies[", "--find-copies[=<n>]", @"Detect copies as well as renames.  See also --find-copies-harder. If n is specified, it has the same meaning as for -M<n>."),
					new GitCommandOption("--find-renames[", "--find-renames[=<n>]", @"Detect renames. If n is specified, it is a threshold on the similarity index (i.e. amount of addition/deletions compared to the file’s size). For example, -M90% means Git should consider a delete/add pair to be a rename if more than 90% of the file hasn’t changed.  Without a % sign, the number is to be read as a fraction, with a decimal point before it.  I.e., -M5 becomes 0.5, and is thus the same as -M50%.  Similarly, -M05 is the same as -M5%.  To limit detection to exact renames, use -M100%.  The default similarity index is 50%."),
					new GitCommandOption("--from", "--from=<ident>", @"Use ident in the From: header of each commit email. If the author ident of the commit is not textually identical to the provided ident, place a From: header in the body of the message with the original author. If no ident is given, use the committer ident.  Note that this option is only useful if you are actually sending the emails and want to identify yourself as the sender, but retain the original author (and git am will correctly pick up the in-body header). Note also that git send-email already handles this transformation for you, and this option should not be used if you are feeding the result to git send-email."),
					new GitCommandOption("--from", "--from", @"Use ident in the From: header of each commit email. If the author ident of the commit is not textually identical to the provided ident, place a From: header in the body of the message with the original author. If no ident is given, use the committer ident.  Note that this option is only useful if you are actually sending the emails and want to identify yourself as the sender, but retain the original author (and git am will correctly pick up the in-body header). Note also that git send-email already handles this transformation for you, and this option should not be used if you are feeding the result to git send-email."),
					new GitCommandOption("--full-index", "--full-index", @"Instead of the first handful of characters, show the full pre- and post-image blob object names on the ""index"" line when generating patch format output."),
					new GitCommandOption("--function-context", "--function-context", @"Show whole function as context lines for each change. The function names are determined in the same way as git diff works out patch hunk headers (see Defining a custom hunk-header in gitattributes)."),
					new GitCommandOption("--histogram", "--histogram", @"Generate a diff using the ""histogram diff"" algorithm."),
					new GitCommandOption("--ignore-all-space", "--ignore-all-space", @"Ignore whitespace when comparing lines.  This ignores differences even if one line has whitespace where the other line has none."),
					new GitCommandOption("--ignore-blank-lines", "--ignore-blank-lines", @"Ignore changes whose lines are all blank."),
					new GitCommandOption("--ignore-cr-at-eol", "--ignore-cr-at-eol", @"Ignore carriage-return at the end of line when doing a comparison."),
					new GitCommandOption("--ignore-if-in-upstream", "--ignore-if-in-upstream", @"Do not include a patch that matches a commit in <until>..<since>.  This will examine all patches reachable from <since> but not from <until> and compare them with the patches being generated, and any patch that matches is ignored."),
					new GitCommandOption("--ignore-matching-lines", "--ignore-matching-lines=<regex>", @"Ignore changes whose all lines match <regex>.  This option may be specified more than once."),
					new GitCommandOption("--ignore-space-at-eol", "--ignore-space-at-eol", @"Ignore changes in whitespace at EOL."),
					new GitCommandOption("--ignore-space-change", "--ignore-space-change", @"Ignore changes in amount of whitespace.  This ignores whitespace at line end, and considers all other sequences of one or more whitespace characters to be equivalent."),
					new GitCommandOption("--ignore-submodules[", "--ignore-submodules[=<when>]", @"Ignore changes to submodules in the diff generation. <when> can be either ""none"", ""untracked"", ""dirty"" or ""all"", which is the default. Using ""none"" will consider the submodule modified when it either contains untracked or modified files or its HEAD differs from the commit recorded in the superproject and can be used to override any settings of the ignore option in git-config or gitmodules. When ""untracked"" is used submodules are not considered dirty when they only contain untracked content (but they are still scanned for modified content). Using ""dirty"" ignores all changes to the work tree of submodules, only changes to the commits stored in the superproject are shown (this was the behavior until 1.7.0). Using ""all"" hides all changes to submodules."),
					new GitCommandOption("--in-reply-to", "--in-reply-to=<message id>", @"Make the first mail (or all the mails with --no-thread) appear as a reply to the given <message id>, which avoids breaking threads to provide a new patch series."),
					new GitCommandOption("--indent-heuristic", "--indent-heuristic", @"Enable the heuristic that shifts diff hunk boundaries to make patches easier to read. This is the default."),
					new GitCommandOption("--inline[", "--inline[=<boundary>]", @"Create multipart/mixed attachment, the first part of which is the commit message and the patch itself in the second part, with Content-Disposition: inline."),
					new GitCommandOption("--inter-hunk-context", "--inter-hunk-context=<lines>", @"Show the context between diff hunks, up to the specified number of lines, thereby fusing hunks that are close to each other. Defaults to diff.interHunkContext or 0 if the config option is unset."),
					new GitCommandOption("--interdiff", "--interdiff=<previous>", @"As a reviewer aid, insert an interdiff into the cover letter, or as commentary of the lone patch of a 1-patch series, showing the differences between the previous version of the patch series and the series currently being formatted. previous is a single revision naming the tip of the previous series which shares a common base with the series being formatted (for example git format-patch --cover-letter --interdiff=feature/v1 -3 feature/v2)."),
					new GitCommandOption("--irreversible-delete", "--irreversible-delete", @"Omit the preimage for deletes, i.e. print only the header but not the diff between the preimage and /dev/null. The resulting patch is not meant to be applied with patch or git apply; this is solely for people who want to just concentrate on reviewing the text after the change. In addition, the output obviously lacks enough information to apply such a patch in reverse, even manually, hence the name of the option.  When used together with -B, omit also the preimage in the deletion part of a delete/create pair."),
					new GitCommandOption("--ita-invisible-in-index", "--ita-invisible-in-index", @"By default entries added by ""git add -N"" appear as an existing empty file in ""git diff"" and a new file in ""git diff --cached"". This option makes the entry appear as a new file in ""git diff"" and non-existent in ""git diff --cached"". This option could be reverted with --ita-visible-in-index. Both options are experimental and could be removed in future."),
					new GitCommandOption("--keep-subject", "--keep-subject", @"Do not strip/add [PATCH] from the first line of the commit log message."),
					new GitCommandOption("--line-prefix", "--line-prefix=<prefix>", @"Prepend an additional prefix to every line of output."),
					new GitCommandOption("--minimal", "--minimal", @"Spend extra time to make sure the smallest possible diff is produced."),
					new GitCommandOption("--no-attach", "--no-attach", @"Disable the creation of an attachment, overriding the configuration setting."),
					new GitCommandOption("--no-binary", "--no-binary", @"Do not output contents of changes in binary files, instead display a notice that those files changed.  Patches generated using this option cannot be applied properly, but they are still useful for code review."),
					new GitCommandOption("--no-encode-email-headers", "--no-encode-email-headers", @"Encode email headers that have non-ASCII characters with ""Q-encoding"" (described in RFC 2047), instead of outputting the headers verbatim. Defaults to the value of the format.encodeEmailHeaders configuration variable."),
					new GitCommandOption("--no-ext-diff", "--no-ext-diff", @"Disallow external diff drivers."),
					new GitCommandOption("--no-indent-heuristic", "--no-indent-heuristic", @"Disable the indent heuristic."),
					new GitCommandOption("--no-notes", "--no-notes", @"Append the notes (see git-notes) for the commit after the three-dash line.  The expected use case of this is to write supporting explanation for the commit that does not belong to the commit log message proper, and include it with the patch submission. While one can simply write these explanations after format-patch has run but before sending, keeping them as Git notes allows them to be maintained between versions of the patch series (but see the discussion of the notes.rewrite configuration options in git-notes to use this workflow).   The default is --no-notes, unless the format.notes configuration is set."),
					new GitCommandOption("--no-numbered", "--no-numbered", @"Name output in [PATCH] format."),
					new GitCommandOption("--no-prefix", "--no-prefix", @"Do not show any source or destination prefix."),
					new GitCommandOption("--no-relative", "--no-relative", @"When run from a subdirectory of the project, it can be told to exclude changes outside the directory and show pathnames relative to it with this option.  When you are not in a subdirectory (e.g. in a bare repository), you can name which subdirectory to make the output relative to by giving a <path> as an argument. --no-relative can be used to countermand both diff.relative config option and previous --relative."),
					new GitCommandOption("--no-renames", "--no-renames", @"Turn off rename detection, even when the configuration file gives the default to do so."),
					new GitCommandOption("--no-stat", "--no-stat", @"Generate plain patches without any diffstats."),
					new GitCommandOption("--no-textconv", "--no-textconv", @"Allow (or disallow) external text conversion filters to be run when comparing binary files. See gitattributes for details. Because textconv filters are typically a one-way conversion, the resulting diff is suitable for human consumption, but cannot be applied. For this reason, textconv filters are enabled by default only for git-diff and git-log, but not for git-format-patch or diff plumbing commands."),
					new GitCommandOption("--no-thread", "--no-thread", @"Controls addition of In-Reply-To and References headers to make the second and subsequent mails appear as replies to the first.  Also controls generation of the Message-Id header to reference.  The optional <style> argument can be either shallow or deep. shallow threading makes every mail a reply to the head of the series, where the head is chosen from the cover letter, the --in-reply-to, and the first patch mail, in this order.  deep threading makes every mail a reply to the previous one.   The default is --no-thread, unless the format.thread configuration is set.  If --thread is specified without a style, it defaults to the style specified by format.thread if any, or else shallow.   Beware that the default for git send-email is to thread emails itself.  If you want git format-patch to take care of threading, you will want to ensure that threading is disabled for git send-email."),
					new GitCommandOption("--notes[", "--notes[=<ref>]", @"Append the notes (see git-notes) for the commit after the three-dash line.  The expected use case of this is to write supporting explanation for the commit that does not belong to the commit log message proper, and include it with the patch submission. While one can simply write these explanations after format-patch has run but before sending, keeping them as Git notes allows them to be maintained between versions of the patch series (but see the discussion of the notes.rewrite configuration options in git-notes to use this workflow).   The default is --no-notes, unless the format.notes configuration is set."),
					new GitCommandOption("--numbered", "--numbered", @"Name output in [PATCH n/m] format, even with a single patch."),
					new GitCommandOption("--numbered-files", "--numbered-files", @"Output file names will be a simple number sequence without the default first line of the commit appended."),
					new GitCommandOption("--numstat", "--numstat", @"Similar to --stat, but shows number of added and deleted lines in decimal notation and pathname without abbreviation, to make it more machine friendly.  For binary files, outputs two - instead of saying 0 0."),
					new GitCommandOption("--output", "--output=<file>", @"Output to a specific file instead of stdout."),
					new GitCommandOption("--output-directory", "--output-directory <dir>", @"Use <dir> to store the resulting files, instead of the current working directory."),
					new GitCommandOption("--output-indicator-context", "--output-indicator-context=<char>", @"Specify the character used to indicate new, old or context lines in the generated patch. Normally they are +, - and ' ' respectively."),
					new GitCommandOption("--output-indicator-new", "--output-indicator-new=<char>", @"Specify the character used to indicate new, old or context lines in the generated patch. Normally they are +, - and ' ' respectively."),
					new GitCommandOption("--output-indicator-old", "--output-indicator-old=<char>", @"Specify the character used to indicate new, old or context lines in the generated patch. Normally they are +, - and ' ' respectively."),
					new GitCommandOption("--patience", "--patience", @"Generate a diff using the ""patience diff"" algorithm."),
					new GitCommandOption("--progress", "--progress", @"Show progress reports on stderr as patches are generated."),
					new GitCommandOption("--quiet", "--quiet", @"Do not print the names of the generated files to standard output."),
					new GitCommandOption("--range-diff", "--range-diff=<previous>", @"As a reviewer aid, insert a range-diff (see git-range-diff) into the cover letter, or as commentary of the lone patch of a 1-patch series, showing the differences between the previous version of the patch series and the series currently being formatted. previous can be a single revision naming the tip of the previous series if it shares a common base with the series being formatted (for example git format-patch --cover-letter --range-diff=feature/v1 -3 feature/v2), or a revision range if the two versions of the series are disjoint (for example git format-patch --cover-letter --range-diff=feature/v1~3..feature/v1 -3 feature/v2).  Note that diff options passed to the command affect how the primary product of format-patch is generated, and they are not passed to the underlying range-diff machinery used to generate the cover-letter material (this may change in the future)."),
					new GitCommandOption("--relative[", "--relative[=<path>]", @"When run from a subdirectory of the project, it can be told to exclude changes outside the directory and show pathnames relative to it with this option.  When you are not in a subdirectory (e.g. in a bare repository), you can name which subdirectory to make the output relative to by giving a <path> as an argument. --no-relative can be used to countermand both diff.relative config option and previous --relative."),
					new GitCommandOption("--reroll-count", "--reroll-count=<n>", @"Mark the series as the <n>-th iteration of the topic. The output filenames have v<n> prepended to them, and the subject prefix (""PATCH"" by default, but configurable via the --subject-prefix option) has ` v<n>` appended to it.  E.g. --reroll-count=4 may produce v4-0001-add-makefile.patch file that has ""Subject: [PATCH v4 1/20] Add makefile"" in it. <n> does not have to be an integer (e.g. ""--reroll-count=4.4"", or ""--reroll-count=4rev2"" are allowed), but the downside of using such a reroll-count is that the range-diff/interdiff with the previous version does not state exactly which version the new interation is compared against."),
					new GitCommandOption("--rfc", "--rfc", @"Alias for --subject-prefix=""RFC PATCH"". RFC means ""Request For Comments""; use this when sending an experimental patch for discussion rather than application."),
					new GitCommandOption("--root", "--root", @"Treat the revision argument as a <revision range>, even if it is just a single commit (that would normally be treated as a <since>).  Note that root commits included in the specified range are always formatted as creation patches, independently of this flag."),
					new GitCommandOption("--rotate-to", "--rotate-to=<file>", @"Discard the files before the named <file> from the output (i.e. skip to), or move them to the end of the output (i.e. rotate to).  These were invented primarily for use of the git difftool command, and may not be very useful otherwise."),
					new GitCommandOption("--shortstat", "--shortstat", @"Output only the last line of the --stat format containing total number of modified files, as well as number of added and deleted lines."),
					new GitCommandOption("--signature-file", "--signature-file=<file>", @"Works just like --signature except the signature is read from a file."),
					new GitCommandOption("--signoff", "--signoff", @"Add a Signed-off-by trailer to the commit message, using the committer identity of yourself. See the signoff option in git-commit for more information."),
					new GitCommandOption("--skip-to", "--skip-to=<file>", @"Discard the files before the named <file> from the output (i.e. skip to), or move them to the end of the output (i.e. rotate to).  These were invented primarily for use of the git difftool command, and may not be very useful otherwise."),
					new GitCommandOption("--src-prefix", "--src-prefix=<prefix>", @"Show the given source prefix instead of ""a/""."),
					new GitCommandOption("--start-number", "--start-number <n>", @"Start numbering the patches at <n> instead of 1."),
					new GitCommandOption("--stat[", "--stat[=<width>[,<name-width>[,<count>]]]", @"Generate a diffstat. By default, as much space as necessary will be used for the filename part, and the rest for the graph part. Maximum width defaults to terminal width, or 80 columns if not connected to a terminal, and can be overridden by <width>. The width of the filename part can be limited by giving another width <name-width> after a comma. The width of the graph part can be limited by using --stat-graph-width=<width> (affects all commands generating a stat graph) or by setting diff.statGraphWidth=<width> (does not affect git format-patch). By giving a third parameter <count>, you can limit the output to the first <count> lines, followed by ... if there are more.  These parameters can also be set individually with --stat-width=<width>, --stat-name-width=<name-width> and --stat-count=<count>."),
					new GitCommandOption("--stdout", "--stdout", @"Print all commits to the standard output in mbox format, instead of creating a file for each one."),
					new GitCommandOption("--subject-prefix", "--subject-prefix=<subject prefix>", @"Instead of the standard [PATCH] prefix in the subject line, instead use [<subject prefix>]. This allows for useful naming of a patch series, and can be combined with the --numbered option."),
					new GitCommandOption("--suffix", "--suffix=.<sfx>", @"Instead of using .patch as the suffix for generated filenames, use specified suffix.  A common alternative is --suffix=.txt.  Leaving this empty will remove the .patch suffix.  Note that the leading character does not have to be a dot; for example, you can use --suffix=-patch to get 0001-description-of-my-change-patch."),
					new GitCommandOption("--summary", "--summary", @"Output a condensed summary of extended header information such as creations, renames and mode changes."),
					new GitCommandOption("--text", "--text", @"Treat all files as text."),
					new GitCommandOption("--textconv", "--textconv", @"Allow (or disallow) external text conversion filters to be run when comparing binary files. See gitattributes for details. Because textconv filters are typically a one-way conversion, the resulting diff is suitable for human consumption, but cannot be applied. For this reason, textconv filters are enabled by default only for git-diff and git-log, but not for git-format-patch or diff plumbing commands."),
					new GitCommandOption("--thread[", "--thread[=<style>]", @"Controls addition of In-Reply-To and References headers to make the second and subsequent mails appear as replies to the first.  Also controls generation of the Message-Id header to reference.  The optional <style> argument can be either shallow or deep. shallow threading makes every mail a reply to the head of the series, where the head is chosen from the cover letter, the --in-reply-to, and the first patch mail, in this order.  deep threading makes every mail a reply to the previous one.   The default is --no-thread, unless the format.thread configuration is set.  If --thread is specified without a style, it defaults to the style specified by format.thread if any, or else shallow.   Beware that the default for git send-email is to thread emails itself.  If you want git format-patch to take care of threading, you will want to ensure that threading is disabled for git send-email."),
					new GitCommandOption("--to", "--to=<email>", @"Add a To: header to the email headers. This is in addition to any configured headers, and may be used multiple times. The negated form --no-to discards all To: headers added so far (from config or command line)."),
					new GitCommandOption("--unified", "--unified=<n>", @"Generate diffs with <n> lines of context instead of the usual three."),
					new GitCommandOption("--zero-commit", "--zero-commit", @"Output an all-zero hash in each patch’s From header instead of the hash of the commit."),
					new GitCommandOption("-<n>", "-<n>", @"Prepare patches from the topmost <n> commits."),
					new GitCommandOption("-a", "-a", @"Treat all files as text."),
					new GitCommandOption("-b", "-b", @"Ignore changes in amount of whitespace.  This ignores whitespace at line end, and considers all other sequences of one or more whitespace characters to be equivalent."),
					new GitCommandOption("-B[<n>][/<m>]", "-B[<n>][/<m>]", @"Break complete rewrite changes into pairs of delete and create. This serves two purposes:  It affects the way a change that amounts to a total rewrite of a file not as a series of deletion and insertion mixed together with a very few lines that happen to match textually as the context, but as a single deletion of everything old followed by a single insertion of everything new, and the number m controls this aspect of the -B option (defaults to 60%). -B/70% specifies that less than 30% of the original should remain in the result for Git to consider it a total rewrite (i.e. otherwise the resulting patch will be a series of deletion and insertion mixed together with context lines).   When used with -M, a totally-rewritten file is also considered as the source of a rename (usually -M only considers a file that disappeared as the source of a rename), and the number n controls this aspect of the -B option (defaults to 50%). -B20% specifies that a change with addition and deletion compared to 20% or more of the file’s size are eligible for being picked up as a possible source of a rename to another file."),
					new GitCommandOption("-C[<n>]", "-C[<n>]", @"Detect copies as well as renames.  See also --find-copies-harder. If n is specified, it has the same meaning as for -M<n>."),
					new GitCommandOption("-D", "-D", @"Omit the preimage for deletes, i.e. print only the header but not the diff between the preimage and /dev/null. The resulting patch is not meant to be applied with patch or git apply; this is solely for people who want to just concentrate on reviewing the text after the change. In addition, the output obviously lacks enough information to apply such a patch in reverse, even manually, hence the name of the option.  When used together with -B, omit also the preimage in the deletion part of a delete/create pair."),
					new GitCommandOption("-I<regex>", "-I<regex>", @"Ignore changes whose all lines match <regex>.  This option may be specified more than once."),
					new GitCommandOption("-k", "-k", @"Do not strip/add [PATCH] from the first line of the commit log message."),
					new GitCommandOption("-l<num>", "-l<num>", @"The -M and -C options involve some preliminary steps that can detect subsets of renames/copies cheaply, followed by an exhaustive fallback portion that compares all remaining unpaired destinations to all relevant sources.  (For renames, only remaining unpaired sources are relevant; for copies, all original sources are relevant.)  For N sources and destinations, this exhaustive check is O(N^2).  This option prevents the exhaustive portion of rename/copy detection from running if the number of source/destination files involved exceeds the specified number.  Defaults to diff.renameLimit. Note that a value of 0 is treated as unlimited."),
					new GitCommandOption("-M[<n>]", "-M[<n>]", @"Detect renames. If n is specified, it is a threshold on the similarity index (i.e. amount of addition/deletions compared to the file’s size). For example, -M90% means Git should consider a delete/add pair to be a rename if more than 90% of the file hasn’t changed.  Without a % sign, the number is to be read as a fraction, with a decimal point before it.  I.e., -M5 becomes 0.5, and is thus the same as -M50%.  Similarly, -M05 is the same as -M5%.  To limit detection to exact renames, use -M100%.  The default similarity index is 50%."),
					new GitCommandOption("-n", "-n", @"Name output in [PATCH n/m] format, even with a single patch."),
					new GitCommandOption("-N", "-N", @"Name output in [PATCH] format."),
					new GitCommandOption("-o", "-o <dir>", @"Use <dir> to store the resulting files, instead of the current working directory."),
					new GitCommandOption("-O<orderfile>", "-O<orderfile>", @"Control the order in which files appear in the output. This overrides the diff.orderFile configuration variable (see git-config).  To cancel diff.orderFile, use -O/dev/null.  The output order is determined by the order of glob patterns in <orderfile>. All files with pathnames that match the first pattern are output first, all files with pathnames that match the second pattern (but not the first) are output next, and so on. All files with pathnames that do not match any pattern are output last, as if there was an implicit match-all pattern at the end of the file. If multiple pathnames have the same rank (they match the same pattern but no earlier patterns), their output order relative to each other is the normal order.   <orderfile> is parsed as follows:       Blank lines are ignored, so they can be used as separators for readability.   Lines starting with a hash (""#"") are ignored, so they can be used for comments.  Add a backslash (""\"") to the beginning of the pattern if it starts with a hash.   Each other line contains a single pattern.       Patterns have the same syntax and semantics as patterns used for fnmatch without the FNM_PATHNAME flag, except a pathname also matches a pattern if removing any number of the final pathname components matches the pattern.  For example, the pattern ""foo*bar"" matches ""fooasdfbar"" and ""foo/bar/baz/asdf"" but not ""foobarx""."),
					new GitCommandOption("-p", "-p", @"Generate plain patches without any diffstats."),
					new GitCommandOption("-q", "-q", @"Do not print the names of the generated files to standard output."),
					new GitCommandOption("-s", "-s", @"Add a Signed-off-by trailer to the commit message, using the committer identity of yourself. See the signoff option in git-commit for more information."),
					new GitCommandOption("-U<n>", "-U<n>", @"Generate diffs with <n> lines of context instead of the usual three."),
					new GitCommandOption("-v", "-v <n>", @"Mark the series as the <n>-th iteration of the topic. The output filenames have v<n> prepended to them, and the subject prefix (""PATCH"" by default, but configurable via the --subject-prefix option) has ` v<n>` appended to it.  E.g. --reroll-count=4 may produce v4-0001-add-makefile.patch file that has ""Subject: [PATCH v4 1/20] Add makefile"" in it. <n> does not have to be an integer (e.g. ""--reroll-count=4.4"", or ""--reroll-count=4rev2"" are allowed), but the downside of using such a reroll-count is that the range-diff/interdiff with the previous version does not state exactly which version the new interation is compared against."),
					new GitCommandOption("-w", "-w", @"Ignore whitespace when comparing lines.  This ignores differences even if one line has whitespace where the other line has none."),
					new GitCommandOption("-W", "-W", @"Show whole function as context lines for each change. The function names are determined in the same way as git diff works out patch hunk headers (see Defining a custom hunk-header in gitattributes)."),
					new GitCommandOption("-X[<param1,param2,…​>]", "-X[<param1,param2,…​>]", @"Output the distribution of relative amount of changes for each sub-directory. The behavior of --dirstat can be customized by passing it a comma separated list of parameters. The defaults are controlled by the diff.dirstat configuration variable (see git-config). The following parameters are available:     changes  Compute the dirstat numbers by counting the lines that have been removed from the source, or added to the destination. This ignores the amount of pure code movements within a file.  In other words, rearranging lines in a file is not counted as much as other changes. This is the default behavior when no parameter is given.  lines  Compute the dirstat numbers by doing the regular line-based diff analysis, and summing the removed/added line counts. (For binary files, count 64-byte chunks instead, since binary files have no natural concept of lines). This is a more expensive --dirstat behavior than the changes behavior, but it does count rearranged lines within a file as much as other changes. The resulting output is consistent with what you get from the other --*stat options.  files  Compute the dirstat numbers by counting the number of files changed. Each changed file counts equally in the dirstat analysis. This is the computationally cheapest --dirstat behavior, since it does not have to look at the file contents at all.  cumulative  Count changes in a child directory for the parent directory as well. Note that when using cumulative, the sum of the percentages reported may exceed 100%. The default (non-cumulative) behavior can be specified with the noncumulative parameter.  <limit>  An integer parameter specifies a cut-off percent (3% by default). Directories contributing less than this percentage of the changes are not shown in the output.       Example: The following will count changed files, while ignoring directories with less than 10% of the total amount of changed files, and accumulating child directory counts in the parent directories: --dirstat=files,10,cumulative."),
					new GitCommandOption("changes", "changes", @"Compute the dirstat numbers by counting the lines that have been removed from the source, or added to the destination. This ignores the amount of pure code movements within a file.  In other words, rearranging lines in a file is not counted as much as other changes. This is the default behavior when no parameter is given."),
					new GitCommandOption("cumulative", "cumulative", @"Count changes in a child directory for the parent directory as well. Note that when using cumulative, the sum of the percentages reported may exceed 100%. The default (non-cumulative) behavior can be specified with the noncumulative parameter."),
					new GitCommandOption("default,", "default, myers", @"The basic greedy diff algorithm. Currently, this is the default."),
					new GitCommandOption("files", "files", @"Compute the dirstat numbers by counting the number of files changed. Each changed file counts equally in the dirstat analysis. This is the computationally cheapest --dirstat behavior, since it does not have to look at the file contents at all."),
					new GitCommandOption("histogram", "histogram", @"This algorithm extends the patience algorithm to ""support low-occurrence common elements""."),
					new GitCommandOption("lines", "lines", @"Compute the dirstat numbers by doing the regular line-based diff analysis, and summing the removed/added line counts. (For binary files, count 64-byte chunks instead, since binary files have no natural concept of lines). This is a more expensive --dirstat behavior than the changes behavior, but it does count rearranged lines within a file as much as other changes. The resulting output is consistent with what you get from the other --*stat options."),
					new GitCommandOption("minimal", "minimal", @"Spend extra time to make sure the smallest possible diff is produced."),
					new GitCommandOption("patience", "patience", @"Use ""patience diff"" algorithm when generating patches."),
				}, 
	"fsck-objects" => new GitCommandOption[] {
				}, 
	"fsck" => new GitCommandOption[] {
					new GitCommandOption("<object>", "<object>", @"An object to treat as the head of an unreachability trace.  If no objects are given, git fsck defaults to using the index file, all SHA-1 references in refs namespace, and all reflogs (unless --no-reflogs is given) as heads."),
					new GitCommandOption("--[no-]dangling", "--[no-]dangling", @"Print objects that exist but that are never directly used (default). --no-dangling can be used to omit this information from the output."),
					new GitCommandOption("--[no-]progress", "--[no-]progress", @"Progress status is reported on the standard error stream by default when it is attached to a terminal, unless --no-progress or --verbose is specified. --progress forces progress status even if the standard error stream is not directed to a terminal."),
					new GitCommandOption("--cache", "--cache", @"Consider any object recorded in the index also as a head node for an unreachability trace."),
					new GitCommandOption("--connectivity-only", "--connectivity-only", @"Check only the connectivity of reachable objects, making sure that any objects referenced by a reachable tag, commit, or tree is present. This speeds up the operation by avoiding reading blobs entirely (though it does still check that referenced blobs exist). This will detect corruption in commits and trees, but not do any semantic checks (e.g., for format errors). Corruption in blob objects will not be detected at all.  Unreachable tags, commits, and trees will also be accessed to find the tips of dangling segments of history. Use --no-dangling if you don’t care about this output and want to speed it up further."),
					new GitCommandOption("--full", "--full", @"Check not just objects in GIT_OBJECT_DIRECTORY ($GIT_DIR/objects), but also the ones found in alternate object pools listed in GIT_ALTERNATE_OBJECT_DIRECTORIES or $GIT_DIR/objects/info/alternates, and in packed Git archives found in $GIT_DIR/objects/pack and corresponding pack subdirectories in alternate object pools.  This is now default; you can turn it off with --no-full."),
					new GitCommandOption("--lost-found", "--lost-found", @"Write dangling objects into .git/lost-found/commit/ or .git/lost-found/other/, depending on type.  If the object is a blob, the contents are written into the file, rather than its object name."),
					new GitCommandOption("--name-objects", "--name-objects", @"When displaying names of reachable objects, in addition to the SHA-1 also display a name that describes how they are reachable, compatible with git-rev-parse, e.g. HEAD@{1234567890}~25^2:src/."),
					new GitCommandOption("--no-reflogs", "--no-reflogs", @"Do not consider commits that are referenced only by an entry in a reflog to be reachable.  This option is meant only to search for commits that used to be in a ref, but now aren’t, but are still in that corresponding reflog."),
					new GitCommandOption("--root", "--root", @"Report root nodes."),
					new GitCommandOption("--strict", "--strict", @"Enable more strict checking, namely to catch a file mode recorded with g+w bit set, which was created by older versions of Git.  Existing repositories, including the Linux kernel, Git itself, and sparse repository have old objects that triggers this check, but it is recommended to check new projects with this flag."),
					new GitCommandOption("--tags", "--tags", @"Report tags."),
					new GitCommandOption("--unreachable", "--unreachable", @"Print out objects that exist but that aren’t reachable from any of the reference nodes."),
					new GitCommandOption("--verbose", "--verbose", @"Be chatty."),
				}, 
	"fsmonitor--daemon" => new GitCommandOption[] {
					new GitCommandOption("run", "run", @"Runs a daemon in the foreground."),
					new GitCommandOption("start", "start", @"Starts a daemon in the background."),
					new GitCommandOption("status", "status", @"Exits with zero status if a daemon is watching the current working directory."),
					new GitCommandOption("stop", "stop", @"Stops the daemon running in the current working directory, if present."),
				}, 
	"gc" => new GitCommandOption[] {
					new GitCommandOption("--aggressive", "--aggressive", @"Usually git gc runs very quickly while providing good disk space utilization and performance.  This option will cause git gc to more aggressively optimize the repository at the expense of taking much more time.  The effects of this optimization are mostly persistent. See the ""AGGRESSIVE"" section below for details."),
					new GitCommandOption("--auto", "--auto", @"With this option, git gc checks whether any housekeeping is required; if not, it exits without performing any work.  See the gc.auto option in the ""CONFIGURATION"" section below for how this heuristic works.   Once housekeeping is triggered by exceeding the limits of configuration options such as gc.auto and gc.autoPackLimit, all other housekeeping tasks (e.g. rerere, working trees, reflog…​) will be performed as well."),
					new GitCommandOption("--force", "--force", @"Force git gc to run even if there may be another git gc instance running on this repository."),
					new GitCommandOption("--keep-largest-pack", "--keep-largest-pack", @"All packs except the largest pack and those marked with a .keep files are consolidated into a single pack. When this option is used, gc.bigPackThreshold is ignored."),
					new GitCommandOption("--no-prune", "--no-prune", @"Do not prune any loose objects."),
					new GitCommandOption("--prune", "--prune=<date>", @"Prune loose objects older than date (default is 2 weeks ago, overridable by the config variable gc.pruneExpire). --prune=now prunes loose objects regardless of their age and increases the risk of corruption if another process is writing to the repository concurrently; see ""NOTES"" below. --prune is on by default."),
					new GitCommandOption("--quiet", "--quiet", @"Suppress all progress reports."),
				}, 
	"get-tar-commit-id" => new GitCommandOption[] {
				}, 
	"grep" => new GitCommandOption[] {
					new GitCommandOption("<pathspec>…​", "<pathspec>…​", @"If given, limit the search to paths matching at least one pattern. Both leading paths match and glob patterns are supported.  For more details about the <pathspec> syntax, see the pathspec entry in gitglossary."),
					new GitCommandOption("<tree>…​", "<tree>…​", @"Instead of searching tracked files in the working tree, search blobs in the given trees."),
					new GitCommandOption("--", "--", @"Signals the end of options; the rest of the parameters are <pathspec> limiters."),
					new GitCommandOption("--after-context", "--after-context <num>", @"Show <num> trailing lines, and place a line containing -- between contiguous groups of matches."),
					new GitCommandOption("--all-match", "--all-match", @"When giving multiple pattern expressions combined with --or, this flag is specified to limit the match to files that have lines to match all of them."),
					new GitCommandOption("--and", "--and", @"Specify how multiple patterns are combined using Boolean expressions.  --or is the default operator.  --and has higher precedence than --or.  -e has to be used for all patterns."),
					new GitCommandOption("--basic-regexp", "--basic-regexp", @"Use POSIX extended/basic regexp for patterns.  Default is to use basic regexp."),
					new GitCommandOption("--before-context", "--before-context <num>", @"Show <num> leading lines, and place a line containing -- between contiguous groups of matches."),
					new GitCommandOption("--break", "--break", @"Print an empty line between matches from different files."),
					new GitCommandOption("--cached", "--cached", @"Instead of searching tracked files in the working tree, search blobs registered in the index file."),
					new GitCommandOption("--color[", "--color[=<when>]", @"Show colored matches. The value must be always (the default), never, or auto."),
					new GitCommandOption("--column", "--column", @"Prefix the 1-indexed byte-offset of the first match from the start of the matching line."),
					new GitCommandOption("--context", "--context <num>", @"Show <num> leading and trailing lines, and place a line containing -- between contiguous groups of matches."),
					new GitCommandOption("--count", "--count", @"Instead of showing every matched line, show the number of lines that match."),
					new GitCommandOption("--exclude-standard", "--exclude-standard", @"Do not pay attention to ignored files specified via the .gitignore mechanism.  Only useful when searching files in the current directory with --no-index."),
					new GitCommandOption("--extended-regexp", "--extended-regexp", @"Use POSIX extended/basic regexp for patterns.  Default is to use basic regexp."),
					new GitCommandOption("--files-with-matches", "--files-with-matches", @"Instead of showing every matched line, show only the names of files that contain (or do not contain) matches. For better compatibility with git diff, --name-only is a synonym for --files-with-matches."),
					new GitCommandOption("--files-without-match", "--files-without-match", @"Instead of showing every matched line, show only the names of files that contain (or do not contain) matches. For better compatibility with git diff, --name-only is a synonym for --files-with-matches."),
					new GitCommandOption("--fixed-strings", "--fixed-strings", @"Use fixed strings for patterns (don’t interpret pattern as a regex)."),
					new GitCommandOption("--full-name", "--full-name", @"When run from a subdirectory, the command usually outputs paths relative to the current directory.  This option forces paths to be output relative to the project top directory."),
					new GitCommandOption("--function-context", "--function-context", @"Show the surrounding text from the previous line containing a function name up to the one before the next function name, effectively showing the whole function in which the match was found. The function names are determined in the same way as git diff works out patch hunk headers (see Defining a custom hunk-header in gitattributes)."),
					new GitCommandOption("--heading", "--heading", @"Show the filename above the matches in that file instead of at the start of each shown line."),
					new GitCommandOption("--ignore-case", "--ignore-case", @"Ignore case differences between the patterns and the files."),
					new GitCommandOption("--invert-match", "--invert-match", @"Select non-matching lines."),
					new GitCommandOption("--line-number", "--line-number", @"Prefix the line number to matching lines."),
					new GitCommandOption("--max-depth", "--max-depth <depth>", @"For each <pathspec> given on command line, descend at most <depth> levels of directories. A value of -1 means no limit. This option is ignored if <pathspec> contains active wildcards. In other words if ""a*"" matches a directory named ""a*"", ""*"" is matched literally so --max-depth is still effective."),
					new GitCommandOption("--name-only", "--name-only", @"Instead of showing every matched line, show only the names of files that contain (or do not contain) matches. For better compatibility with git diff, --name-only is a synonym for --files-with-matches."),
					new GitCommandOption("--no-color", "--no-color", @"Turn off match highlighting, even when the configuration file gives the default to color output. Same as --color=never."),
					new GitCommandOption("--no-exclude-standard", "--no-exclude-standard", @"Also search in ignored files by not honoring the .gitignore mechanism. Only useful with --untracked."),
					new GitCommandOption("--no-index", "--no-index", @"Search files in the current directory that is not managed by Git."),
					new GitCommandOption("--no-recursive", "--no-recursive", @"Same as --max-depth=0."),
					new GitCommandOption("--no-textconv", "--no-textconv", @"Do not honor textconv filter settings. This is the default."),
					new GitCommandOption("--not", "--not", @"Specify how multiple patterns are combined using Boolean expressions.  --or is the default operator.  --and has higher precedence than --or.  -e has to be used for all patterns."),
					new GitCommandOption("--null", "--null", @"Use \0 as the delimiter for pathnames in the output, and print them verbatim. Without this option, pathnames with ""unusual"" characters are quoted as explained for the configuration variable core.quotePath (see git-config)."),
					new GitCommandOption("--only-matching", "--only-matching", @"Print only the matched (non-empty) parts of a matching line, with each such part on a separate output line."),
					new GitCommandOption("--open-files-in-pager[", "--open-files-in-pager[=<pager>]", @"Open the matching files in the pager (not the output of grep). If the pager happens to be ""less"" or ""vi"", and the user specified only one pattern, the first file is positioned at the first match automatically. The pager argument is optional; if specified, it must be stuck to the option without a space. If pager is unspecified, the default pager will be used (see core.pager in git-config)."),
					new GitCommandOption("--or", "--or", @"Specify how multiple patterns are combined using Boolean expressions.  --or is the default operator.  --and has higher precedence than --or.  -e has to be used for all patterns."),
					new GitCommandOption("--perl-regexp", "--perl-regexp", @"Use Perl-compatible regular expressions for patterns.  Support for these types of regular expressions is an optional compile-time dependency. If Git wasn’t compiled with support for them providing this option will cause it to die."),
					new GitCommandOption("--quiet", "--quiet", @"Do not output matched lines; instead, exit with status 0 when there is a match and with non-zero status when there isn’t."),
					new GitCommandOption("--recurse-submodules", "--recurse-submodules", @"Recursively search in each submodule that is active and checked out in the repository.  When used in combination with the <tree> option the prefix of all submodule output will be the name of the parent project’s <tree> object. This option has no effect if --no-index is given."),
					new GitCommandOption("--recursive", "--recursive", @"Same as --max-depth=-1; this is the default."),
					new GitCommandOption("--show-function", "--show-function", @"Show the preceding line that contains the function name of the match, unless the matching line is a function name itself. The name is determined in the same way as git diff works out patch hunk headers (see Defining a custom hunk-header in gitattributes)."),
					new GitCommandOption("--text", "--text", @"Process binary files as if they were text."),
					new GitCommandOption("--textconv", "--textconv", @"Honor textconv filter settings."),
					new GitCommandOption("--threads", "--threads <num>", @"Number of grep worker threads to use. See grep.threads in CONFIGURATION for more information."),
					new GitCommandOption("--untracked", "--untracked", @"In addition to searching in the tracked files in the working tree, search also in untracked files."),
					new GitCommandOption("--word-regexp", "--word-regexp", @"Match the pattern only at word boundary (either begin at the beginning of a line, or preceded by a non-word character; end at the end of a line or followed by a non-word character)."),
					new GitCommandOption("-<num>", "-<num>", @"Show <num> leading and trailing lines, and place a line containing -- between contiguous groups of matches."),
					new GitCommandOption("-a", "-a", @"Process binary files as if they were text."),
					new GitCommandOption("-A", "-A <num>", @"Show <num> trailing lines, and place a line containing -- between contiguous groups of matches."),
					new GitCommandOption("-B", "-B <num>", @"Show <num> leading lines, and place a line containing -- between contiguous groups of matches."),
					new GitCommandOption("-c", "-c", @"Instead of showing every matched line, show the number of lines that match."),
					new GitCommandOption("-C", "-C <num>", @"Show <num> leading and trailing lines, and place a line containing -- between contiguous groups of matches."),
					new GitCommandOption("-e", "-e", @"The next parameter is the pattern. This option has to be used for patterns starting with - and should be used in scripts passing user input to grep.  Multiple patterns are combined by or."),
					new GitCommandOption("-E", "-E", @"Use POSIX extended/basic regexp for patterns.  Default is to use basic regexp."),
					new GitCommandOption("-f", "-f <file>", @"Read patterns from <file>, one per line.  Passing the pattern via <file> allows for providing a search pattern containing a \0.   Not all pattern types support patterns containing \0. Git will error out if a given pattern type can’t support such a pattern. The --perl-regexp pattern type when compiled against the PCRE v2 backend has the widest support for these types of patterns.   In versions of Git before 2.23.0 patterns containing \0 would be silently considered fixed. This was never documented, there were also odd and undocumented interactions between e.g. non-ASCII patterns containing \0 and --ignore-case.   In future versions we may learn to support patterns containing \0 for more search backends, until then we’ll die when the pattern type in question doesn’t support them."),
					new GitCommandOption("-F", "-F", @"Use fixed strings for patterns (don’t interpret pattern as a regex)."),
					new GitCommandOption("-G", "-G", @"Use POSIX extended/basic regexp for patterns.  Default is to use basic regexp."),
					new GitCommandOption("-h", "-h", @"By default, the command shows the filename for each match.  -h option is used to suppress this output. -H is there for completeness and does not do anything except it overrides -h given earlier on the command line."),
					new GitCommandOption("-H", "-H", @"By default, the command shows the filename for each match.  -h option is used to suppress this output. -H is there for completeness and does not do anything except it overrides -h given earlier on the command line."),
					new GitCommandOption("-i", "-i", @"Ignore case differences between the patterns and the files."),
					new GitCommandOption("-I", "-I", @"Don’t match the pattern in binary files."),
					new GitCommandOption("-L", "-L", @"Instead of showing every matched line, show only the names of files that contain (or do not contain) matches. For better compatibility with git diff, --name-only is a synonym for --files-with-matches."),
					new GitCommandOption("-l", "-l", @"Instead of showing every matched line, show only the names of files that contain (or do not contain) matches. For better compatibility with git diff, --name-only is a synonym for --files-with-matches."),
					new GitCommandOption("-n", "-n", @"Prefix the line number to matching lines."),
					new GitCommandOption("-o", "-o", @"Print only the matched (non-empty) parts of a matching line, with each such part on a separate output line."),
					new GitCommandOption("-O[<pager>]", "-O[<pager>]", @"Open the matching files in the pager (not the output of grep). If the pager happens to be ""less"" or ""vi"", and the user specified only one pattern, the first file is positioned at the first match automatically. The pager argument is optional; if specified, it must be stuck to the option without a space. If pager is unspecified, the default pager will be used (see core.pager in git-config)."),
					new GitCommandOption("-P", "-P", @"Use Perl-compatible regular expressions for patterns.  Support for these types of regular expressions is an optional compile-time dependency. If Git wasn’t compiled with support for them providing this option will cause it to die."),
					new GitCommandOption("-p", "-p", @"Show the preceding line that contains the function name of the match, unless the matching line is a function name itself. The name is determined in the same way as git diff works out patch hunk headers (see Defining a custom hunk-header in gitattributes)."),
					new GitCommandOption("-q", "-q", @"Do not output matched lines; instead, exit with status 0 when there is a match and with non-zero status when there isn’t."),
					new GitCommandOption("-r", "-r", @"Same as --max-depth=-1; this is the default."),
					new GitCommandOption("-v", "-v", @"Select non-matching lines."),
					new GitCommandOption("-W", "-W", @"Show the surrounding text from the previous line containing a function name up to the one before the next function name, effectively showing the whole function in which the match was found. The function names are determined in the same way as git diff works out patch hunk headers (see Defining a custom hunk-header in gitattributes)."),
					new GitCommandOption("-w", "-w", @"Match the pattern only at word boundary (either begin at the beginning of a line, or preceded by a non-word character; end at the end of a line or followed by a non-word character)."),
					new GitCommandOption("-z", "-z", @"Use \0 as the delimiter for pathnames in the output, and print them verbatim. Without this option, pathnames with ""unusual"" characters are quoted as explained for the configuration variable core.quotePath (see git-config)."),
					new GitCommandOption("(", "( …​ )", @"Specify how multiple patterns are combined using Boolean expressions.  --or is the default operator.  --and has higher precedence than --or.  -e has to be used for all patterns."),
				}, 
	"gui" => new GitCommandOption[] {
				}, 
	"hash-object" => new GitCommandOption[] {
					new GitCommandOption("--literally", "--literally", @"Allow --stdin to hash any garbage into a loose object which might not otherwise pass standard object parsing or git-fsck checks. Useful for stress-testing Git itself or reproducing characteristics of corrupt or bogus objects encountered in the wild."),
					new GitCommandOption("--no-filters", "--no-filters", @"Hash the contents as is, ignoring any input filter that would have been chosen by the attributes mechanism, including the end-of-line conversion. If the file is read from standard input then this is always implied, unless the --path option is given."),
					new GitCommandOption("--path", "--path", @"Hash object as it were located at the given path. The location of file does not directly influence on the hash value, but path is used to determine what Git filters should be applied to the object before it can be placed to the object database, and, as result of applying filters, the actual blob put into the object database may differ from the given file. This option is mainly useful for hashing temporary files located outside of the working directory or files read from stdin."),
					new GitCommandOption("--stdin", "--stdin", @"Read the object from standard input instead of from a file."),
					new GitCommandOption("--stdin-paths", "--stdin-paths", @"Read file names from the standard input, one per line, instead of from the command-line."),
					new GitCommandOption("-t", "-t <type>", @"Specify the type (default: ""blob"")."),
					new GitCommandOption("-w", "-w", @"Actually write the object into the object database."),
				}, 
	"help" => new GitCommandOption[] {
					new GitCommandOption("--all", "--all", @"Prints all the available commands on the standard output."),
					new GitCommandOption("--config", "--config", @"List all available configuration variables. This is a short summary of the list in git-config."),
					new GitCommandOption("--guides", "--guides", @"Prints a list of the Git concept guides on the standard output."),
					new GitCommandOption("--info", "--info", @"Display manual page for the command in the info format. The info program will be used for that purpose."),
					new GitCommandOption("--man", "--man", @"Display manual page for the command in the man format. This option may be used to override a value set in the help.format configuration variable.  By default the man program will be used to display the manual page, but the man.viewer configuration variable may be used to choose other display programs (see below)."),
					new GitCommandOption("--no-aliases", "--no-aliases", @"When used with --all, exclude the listing of configured aliases."),
					new GitCommandOption("--no-external-commands", "--no-external-commands", @"When used with --all, exclude the listing of external ""git-*"" commands found in the $PATH."),
					new GitCommandOption("--verbose", "--verbose", @"When used with --all print description for all recognized commands. This is the default."),
					new GitCommandOption("--web", "--web", @"Display manual page for the command in the web (HTML) format. A web browser will be used for that purpose.  The web browser can be specified using the configuration variable help.browser, or web.browser if the former is not set. If none of these config variables is set, the git web--browse helper script (called by git help) will pick a suitable default. See git-web--browse for more information about this."),
					new GitCommandOption("-a", "-a", @"Prints all the available commands on the standard output."),
					new GitCommandOption("-c", "-c", @"List all available configuration variables. This is a short summary of the list in git-config."),
					new GitCommandOption("-g", "-g", @"Prints a list of the Git concept guides on the standard output."),
					new GitCommandOption("-i", "-i", @"Display manual page for the command in the info format. The info program will be used for that purpose."),
					new GitCommandOption("-m", "-m", @"Display manual page for the command in the man format. This option may be used to override a value set in the help.format configuration variable.  By default the man program will be used to display the manual page, but the man.viewer configuration variable may be used to choose other display programs (see below)."),
					new GitCommandOption("-w", "-w", @"Display manual page for the command in the web (HTML) format. A web browser will be used for that purpose.  The web browser can be specified using the configuration variable help.browser, or web.browser if the former is not set. If none of these config variables is set, the git web--browse helper script (called by git help) will pick a suitable default. See git-web--browse for more information about this."),
				}, 
	"hook" => new GitCommandOption[] {
					new GitCommandOption("--ignore-missing", "--ignore-missing", @"Ignore any missing hook by quietly returning zero. Used for tools that want to do a blind one-shot run of a hook that may or may not be present."),
				}, 
	"http-backend" => new GitCommandOption[] {
				}, 
	"http-fetch" => new GitCommandOption[] {
					new GitCommandOption("--index-pack-args", "--index-pack-args=<args>", @"For internal use only. The command to run on the contents of the downloaded pack. Arguments are URL-encoded separated by spaces."),
					new GitCommandOption("--packfile", "--packfile=<hash>", @"For internal use only. Instead of a commit id on the command line (which is not expected in this case), git http-fetch fetches the packfile directly at the given URL and uses index-pack to generate corresponding .idx and .keep files. The hash is used to determine the name of the temporary file and is arbitrary. The output of index-pack is printed to stdout. Requires --index-pack-args."),
					new GitCommandOption("--recover", "--recover", @"Verify that everything reachable from target is fetched.  Used after an earlier fetch is interrupted."),
					new GitCommandOption("--stdin", "--stdin", @"Instead of a commit id on the command line (which is not expected in this case), git http-fetch expects lines on stdin in the format   <commit-id>['\t'<filename-as-in--w>]"),
					new GitCommandOption("-a,", "-a, -c, -t", @"These options are ignored for historical reasons."),
					new GitCommandOption("-v", "-v", @"Report what is downloaded."),
					new GitCommandOption("-w", "-w <filename>", @"Writes the commit-id into the filename under $GIT_DIR/refs/<filename> on the local end after the transfer is complete."),
					new GitCommandOption("commit-id", "commit-id", @"Either the hash or the filename under [URL]/refs/ to pull."),
				}, 
	"http-push" => new GitCommandOption[] {
					new GitCommandOption("<ref>…​", "<ref>…​", @"The remote refs to update."),
					new GitCommandOption("--all", "--all", @"Do not assume that the remote repository is complete in its current state, and verify all objects in the entire local ref’s history exist in the remote repository."),
					new GitCommandOption("--dry-run", "--dry-run", @"Do everything except actually send the updates."),
					new GitCommandOption("--force", "--force", @"Usually, the command refuses to update a remote ref that is not an ancestor of the local ref used to overwrite it. This flag disables the check.  What this means is that the remote repository can lose commits; use it with care."),
					new GitCommandOption("--verbose", "--verbose", @"Report the list of objects being walked locally and the list of objects successfully sent to the remote repository."),
					new GitCommandOption("-d", "-d", @"Remove <ref> from remote repository.  The specified branch cannot be the remote HEAD.  If -d is specified the following other conditions must also be met:    Remote HEAD must resolve to an object that exists locally   Specified branch resolves to an object that exists locally   Specified branch is an ancestor of the remote HEAD"),
					new GitCommandOption("-D", "-D", @"Remove <ref> from remote repository.  The specified branch cannot be the remote HEAD.  If -d is specified the following other conditions must also be met:    Remote HEAD must resolve to an object that exists locally   Specified branch resolves to an object that exists locally   Specified branch is an ancestor of the remote HEAD"),
				}, 
	"imap-send" => new GitCommandOption[] {
					new GitCommandOption("--curl", "--curl", @"Use libcurl to communicate with the IMAP server, unless tunneling into it.  Ignored if Git was built without the USE_CURL_FOR_IMAP_SEND option set."),
					new GitCommandOption("--no-curl", "--no-curl", @"Talk to the IMAP server using git’s own IMAP routines instead of using libcurl.  Ignored if Git was built with the NO_OPENSSL option set."),
					new GitCommandOption("--quiet", "--quiet", @"Be quiet."),
					new GitCommandOption("--verbose", "--verbose", @"Be verbose."),
					new GitCommandOption("-q", "-q", @"Be quiet."),
					new GitCommandOption("-v", "-v", @"Be verbose."),
				}, 
	"index-pack" => new GitCommandOption[] {
					new GitCommandOption("--[no-]rev-index", "--[no-]rev-index", @"When this flag is provided, generate a reverse index (a .rev file) corresponding to the given pack. If --verify is given, ensure that the existing reverse index is correct. Takes precedence over pack.writeReverseIndex."),
					new GitCommandOption("--check-self-contained-and-connected", "--check-self-contained-and-connected", @"Die if the pack contains broken links. For internal use only."),
					new GitCommandOption("--fix-thin", "--fix-thin", @"Fix a ""thin"" pack produced by git pack-objects --thin (see git-pack-objects for details) by adding the excluded objects the deltified objects are based on to the pack. This option only makes sense in conjunction with --stdin."),
					new GitCommandOption("--fsck-objects", "--fsck-objects", @"For internal use only.  Die if the pack contains broken objects. If the pack contains a tree pointing to a .gitmodules blob that does not exist, prints the hash of that blob (for the caller to check) after the hash that goes into the name of the pack/idx file (see ""Notes"")."),
					new GitCommandOption("--index-version", "--index-version=<version>[,<offset>]", @"This is intended to be used by the test suite only. It allows to force the version for the generated pack index, and to force 64-bit index entries on objects located above the given offset."),
					new GitCommandOption("--keep", "--keep", @"Before moving the index into its final destination create an empty .keep file for the associated pack file. This option is usually necessary with --stdin to prevent a simultaneous git repack process from deleting the newly constructed pack and index before refs can be updated to use objects contained in the pack."),
					new GitCommandOption("--keep", "--keep=<msg>", @"Like --keep create a .keep file before moving the index into its final destination, but rather than creating an empty file place <msg> followed by an LF into the .keep file.  The <msg> message can later be searched for within all .keep files to locate any which have outlived their usefulness."),
					new GitCommandOption("--max-input-size", "--max-input-size=<size>", @"Die, if the pack is larger than <size>."),
					new GitCommandOption("--object-format", "--object-format=<hash-algorithm>", @"Specify the given object format (hash algorithm) for the pack.  The valid values are sha1 and (if enabled) sha256.  The default is the algorithm for the current repository (set by extensions.objectFormat), or sha1 if no value is set or outside a repository.  This option cannot be used with --stdin.   THIS OPTION IS EXPERIMENTAL! SHA-256 support is experimental and still in an early stage.  A SHA-256 repository will in general not be able to share work with ""regular"" SHA-1 repositories.  It should be assumed that, e.g., Git internal file formats in relation to SHA-256 repositories may change in backwards-incompatible ways.  Only use --object-format=sha256 for testing purposes."),
					new GitCommandOption("--progress-title", "--progress-title", @"For internal use only.  Set the title of the progress bar. The title is ""Receiving objects"" by default and ""Indexing objects"" when --stdin is specified."),
					new GitCommandOption("--promisor[", "--promisor[=<message>]", @"Before committing the pack-index, create a .promisor file for this pack. Particularly helpful when writing a promisor pack with --fix-thin since the name of the pack is not final until the pack has been fully written. If a <message> is provided, then that content will be written to the .promisor file for future reference. See partial clone for more information."),
					new GitCommandOption("--stdin", "--stdin", @"When this flag is provided, the pack is read from stdin instead and a copy is then written to <pack-file>. If <pack-file> is not specified, the pack is written to objects/pack/ directory of the current Git repository with a default name determined from the pack content.  If <pack-file> is not specified consider using --keep to prevent a race condition between this process and git repack."),
					new GitCommandOption("--strict", "--strict", @"Die, if the pack contains broken objects or links."),
					new GitCommandOption("--threads", "--threads=<n>", @"Specifies the number of threads to spawn when resolving deltas. This requires that index-pack be compiled with pthreads otherwise this option is ignored with a warning. This is meant to reduce packing time on multiprocessor machines. The required amount of memory for the delta search window is however multiplied by the number of threads. Specifying 0 will cause Git to auto-detect the number of CPU’s and use maximum 3 threads."),
					new GitCommandOption("-o", "-o <index-file>", @"Write the generated pack index into the specified file.  Without this option the name of pack index file is constructed from the name of packed archive file by replacing .pack with .idx (and the program fails if the name of packed archive does not end with .pack)."),
					new GitCommandOption("-v", "-v", @"Be verbose about what is going on, including progress status."),
				}, 
	"init-db" => new GitCommandOption[] {
				}, 
	"init" => new GitCommandOption[] {
					new GitCommandOption("<perm>", "<perm>", @"<perm> is a 3-digit octal number prefixed with 0 and each file will have mode <perm>. <perm> will override users' umask value (and not only loosen permissions as group and all does). 0640 will create a repository which is group-readable, but not group-writable or accessible to others. 0660 will create a repo that is readable and writable to the current user and group, but inaccessible to others (directories and executable files get their x bit from the r bit for corresponding classes of users)."),
					new GitCommandOption("--bare", "--bare", @"Create a bare repository. If GIT_DIR environment is not set, it is set to the current working directory."),
					new GitCommandOption("--initial-branch", "--initial-branch=<branch-name>", @"Use the specified name for the initial branch in the newly created repository.  If not specified, fall back to the default name (currently master, but this is subject to change in the future; the name can be customized via the init.defaultBranch configuration variable)."),
					new GitCommandOption("--object-format", "--object-format=<format>", @"Specify the given object format (hash algorithm) for the repository.  The valid values are sha1 and (if enabled) sha256.  sha1 is the default.  THIS OPTION IS EXPERIMENTAL! SHA-256 support is experimental and still in an early stage.  A SHA-256 repository will in general not be able to share work with ""regular"" SHA-1 repositories.  It should be assumed that, e.g., Git internal file formats in relation to SHA-256 repositories may change in backwards-incompatible ways.  Only use --object-format=sha256 for testing purposes."),
					new GitCommandOption("--quiet", "--quiet", @"Only print error and warning messages; all other output will be suppressed."),
					new GitCommandOption("--separate-git-dir", "--separate-git-dir=<git-dir>", @"Instead of initializing the repository as a directory to either $GIT_DIR or ./.git/, create a text file there containing the path to the actual repository.  This file acts as filesystem-agnostic Git symbolic link to the repository.  If this is reinitialization, the repository will be moved to the specified path."),
					new GitCommandOption("--shared[", "--shared[=(false|true|umask|group|all|world|everybody|<perm>)]", @"Specify that the Git repository is to be shared amongst several users.  This allows users belonging to the same group to push into that repository.  When specified, the config variable ""core.sharedRepository"" is set so that files and directories under $GIT_DIR are created with the requested permissions.  When not specified, Git will use permissions reported by umask.  The option can have the following values, defaulting to group if no value is given:      umask (or false)  Use permissions reported by umask. The default, when --shared is not specified.  group (or true)  Make the repository group-writable, (and g+sx, since the git group may be not the primary group of all users). This is used to loosen the permissions of an otherwise safe umask value. Note that the umask still applies to the other permission bits (e.g. if umask is 0022, using group will not remove read privileges from other (non-group) users). See 0xxx for how to exactly specify the repository permissions.  all (or world or everybody)  Same as group, but make the repository readable by all users.  <perm>  <perm> is a 3-digit octal number prefixed with 0 and each file will have mode <perm>. <perm> will override users' umask value (and not only loosen permissions as group and all does). 0640 will create a repository which is group-readable, but not group-writable or accessible to others. 0660 will create a repo that is readable and writable to the current user and group, but inaccessible to others (directories and executable files get their x bit from the r bit for corresponding classes of users)."),
					new GitCommandOption("--template", "--template=<template-directory>", @"Specify the directory from which templates will be used.  (See the ""TEMPLATE DIRECTORY"" section below.)"),
					new GitCommandOption("-b", "-b <branch-name>", @"Use the specified name for the initial branch in the newly created repository.  If not specified, fall back to the default name (currently master, but this is subject to change in the future; the name can be customized via the init.defaultBranch configuration variable)."),
					new GitCommandOption("-q", "-q", @"Only print error and warning messages; all other output will be suppressed."),
					new GitCommandOption("all", "all (or world or everybody)", @"Same as group, but make the repository readable by all users."),
					new GitCommandOption("group", "group (or true)", @"Make the repository group-writable, (and g+sx, since the git group may be not the primary group of all users). This is used to loosen the permissions of an otherwise safe umask value. Note that the umask still applies to the other permission bits (e.g. if umask is 0022, using group will not remove read privileges from other (non-group) users). See 0xxx for how to exactly specify the repository permissions."),
					new GitCommandOption("umask", "umask (or false)", @"Use permissions reported by umask. The default, when --shared is not specified."),
				}, 
	"instaweb" => new GitCommandOption[] {
					new GitCommandOption("--browser", "--browser", @"The web browser that should be used to view the gitweb page. This will be passed to the git web--browse helper script along with the URL of the gitweb instance. See git-web--browse for more information about this. If the script fails, the URL will be printed to stdout."),
					new GitCommandOption("--httpd", "--httpd", @"The HTTP daemon command-line that will be executed. Command-line options may be specified here, and the configuration file will be added at the end of the command-line. Currently apache2, lighttpd, mongoose, plackup, python and webrick are supported. (Default: lighttpd)"),
					new GitCommandOption("--local", "--local", @"Only bind the web server to the local IP (127.0.0.1)."),
					new GitCommandOption("--module-path", "--module-path", @"The module path (only needed if httpd is Apache). (Default: /usr/lib/apache2/modules)"),
					new GitCommandOption("--port", "--port", @"The port number to bind the httpd to.  (Default: 1234)"),
					new GitCommandOption("--restart", "--restart", @"Restart the httpd instance and exit.  Regenerate configuration files as necessary for spawning a new instance."),
					new GitCommandOption("--start", "--start", @"Start the httpd instance and exit.  Regenerate configuration files as necessary for spawning a new instance."),
					new GitCommandOption("--stop", "--stop", @"Stop the httpd instance and exit.  This does not generate any of the configuration files for spawning a new instance, nor does it close the browser."),
					new GitCommandOption("-b", "-b", @"The web browser that should be used to view the gitweb page. This will be passed to the git web--browse helper script along with the URL of the gitweb instance. See git-web--browse for more information about this. If the script fails, the URL will be printed to stdout."),
					new GitCommandOption("-d", "-d", @"The HTTP daemon command-line that will be executed. Command-line options may be specified here, and the configuration file will be added at the end of the command-line. Currently apache2, lighttpd, mongoose, plackup, python and webrick are supported. (Default: lighttpd)"),
					new GitCommandOption("-l", "-l", @"Only bind the web server to the local IP (127.0.0.1)."),
					new GitCommandOption("-m", "-m", @"The module path (only needed if httpd is Apache). (Default: /usr/lib/apache2/modules)"),
					new GitCommandOption("-p", "-p", @"The port number to bind the httpd to.  (Default: 1234)"),
					new GitCommandOption("restart", "restart", @"Restart the httpd instance and exit.  Regenerate configuration files as necessary for spawning a new instance."),
					new GitCommandOption("start", "start", @"Start the httpd instance and exit.  Regenerate configuration files as necessary for spawning a new instance."),
					new GitCommandOption("stop", "stop", @"Stop the httpd instance and exit.  This does not generate any of the configuration files for spawning a new instance, nor does it close the browser."),
				}, 
	"interpret-trailers" => new GitCommandOption[] {
					new GitCommandOption("--if-exists", "--if-exists <action>", @"Specify what action will be performed when there is already at least one trailer with the same <token> in the message.  A setting provided with --if-exists overrides all configuration variables and applies to all --trailer options until the next occurrence of --if-exists or --no-if-exists. Possible actions are addIfDifferent, addIfDifferentNeighbor, add, replace and doNothing."),
					new GitCommandOption("--if-missing", "--if-missing <action>", @"Specify what action will be performed when there is no other trailer with the same <token> in the message.  A setting provided with --if-missing overrides all configuration variables and applies to all --trailer options until the next occurrence of --if-missing or --no-if-missing. Possible actions are doNothing or add."),
					new GitCommandOption("--in-place", "--in-place", @"Edit the files in place."),
					new GitCommandOption("--no-divider", "--no-divider", @"Do not treat --- as the end of the commit message. Use this when you know your input contains just the commit message itself (and not an email or the output of git format-patch)."),
					new GitCommandOption("--no-if-exists", "--no-if-exists", @"Specify what action will be performed when there is already at least one trailer with the same <token> in the message.  A setting provided with --if-exists overrides all configuration variables and applies to all --trailer options until the next occurrence of --if-exists or --no-if-exists. Possible actions are addIfDifferent, addIfDifferentNeighbor, add, replace and doNothing."),
					new GitCommandOption("--no-if-missing", "--no-if-missing", @"Specify what action will be performed when there is no other trailer with the same <token> in the message.  A setting provided with --if-missing overrides all configuration variables and applies to all --trailer options until the next occurrence of --if-missing or --no-if-missing. Possible actions are doNothing or add."),
					new GitCommandOption("--no-where", "--no-where", @"Specify where all new trailers will be added.  A setting provided with --where overrides all configuration variables and applies to all --trailer options until the next occurrence of --where or --no-where. Possible values are after, before, end or start."),
					new GitCommandOption("--only-input", "--only-input", @"Output only trailers that exist in the input; do not add any from the command-line or by following configured trailer.* rules."),
					new GitCommandOption("--only-trailers", "--only-trailers", @"Output only the trailers, not any other parts of the input."),
					new GitCommandOption("--parse", "--parse", @"A convenience alias for --only-trailers --only-input --unfold."),
					new GitCommandOption("--trailer", "--trailer <token>[(=|:)<value>]", @"Specify a (<token>, <value>) pair that should be applied as a trailer to the input messages. See the description of this command."),
					new GitCommandOption("--trim-empty", "--trim-empty", @"If the <value> part of any trailer contains only whitespace, the whole trailer will be removed from the resulting message. This applies to existing trailers as well as new trailers."),
					new GitCommandOption("--unfold", "--unfold", @"Remove any whitespace-continuation in trailers, so that each trailer appears on a line by itself with its full content."),
					new GitCommandOption("--where", "--where <placement>", @"Specify where all new trailers will be added.  A setting provided with --where overrides all configuration variables and applies to all --trailer options until the next occurrence of --where or --no-where. Possible values are after, before, end or start."),
				}, 
	"log" => new GitCommandOption[] {
					new GitCommandOption("<paths>", "<paths>", @"Commits modifying the given <paths> are selected."),
					new GitCommandOption("<revision-range>", "<revision-range>", @"Show only commits in the specified revision range.  When no <revision-range> is specified, it defaults to HEAD (i.e. the whole history leading to the current commit).  origin..HEAD specifies all the commits reachable from the current commit (i.e. HEAD), but not from origin. For a complete list of ways to spell <revision-range>, see the Specifying Ranges section of gitrevisions."),
					new GitCommandOption("--[no-]mailmap", "--[no-]mailmap", @"Use mailmap file to map author and committer names and email addresses to canonical real names and email addresses. See git-shortlog."),
					new GitCommandOption("--[no-]standard-notes", "--[no-]standard-notes", @"These options are deprecated. Use the above --notes/--no-notes options instead."),
					new GitCommandOption("--[no-]use-mailmap", "--[no-]use-mailmap", @"Use mailmap file to map author and committer names and email addresses to canonical real names and email addresses. See git-shortlog."),
					new GitCommandOption("--abbrev-commit", "--abbrev-commit", @"Instead of showing the full 40-byte hexadecimal commit object name, show a prefix that names the object uniquely. ""--abbrev=<n>"" (which also modifies diff output, if it is displayed) option can be used to specify the minimum length of the prefix.  This should make ""--pretty=oneline"" a whole lot more readable for people using 80-column terminals."),
					new GitCommandOption("--after", "--after=<date>", @"Show commits more recent than a specific date."),
					new GitCommandOption("--all", "--all", @"Pretend as if all the refs in refs/, along with HEAD, are listed on the command line as <commit>."),
					new GitCommandOption("--all-match", "--all-match", @"Limit the commits output to ones that match all given --grep, instead of ones that match at least one."),
					new GitCommandOption("--alternate-refs", "--alternate-refs", @"Pretend as if all objects mentioned as ref tips of alternate repositories were listed on the command line. An alternate repository is any repository whose object directory is specified in objects/info/alternates.  The set of included objects may be modified by core.alternateRefsCommand, etc. See git-config."),
					new GitCommandOption("--ancestry-path", "--ancestry-path", @"Limit the displayed commits to those directly on the ancestry chain between the “from” and “to” commits in the given commit range. I.e. only display commits that are ancestor of the “to” commit and descendants of the “from” commit.  As an example use case, consider the following commit history:                D---E-------F            /     \       \           B---C---G---H---I---J          /                     \         A-------K---------------L--M    A regular D..M computes the set of commits that are ancestors of M, but excludes the ones that are ancestors of D. This is useful to see what happened to the history leading to M since D, in the sense that “what does M have that did not exist in D”. The result in this example would be all the commits, except A and B (and D itself, of course).   When we want to find out what commits in M are contaminated with the bug introduced by D and need fixing, however, we might want to view only the subset of D..M that are actually descendants of D, i.e. excluding C and K. This is exactly what the --ancestry-path option does. Applied to the D..M range, it results in:                    E-------F                  \       \                   G---H---I---J                                \                                 L--M"),
					new GitCommandOption("--ancestry-path", "--ancestry-path", @"When given a range of commits to display (e.g. commit1..commit2 or commit2 ^commit1), only display commits that exist directly on the ancestry chain between the commit1 and commit2, i.e. commits that are both descendants of commit1, and ancestors of commit2."),
					new GitCommandOption("--author", "--author=<pattern>", @"Limit the commits output to ones with author/committer header lines that match the specified pattern (regular expression).  With more than one --author=<pattern>, commits whose author matches any of the given patterns are chosen (similarly for multiple --committer=<pattern>)."),
					new GitCommandOption("--author-date-order", "--author-date-order", @"Show no parents before all of its children are shown, but otherwise show commits in the author timestamp order."),
					new GitCommandOption("--basic-regexp", "--basic-regexp", @"Consider the limiting patterns to be basic regular expressions; this is the default."),
					new GitCommandOption("--before", "--before=<date>", @"Show commits older than a specific date."),
					new GitCommandOption("--bisect", "--bisect", @"Pretend as if the bad bisection ref refs/bisect/bad was listed and as if it was followed by --not and the good bisection refs refs/bisect/good-* on the command line."),
					new GitCommandOption("--boundary", "--boundary", @"Output excluded boundary commits. Boundary commits are prefixed with -."),
					new GitCommandOption("--branches[", "--branches[=<pattern>]", @"Pretend as if all the refs in refs/heads are listed on the command line as <commit>. If <pattern> is given, limit branches to ones matching given shell glob. If pattern lacks ?, *, or [, /* at the end is implied."),
					new GitCommandOption("--cherry", "--cherry", @"A synonym for --right-only --cherry-mark --no-merges; useful to limit the output to the commits on our side and mark those that have been applied to the other side of a forked history with git log --cherry upstream...mybranch, similar to git cherry upstream mybranch."),
					new GitCommandOption("--cherry-mark", "--cherry-mark", @"Like --cherry-pick (see below) but mark equivalent commits with = rather than omitting them, and inequivalent ones with +."),
					new GitCommandOption("--cherry-pick", "--cherry-pick", @"Omit any commit that introduces the same change as another commit on the “other side” when the set of commits are limited with symmetric difference.  For example, if you have two branches, A and B, a usual way to list all commits on only one side of them is with --left-right (see the example below in the description of the --left-right option). However, it shows the commits that were cherry-picked from the other branch (for example, “3rd on b” may be cherry-picked from branch A). With this option, such pairs of commits are excluded from the output."),
					new GitCommandOption("--children", "--children", @"Print also the children of the commit (in the form ""commit child…​""). Also enables parent rewriting, see History Simplification above."),
					new GitCommandOption("--committer", "--committer=<pattern>", @"Limit the commits output to ones with author/committer header lines that match the specified pattern (regular expression).  With more than one --author=<pattern>, commits whose author matches any of the given patterns are chosen (similarly for multiple --committer=<pattern>)."),
					new GitCommandOption("--date", "--date=<format>", @"Only takes effect for dates shown in human-readable format, such as when using --pretty. log.date config variable sets a default value for the log command’s --date option. By default, dates are shown in the original time zone (either committer’s or author’s). If -local is appended to the format (e.g., iso-local), the user’s local time zone is used instead.    --date=relative shows dates relative to the current time, e.g. “2 hours ago”. The -local option has no effect for --date=relative.   --date=local is an alias for --date=default-local.   --date=iso (or --date=iso8601) shows timestamps in a ISO 8601-like format. The differences to the strict ISO 8601 format are:     a space instead of the T date/time delimiter   a space between time and time zone   no colon between hours and minutes of the time zone     --date=iso-strict (or --date=iso8601-strict) shows timestamps in strict ISO 8601 format.   --date=rfc (or --date=rfc2822) shows timestamps in RFC 2822 format, often found in email messages.   --date=short shows only the date, but not the time, in YYYY-MM-DD format.   --date=raw shows the date as seconds since the epoch (1970-01-01 00:00:00 UTC), followed by a space, and then the timezone as an offset from UTC (a + or - with four digits; the first two are hours, and the second two are minutes). I.e., as if the timestamp were formatted with strftime(""%s %z"")). Note that the -local option does not affect the seconds-since-epoch value (which is always measured in UTC), but does switch the accompanying timezone value.   --date=human shows the timezone if the timezone does not match the current time-zone, and doesn’t print the whole date if that matches (ie skip printing year for dates that are ""this year"", but also skip the whole date itself if it’s in the last few days and we can just say what weekday it was).  For older dates the hour and minute is also omitted.   --date=unix shows the date as a Unix epoch timestamp (seconds since 1970).  As with --raw, this is always in UTC and therefore -local has no effect.   --date=format:... feeds the format ... to your system strftime, except for %s, %z, and %Z, which are handled internally. Use --date=format:%c to show the date in your system locale’s preferred format.  See the strftime manual for a complete list of format placeholders. When using -local, the correct syntax is --date=format-local:....   --date=default is the default format, and is similar to --date=rfc2822, with a few exceptions:       there is no comma after the day-of-week   the time zone is omitted when the local time zone is used"),
					new GitCommandOption("--date-order", "--date-order", @"Show no parents before all of its children are shown, but otherwise show commits in the commit timestamp order."),
					new GitCommandOption("--decorate-refs", "--decorate-refs=<pattern>", @"If no --decorate-refs is given, pretend as if all refs were included.  For each candidate, do not use it for decoration if it matches any patterns given to --decorate-refs-exclude or if it doesn’t match any of the patterns given to --decorate-refs. The log.excludeDecoration config option allows excluding refs from the decorations, but an explicit --decorate-refs pattern will override a match in log.excludeDecoration."),
					new GitCommandOption("--decorate-refs-exclude", "--decorate-refs-exclude=<pattern>", @"If no --decorate-refs is given, pretend as if all refs were included.  For each candidate, do not use it for decoration if it matches any patterns given to --decorate-refs-exclude or if it doesn’t match any of the patterns given to --decorate-refs. The log.excludeDecoration config option allows excluding refs from the decorations, but an explicit --decorate-refs pattern will override a match in log.excludeDecoration."),
					new GitCommandOption("--decorate[", "--decorate[=short|full|auto|no]", @"Print out the ref names of any commits that are shown. If short is specified, the ref name prefixes refs/heads/, refs/tags/ and refs/remotes/ will not be printed. If full is specified, the full ref name (including prefix) will be printed. If auto is specified, then if the output is going to a terminal, the ref names are shown as if short were given, otherwise no ref names are shown. The option --decorate is short-hand for --decorate=short. Default to configuration value of log.decorate if configured, otherwise, auto."),
					new GitCommandOption("--dense", "--dense", @"Commits that are walked are included if they are not TREESAME to any parent."),
					new GitCommandOption("--dense", "--dense", @"Only the selected commits are shown, plus some to have a meaningful history."),
					new GitCommandOption("--do-walk", "--do-walk", @"Overrides a previous --no-walk."),
					new GitCommandOption("--encoding", "--encoding=<encoding>", @"Commit objects record the character encoding used for the log message in their encoding header; this option can be used to tell the command to re-code the commit log message in the encoding preferred by the user.  For non plumbing commands this defaults to UTF-8. Note that if an object claims to be encoded in X and we are outputting in X, we will output the object verbatim; this means that invalid sequences in the original commit may be copied to the output. Likewise, if iconv fails to convert the commit, we will quietly output the original object verbatim."),
					new GitCommandOption("--exclude", "--exclude=<glob-pattern>", @"Do not include refs matching <glob-pattern> that the next --all, --branches, --tags, --remotes, or --glob would otherwise consider. Repetitions of this option accumulate exclusion patterns up to the next --all, --branches, --tags, --remotes, or --glob option (other options or arguments do not clear accumulated patterns).  The patterns given should not begin with refs/heads, refs/tags, or refs/remotes when applied to --branches, --tags, or --remotes, respectively, and they must begin with refs/ when applied to --glob or --all. If a trailing /* is intended, it must be given explicitly."),
					new GitCommandOption("--exclude-first-parent-only", "--exclude-first-parent-only", @"When finding commits to exclude (with a ^), follow only the first parent commit upon seeing a merge commit. This can be used to find the set of changes in a topic branch from the point where it diverged from the remote branch, given that arbitrary merges can be valid topic branch changes."),
					new GitCommandOption("--expand-tabs", "--expand-tabs=<n>", @"Perform a tab expansion (replace each tab with enough spaces to fill to the next display column that is multiple of <n>) in the log message before showing it in the output. --expand-tabs is a short-hand for --expand-tabs=8, and --no-expand-tabs is a short-hand for --expand-tabs=0, which disables tab expansion.  By default, tabs are expanded in pretty formats that indent the log message by 4 spaces (i.e.  medium, which is the default, full, and fuller)."),
					new GitCommandOption("--expand-tabs", "--expand-tabs", @"Perform a tab expansion (replace each tab with enough spaces to fill to the next display column that is multiple of <n>) in the log message before showing it in the output. --expand-tabs is a short-hand for --expand-tabs=8, and --no-expand-tabs is a short-hand for --expand-tabs=0, which disables tab expansion.  By default, tabs are expanded in pretty formats that indent the log message by 4 spaces (i.e.  medium, which is the default, full, and fuller)."),
					new GitCommandOption("--extended-regexp", "--extended-regexp", @"Consider the limiting patterns to be extended regular expressions instead of the default basic regular expressions."),
					new GitCommandOption("--first-parent", "--first-parent", @"When finding commits to include, follow only the first parent commit upon seeing a merge commit.  This option can give a better overview when viewing the evolution of a particular topic branch, because merges into a topic branch tend to be only about adjusting to updated upstream from time to time, and this option allows you to ignore the individual commits brought in to your history by such a merge.  This option also changes default diff format for merge commits to first-parent, see --diff-merges=first-parent for details."),
					new GitCommandOption("--fixed-strings", "--fixed-strings", @"Consider the limiting patterns to be fixed strings (don’t interpret pattern as a regular expression)."),
					new GitCommandOption("--follow", "--follow", @"Continue listing the history of a file beyond renames (works only for a single file)."),
					new GitCommandOption("--format", "--format=<format>", @"Pretty-print the contents of the commit logs in a given format, where <format> can be one of oneline, short, medium, full, fuller, reference, email, raw, format:<string> and tformat:<string>.  When <format> is none of the above, and has %placeholder in it, it acts as if --pretty=tformat:<format> were given.  See the ""PRETTY FORMATS"" section for some additional details for each format.  When =<format> part is omitted, it defaults to medium.   Note: you can specify the default pretty format in the repository configuration (see git-config)."),
					new GitCommandOption("--full-diff", "--full-diff", @"Without this flag, git log -p <path>... shows commits that touch the specified paths, and diffs about the same specified paths.  With this, the full diff is shown for commits that touch the specified paths; this means that ""<path>…​"" limits only commits, and doesn’t limit diff for those commits.  Note that this affects all diff-based output types, e.g. those produced by --stat, etc."),
					new GitCommandOption("--full-history", "--full-history without parent rewriting", @"This mode differs from the default in one point: always follow all parents of a merge, even if it is TREESAME to one of them. Even if more than one side of the merge has commits that are included, this does not imply that the merge itself is!  In the example, we get           I  A  B  N  D  O  P  Q    M was excluded because it is TREESAME to both parents.  E, C and B were all walked, but only B was !TREESAME, so the others do not appear.   Note that without parent rewriting, it is not really possible to talk about the parent/child relationships between the commits, so we show them disconnected."),
					new GitCommandOption("--full-history", "--full-history", @"Same as the default mode, but does not prune some history."),
					new GitCommandOption("--full-history", "--full-history with parent rewriting", @"Ordinary commits are only included if they are !TREESAME (though this can be changed, see --sparse below).  Merges are always included.  However, their parent list is rewritten: Along each parent, prune away commits that are not included themselves.  This results in              .-A---M---N---O---P---Q          /     /   /   /   /         I     B   /   D   /          \   /   /   /   /           `-------------'    Compare to --full-history without rewriting above.  Note that E was pruned away because it is TREESAME, but the parent list of P was rewritten to contain E's parent I.  The same happened for C and N, and X, Y and Q."),
					new GitCommandOption("--glob", "--glob=<glob-pattern>", @"Pretend as if all the refs matching shell glob <glob-pattern> are listed on the command line as <commit>. Leading refs/, is automatically prepended if missing. If pattern lacks ?, *, or [, /* at the end is implied."),
					new GitCommandOption("--graph", "--graph", @"Draw a text-based graphical representation of the commit history on the left hand side of the output.  This may cause extra lines to be printed in between commits, in order for the graph history to be drawn properly. Cannot be combined with --no-walk.  This enables parent rewriting, see History Simplification above.   This implies the --topo-order option by default, but the --date-order option may also be specified."),
					new GitCommandOption("--grep", "--grep=<pattern>", @"Limit the commits output to ones with log message that matches the specified pattern (regular expression).  With more than one --grep=<pattern>, commits whose message matches any of the given patterns are chosen (but see --all-match).  When --notes is in effect, the message from the notes is matched as if it were part of the log message."),
					new GitCommandOption("--grep-reflog", "--grep-reflog=<pattern>", @"Limit the commits output to ones with reflog entries that match the specified pattern (regular expression). With more than one --grep-reflog, commits whose reflog message matches any of the given patterns are chosen.  It is an error to use this option unless --walk-reflogs is in use."),
					new GitCommandOption("--ignore-missing", "--ignore-missing", @"Upon seeing an invalid object name in the input, pretend as if the bad input was not given."),
					new GitCommandOption("--invert-grep", "--invert-grep", @"Limit the commits output to ones with log message that do not match the pattern specified with --grep=<pattern>."),
					new GitCommandOption("--left-only", "--left-only", @"List only commits on the respective side of a symmetric difference, i.e. only those which would be marked < resp. > by --left-right.  For example, --cherry-pick --right-only A...B omits those commits from B which are in A or are patch-equivalent to a commit in A. In other words, this lists the + commits from git cherry A B. More precisely, --cherry-pick --right-only --no-merges gives the exact list."),
					new GitCommandOption("--left-right", "--left-right", @"Mark which side of a symmetric difference a commit is reachable from. Commits from the left side are prefixed with < and those from the right with >.  If combined with --boundary, those commits are prefixed with -.  For example, if you have this topology:                 y---b---b  branch B             / \ /            /   .           /   / \          o---x---a---a  branch A    you would get an output like this:            $ git rev-list --left-right --boundary --pretty=oneline A...B          >bbbbbbb... 3rd on b         >bbbbbbb... 2nd on b         <aaaaaaa... 3rd on a         <aaaaaaa... 2nd on a         -yyyyyyy... 1st on b         -xxxxxxx... 1st on a"),
					new GitCommandOption("--log-size", "--log-size", @"Include a line “log size <number>” in the output for each commit, where <number> is the length of that commit’s message in bytes. Intended to speed up tools that read log messages from git log output by allowing them to allocate space in advance."),
					new GitCommandOption("--max-count", "--max-count=<number>", @"Limit the number of commits to output."),
					new GitCommandOption("--max-parents", "--max-parents=<number>", @"Show only commits which have at least (or at most) that many parent commits. In particular, --max-parents=1 is the same as --no-merges, --min-parents=2 is the same as --merges.  --max-parents=0 gives all root commits and --min-parents=3 all octopus merges.  --no-min-parents and --no-max-parents reset these limits (to no limit) again.  Equivalent forms are --min-parents=0 (any commit has 0 or more parents) and --max-parents=-1 (negative numbers denote no upper limit)."),
					new GitCommandOption("--merge", "--merge", @"After a failed merge, show refs that touch files having a conflict and don’t exist on all heads to merge."),
					new GitCommandOption("--merges", "--merges", @"Print only merge commits. This is exactly the same as --min-parents=2."),
					new GitCommandOption("--min-parents", "--min-parents=<number>", @"Show only commits which have at least (or at most) that many parent commits. In particular, --max-parents=1 is the same as --no-merges, --min-parents=2 is the same as --merges.  --max-parents=0 gives all root commits and --min-parents=3 all octopus merges.  --no-min-parents and --no-max-parents reset these limits (to no limit) again.  Equivalent forms are --min-parents=0 (any commit has 0 or more parents) and --max-parents=-1 (negative numbers denote no upper limit)."),
					new GitCommandOption("--no-abbrev-commit", "--no-abbrev-commit", @"Show the full 40-byte hexadecimal commit object name. This negates --abbrev-commit, either explicit or implied by other options such as ""--oneline"". It also overrides the log.abbrevCommit variable."),
					new GitCommandOption("--no-decorate", "--no-decorate", @"Print out the ref names of any commits that are shown. If short is specified, the ref name prefixes refs/heads/, refs/tags/ and refs/remotes/ will not be printed. If full is specified, the full ref name (including prefix) will be printed. If auto is specified, then if the output is going to a terminal, the ref names are shown as if short were given, otherwise no ref names are shown. The option --decorate is short-hand for --decorate=short. Default to configuration value of log.decorate if configured, otherwise, auto."),
					new GitCommandOption("--no-expand-tabs", "--no-expand-tabs", @"Perform a tab expansion (replace each tab with enough spaces to fill to the next display column that is multiple of <n>) in the log message before showing it in the output. --expand-tabs is a short-hand for --expand-tabs=8, and --no-expand-tabs is a short-hand for --expand-tabs=0, which disables tab expansion.  By default, tabs are expanded in pretty formats that indent the log message by 4 spaces (i.e.  medium, which is the default, full, and fuller)."),
					new GitCommandOption("--no-max-parents", "--no-max-parents", @"Show only commits which have at least (or at most) that many parent commits. In particular, --max-parents=1 is the same as --no-merges, --min-parents=2 is the same as --merges.  --max-parents=0 gives all root commits and --min-parents=3 all octopus merges.  --no-min-parents and --no-max-parents reset these limits (to no limit) again.  Equivalent forms are --min-parents=0 (any commit has 0 or more parents) and --max-parents=-1 (negative numbers denote no upper limit)."),
					new GitCommandOption("--no-merges", "--no-merges", @"Do not print commits with more than one parent. This is exactly the same as --max-parents=1."),
					new GitCommandOption("--no-min-parents", "--no-min-parents", @"Show only commits which have at least (or at most) that many parent commits. In particular, --max-parents=1 is the same as --no-merges, --min-parents=2 is the same as --merges.  --max-parents=0 gives all root commits and --min-parents=3 all octopus merges.  --no-min-parents and --no-max-parents reset these limits (to no limit) again.  Equivalent forms are --min-parents=0 (any commit has 0 or more parents) and --max-parents=-1 (negative numbers denote no upper limit)."),
					new GitCommandOption("--no-notes", "--no-notes", @"Do not show notes. This negates the above --notes option, by resetting the list of notes refs from which notes are shown. Options are parsed in the order given on the command line, so e.g. ""--notes --notes=foo --no-notes --notes=bar"" will only show notes from ""refs/notes/bar""."),
					new GitCommandOption("--no-walk[", "--no-walk[=(sorted|unsorted)]", @"Only show the given commits, but do not traverse their ancestors. This has no effect if a range is specified. If the argument unsorted is given, the commits are shown in the order they were given on the command line. Otherwise (if sorted or no argument was given), the commits are shown in reverse chronological order by commit time. Cannot be combined with --graph."),
					new GitCommandOption("--not", "--not", @"Reverses the meaning of the ^ prefix (or lack thereof) for all following revision specifiers, up to the next --not."),
					new GitCommandOption("--notes[", "--notes[=<ref>]", @"Show the notes (see git-notes) that annotate the commit, when showing the commit log message.  This is the default for git log, git show and git whatchanged commands when there is no --pretty, --format, or --oneline option given on the command line.  By default, the notes shown are from the notes refs listed in the core.notesRef and notes.displayRef variables (or corresponding environment overrides). See git-config for more details.   With an optional <ref> argument, use the ref to find the notes to display.  The ref can specify the full refname when it begins with refs/notes/; when it begins with notes/, refs/ and otherwise refs/notes/ is prefixed to form a full name of the ref.   Multiple --notes options can be combined to control which notes are being displayed. Examples: ""--notes=foo"" will show only notes from ""refs/notes/foo""; ""--notes=foo --notes"" will show both notes from ""refs/notes/foo"" and from the default notes ref(s)."),
					new GitCommandOption("--oneline", "--oneline", @"This is a shorthand for ""--pretty=oneline --abbrev-commit"" used together."),
					new GitCommandOption("--parents", "--parents", @"Print also the parents of the commit (in the form ""commit parent…​""). Also enables parent rewriting, see History Simplification above."),
					new GitCommandOption("--perl-regexp", "--perl-regexp", @"Consider the limiting patterns to be Perl-compatible regular expressions.  Support for these types of regular expressions is an optional compile-time dependency. If Git wasn’t compiled with support for them providing this option will cause it to die."),
					new GitCommandOption("--pretty[", "--pretty[=<format>]", @"Pretty-print the contents of the commit logs in a given format, where <format> can be one of oneline, short, medium, full, fuller, reference, email, raw, format:<string> and tformat:<string>.  When <format> is none of the above, and has %placeholder in it, it acts as if --pretty=tformat:<format> were given.  See the ""PRETTY FORMATS"" section for some additional details for each format.  When =<format> part is omitted, it defaults to medium.   Note: you can specify the default pretty format in the repository configuration (see git-config)."),
					new GitCommandOption("--reflog", "--reflog", @"Pretend as if all objects mentioned by reflogs are listed on the command line as <commit>."),
					new GitCommandOption("--regexp-ignore-case", "--regexp-ignore-case", @"Match the regular expression limiting patterns without regard to letter case."),
					new GitCommandOption("--relative-date", "--relative-date", @"Synonym for --date=relative."),
					new GitCommandOption("--remotes[", "--remotes[=<pattern>]", @"Pretend as if all the refs in refs/remotes are listed on the command line as <commit>. If <pattern> is given, limit remote-tracking branches to ones matching given shell glob. If pattern lacks ?, *, or [, /* at the end is implied."),
					new GitCommandOption("--remove-empty", "--remove-empty", @"Stop when a given path disappears from the tree."),
					new GitCommandOption("--reverse", "--reverse", @"Output the commits chosen to be shown (see Commit Limiting section above) in reverse order. Cannot be combined with --walk-reflogs."),
					new GitCommandOption("--right-only", "--right-only", @"List only commits on the respective side of a symmetric difference, i.e. only those which would be marked < resp. > by --left-right.  For example, --cherry-pick --right-only A...B omits those commits from B which are in A or are patch-equivalent to a commit in A. In other words, this lists the + commits from git cherry A B. More precisely, --cherry-pick --right-only --no-merges gives the exact list."),
					new GitCommandOption("--show-linear-break[", "--show-linear-break[=<barrier>]", @"When --graph is not used, all history branches are flattened which can make it hard to see that the two consecutive commits do not belong to a linear branch. This option puts a barrier in between them in that case. If <barrier> is specified, it is the string that will be shown instead of the default one."),
					new GitCommandOption("--show-notes[", "--show-notes[=<ref>]", @"These options are deprecated. Use the above --notes/--no-notes options instead."),
					new GitCommandOption("--show-pulls", "--show-pulls", @"In addition to the commits shown in the default history, show each merge commit that is not TREESAME to its first parent but is TREESAME to a later parent.  When a merge commit is included by --show-pulls, the merge is treated as if it ""pulled"" the change from another branch. When using --show-pulls on this example (and no other options) the resulting graph is:            I---X---R---N    Here, the merge commits R and N are included because they pulled the commits X and R into the base branch, respectively. These merges are the reason the commits A and B do not appear in the default history.   When --show-pulls is paired with --simplify-merges, the graph includes all of the necessary information:              .-A---M--.   N          /     /    \ /         I     B      R          \   /      /           \ /      /            `---X--'    Notice that since M is reachable from R, the edge from N to M was simplified away. However, N still appears in the history as an important commit because it ""pulled"" the change R into the main branch."),
					new GitCommandOption("--show-pulls", "--show-pulls", @"Include all commits from the default mode, but also any merge commits that are not TREESAME to the first parent but are TREESAME to a later parent. This mode is helpful for showing the merge commits that ""first introduced"" a change to a branch."),
					new GitCommandOption("--show-signature", "--show-signature", @"Check the validity of a signed commit object by passing the signature to gpg --verify and show the output."),
					new GitCommandOption("--simplify-by-decoration", "--simplify-by-decoration", @"Commits that are referred by some branch or tag are selected."),
					new GitCommandOption("--simplify-merges", "--simplify-merges", @"First, build a history graph in the same way that --full-history with parent rewriting does (see above).  Then simplify each commit C to its replacement C' in the final history according to the following rules:       Set C' to C.   Replace each parent P of C' with its simplification P'.  In the process, drop parents that are ancestors of other parents or that are root commits TREESAME to an empty tree, and remove duplicates, but take care to never drop all parents that we are TREESAME to.   If after this parent rewriting, C' is a root or merge commit (has zero or >1 parents), a boundary commit, or !TREESAME, it remains. Otherwise, it is replaced with its only parent.       The effect of this is best shown by way of comparing to --full-history with parent rewriting.  The example turns into:              .-A---M---N---O          /     /       /         I     B       D          \   /       /           `---------'    Note the major differences in N, P, and Q over --full-history:       N's parent list had I removed, because it is an ancestor of the other parent M.  Still, N remained because it is !TREESAME.   P's parent list similarly had I removed.  P was then removed completely, because it had one parent and is TREESAME.   Q's parent list had Y simplified to X. X was then removed, because it was a TREESAME root. Q was then removed completely, because it had one parent and is TREESAME."),
					new GitCommandOption("--simplify-merges", "--simplify-merges", @"Additional option to --full-history to remove some needless merges from the resulting history, as there are no selected commits contributing to this merge."),
					new GitCommandOption("--since", "--since=<date>", @"Show commits more recent than a specific date."),
					new GitCommandOption("--single-worktree", "--single-worktree", @"By default, all working trees will be examined by the following options when there are more than one (see git-worktree): --all, --reflog and --indexed-objects. This option forces them to examine the current working tree only."),
					new GitCommandOption("--skip", "--skip=<number>", @"Skip number commits before starting to show the commit output."),
					new GitCommandOption("--source", "--source", @"Print out the ref name given on the command line by which each commit was reached."),
					new GitCommandOption("--sparse", "--sparse", @"All commits in the simplified history are shown."),
					new GitCommandOption("--sparse", "--sparse", @"All commits that are walked are included.  Note that without --full-history, this still simplifies merges: if one of the parents is TREESAME, we follow only that one, so the other sides of the merge are never walked."),
					new GitCommandOption("--stdin", "--stdin", @"In addition to the <commit> listed on the command line, read them from the standard input. If a -- separator is seen, stop reading commits and start reading paths to limit the result."),
					new GitCommandOption("--tags[", "--tags[=<pattern>]", @"Pretend as if all the refs in refs/tags are listed on the command line as <commit>. If <pattern> is given, limit tags to ones matching given shell glob. If pattern lacks ?, *, or [, /* at the end is implied."),
					new GitCommandOption("--topo-order", "--topo-order", @"Show no parents before all of its children are shown, and avoid showing commits on multiple lines of history intermixed.  For example, in a commit history like this:        ---1----2----4----7         \              \          3----5----6----8---    where the numbers denote the order of commit timestamps, git rev-list and friends with --date-order show the commits in the timestamp order: 8 7 6 5 4 3 2 1.   With --topo-order, they would show 8 6 5 3 7 4 2 1 (or 8 7 4 2 6 5 3 1); some older commits are shown before newer ones in order to avoid showing the commits from two parallel development track mixed together."),
					new GitCommandOption("--until", "--until=<date>", @"Show commits older than a specific date."),
					new GitCommandOption("--walk-reflogs", "--walk-reflogs", @"Instead of walking the commit ancestry chain, walk reflog entries from the most recent one to older ones. When this option is used you cannot specify commits to exclude (that is, ^commit, commit1..commit2, and commit1...commit2 notations cannot be used).  With --pretty format other than oneline and reference (for obvious reasons), this causes the output to have two extra lines of information taken from the reflog.  The reflog designator in the output may be shown as ref@{Nth} (where Nth is the reverse-chronological index in the reflog) or as ref@{timestamp} (with the timestamp for that entry), depending on a few rules:       If the starting point is specified as ref@{Nth}, show the index format.   If the starting point was specified as ref@{now}, show the timestamp format.   If neither was used, but --date was given on the command line, show the timestamp in the format requested by --date.   Otherwise, show the index format.       Under --pretty=oneline, the commit message is prefixed with this information on the same line. This option cannot be combined with --reverse. See also git-reflog.   Under --pretty=reference, this information will not be shown at all."),
					new GitCommandOption("-<number>", "-<number>", @"Limit the number of commits to output."),
					new GitCommandOption("-E", "-E", @"Consider the limiting patterns to be extended regular expressions instead of the default basic regular expressions."),
					new GitCommandOption("-F", "-F", @"Consider the limiting patterns to be fixed strings (don’t interpret pattern as a regular expression)."),
					new GitCommandOption("-g", "-g", @"Instead of walking the commit ancestry chain, walk reflog entries from the most recent one to older ones. When this option is used you cannot specify commits to exclude (that is, ^commit, commit1..commit2, and commit1...commit2 notations cannot be used).  With --pretty format other than oneline and reference (for obvious reasons), this causes the output to have two extra lines of information taken from the reflog.  The reflog designator in the output may be shown as ref@{Nth} (where Nth is the reverse-chronological index in the reflog) or as ref@{timestamp} (with the timestamp for that entry), depending on a few rules:       If the starting point is specified as ref@{Nth}, show the index format.   If the starting point was specified as ref@{now}, show the timestamp format.   If neither was used, but --date was given on the command line, show the timestamp in the format requested by --date.   Otherwise, show the index format.       Under --pretty=oneline, the commit message is prefixed with this information on the same line. This option cannot be combined with --reverse. See also git-reflog.   Under --pretty=reference, this information will not be shown at all."),
					new GitCommandOption("-i", "-i", @"Match the regular expression limiting patterns without regard to letter case."),
					new GitCommandOption("-L:<funcname>:<file>", "-L:<funcname>:<file>", @"Trace the evolution of the line range given by <start>,<end>, or by the function name regex <funcname>, within the <file>. You may not give any pathspec limiters.  This is currently limited to a walk starting from a single revision, i.e., you may only give zero or one positive revision arguments, and <start> and <end> (or <funcname>) must exist in the starting revision. You can specify this option more than once. Implies --patch. Patch output can be suppressed using --no-patch, but other diff formats (namely --raw, --numstat, --shortstat, --dirstat, --summary, --name-only, --name-status, --check) are not currently implemented.  <start> and <end> can take one of these forms:     number  If <start> or <end> is a number, it specifies an absolute line number (lines count from 1).    /regex/  This form will use the first line matching the given POSIX regex. If <start> is a regex, it will search from the end of the previous -L range, if any, otherwise from the start of file. If <start> is ^/regex/, it will search from the start of file. If <end> is a regex, it will search starting at the line given by <start>.    +offset or -offset  This is only valid for <end> and will specify a number of lines before or after the line given by <start>.      If :<funcname> is given in place of <start> and <end>, it is a regular expression that denotes the range from the first funcname line that matches <funcname>, up to the next funcname line. :<funcname> searches from the end of the previous -L range, if any, otherwise from the start of file. ^:<funcname> searches from the start of file. The function names are determined in the same way as git diff works out patch hunk headers (see Defining a custom hunk-header in gitattributes)."),
					new GitCommandOption("-L<start>,<end>:<file>", "-L<start>,<end>:<file>", @"Trace the evolution of the line range given by <start>,<end>, or by the function name regex <funcname>, within the <file>. You may not give any pathspec limiters.  This is currently limited to a walk starting from a single revision, i.e., you may only give zero or one positive revision arguments, and <start> and <end> (or <funcname>) must exist in the starting revision. You can specify this option more than once. Implies --patch. Patch output can be suppressed using --no-patch, but other diff formats (namely --raw, --numstat, --shortstat, --dirstat, --summary, --name-only, --name-status, --check) are not currently implemented.  <start> and <end> can take one of these forms:     number  If <start> or <end> is a number, it specifies an absolute line number (lines count from 1).    /regex/  This form will use the first line matching the given POSIX regex. If <start> is a regex, it will search from the end of the previous -L range, if any, otherwise from the start of file. If <start> is ^/regex/, it will search from the start of file. If <end> is a regex, it will search starting at the line given by <start>.    +offset or -offset  This is only valid for <end> and will specify a number of lines before or after the line given by <start>.      If :<funcname> is given in place of <start> and <end>, it is a regular expression that denotes the range from the first funcname line that matches <funcname>, up to the next funcname line. :<funcname> searches from the end of the previous -L range, if any, otherwise from the start of file. ^:<funcname> searches from the start of file. The function names are determined in the same way as git diff works out patch hunk headers (see Defining a custom hunk-header in gitattributes)."),
					new GitCommandOption("-n", "-n <number>", @"Limit the number of commits to output."),
					new GitCommandOption("-P", "-P", @"Consider the limiting patterns to be Perl-compatible regular expressions.  Support for these types of regular expressions is an optional compile-time dependency. If Git wasn’t compiled with support for them providing this option will cause it to die."),
					new GitCommandOption("[--]", "[--] <path>…​", @"Show only commits that are enough to explain how the files that match the specified paths came to be.  See History Simplification below for details and other simplification modes.  Paths may need to be prefixed with -- to separate them from options or the revision range, when confusion arises."),
					new GitCommandOption("Default", "Default mode", @"Simplifies the history to the simplest history explaining the final state of the tree. Simplest because it prunes some side branches if the end result is the same (i.e. merging branches with the same content)"),
					new GitCommandOption("Default", "Default mode", @"Commits are included if they are not TREESAME to any parent (though this can be changed, see --sparse below).  If the commit was a merge, and it was TREESAME to one parent, follow only that parent.  (Even if there are several TREESAME parents, follow only one of them.)  Otherwise, follow all parents.  This results in:              .-A---N---O          /     /   /         I---------D    Note how the rule to only follow the TREESAME parent, if one is available, removed B from consideration entirely.  C was considered via N, but is TREESAME.  Root commits are compared to an empty tree, so I is !TREESAME.   Parent/child relations are only visible with --parents, but that does not affect the commits selected in default mode, so we have shown the parent lines."),
				}, 
	"ls-files" => new GitCommandOption[] {
					new GitCommandOption("<file>", "<file>", @"Files to show. If no files are given all files which match the other specified criteria are shown."),
					new GitCommandOption("--", "--", @"Do not interpret any more arguments as options."),
					new GitCommandOption("--abbrev[", "--abbrev[=<n>]", @"Instead of showing the full 40-byte hexadecimal object lines, show the shortest prefix that is at least <n> hexdigits long that uniquely refers the object. Non default number of digits can be specified with --abbrev=<n>."),
					new GitCommandOption("--cached", "--cached", @"Show cached files in the output (default)"),
					new GitCommandOption("--debug", "--debug", @"After each line that describes a file, add more data about its cache entry.  This is intended to show as much information as possible for manual inspection; the exact format may change at any time."),
					new GitCommandOption("--deduplicate", "--deduplicate", @"When only filenames are shown, suppress duplicates that may come from having multiple stages during a merge, or giving --deleted and --modified option at the same time. When any of the -t, --unmerged, or --stage option is in use, this option has no effect."),
					new GitCommandOption("--deleted", "--deleted", @"Show deleted files in the output"),
					new GitCommandOption("--directory", "--directory", @"If a whole directory is classified as ""other"", show just its name (with a trailing slash) and not its whole contents."),
					new GitCommandOption("--eol", "--eol", @"Show <eolinfo> and <eolattr> of files. <eolinfo> is the file content identification used by Git when the ""text"" attribute is ""auto"" (or not set and core.autocrlf is not false). <eolinfo> is either ""-text"", ""none"", ""lf"", ""crlf"", ""mixed"" or """".  """" means the file is not a regular file, it is not in the index or not accessible in the working tree.   <eolattr> is the attribute that is used when checking out or committing, it is either """", ""-text"", ""text"", ""text=auto"", ""text eol=lf"", ""text eol=crlf"". Since Git 2.10 ""text=auto eol=lf"" and ""text=auto eol=crlf"" are supported.   Both the <eolinfo> in the index (""i/<eolinfo>"") and in the working tree (""w/<eolinfo>"") are shown for regular files, followed by the  (""attr/<eolattr>"")."),
					new GitCommandOption("--error-unmatch", "--error-unmatch", @"If any <file> does not appear in the index, treat this as an error (return 1)."),
					new GitCommandOption("--exclude", "--exclude=<pattern>", @"Skip untracked files matching pattern. Note that pattern is a shell wildcard pattern. See EXCLUDE PATTERNS below for more information."),
					new GitCommandOption("--exclude-from", "--exclude-from=<file>", @"Read exclude patterns from <file>; 1 per line."),
					new GitCommandOption("--exclude-per-directory", "--exclude-per-directory=<file>", @"Read additional exclude patterns that apply only to the directory and its subdirectories in <file>."),
					new GitCommandOption("--exclude-standard", "--exclude-standard", @"Add the standard Git exclusions: .git/info/exclude, .gitignore in each directory, and the user’s global exclusion file."),
					new GitCommandOption("--full-name", "--full-name", @"When run from a subdirectory, the command usually outputs paths relative to the current directory.  This option forces paths to be output relative to the project top directory."),
					new GitCommandOption("--ignored", "--ignored", @"Show only ignored files in the output. When showing files in the index, print only those matched by an exclude pattern. When showing ""other"" files, show only those matched by an exclude pattern. Standard ignore rules are not automatically activated, therefore at least one of the --exclude* options is required."),
					new GitCommandOption("--killed", "--killed", @"Show files on the filesystem that need to be removed due to file/directory conflicts for checkout-index to succeed."),
					new GitCommandOption("--modified", "--modified", @"Show modified files in the output"),
					new GitCommandOption("--no-empty-directory", "--no-empty-directory", @"Do not list empty directories. Has no effect without --directory."),
					new GitCommandOption("--others", "--others", @"Show other (i.e. untracked) files in the output"),
					new GitCommandOption("--recurse-submodules", "--recurse-submodules", @"Recursively calls ls-files on each active submodule in the repository. Currently there is only support for the --cached and --stage modes."),
					new GitCommandOption("--sparse", "--sparse", @"If the index is sparse, show the sparse directories without expanding to the contained files. Sparse directories will be shown with a trailing slash, such as ""x/"" for a sparse directory ""x""."),
					new GitCommandOption("--stage", "--stage", @"Show staged contents' mode bits, object name and stage number in the output."),
					new GitCommandOption("--unmerged", "--unmerged", @"Show unmerged files in the output (forces --stage)"),
					new GitCommandOption("--with-tree", "--with-tree=<tree-ish>", @"When using --error-unmatch to expand the user supplied <file> (i.e. path pattern) arguments to paths, pretend that paths which were removed in the index since the named <tree-ish> are still present.  Using this option with -s or -u options does not make any sense."),
					new GitCommandOption("-c", "-c", @"Show cached files in the output (default)"),
					new GitCommandOption("-d", "-d", @"Show deleted files in the output"),
					new GitCommandOption("-f", "-f", @"Similar to -t, but use lowercase letters for files that are marked as fsmonitor valid (see git-update-index)."),
					new GitCommandOption("-i", "-i", @"Show only ignored files in the output. When showing files in the index, print only those matched by an exclude pattern. When showing ""other"" files, show only those matched by an exclude pattern. Standard ignore rules are not automatically activated, therefore at least one of the --exclude* options is required."),
					new GitCommandOption("-k", "-k", @"Show files on the filesystem that need to be removed due to file/directory conflicts for checkout-index to succeed."),
					new GitCommandOption("-m", "-m", @"Show modified files in the output"),
					new GitCommandOption("-o", "-o", @"Show other (i.e. untracked) files in the output"),
					new GitCommandOption("-s", "-s", @"Show staged contents' mode bits, object name and stage number in the output."),
					new GitCommandOption("-t", "-t", @"This feature is semi-deprecated. For scripting purpose, git-status --porcelain and git-diff-files --name-status are almost always superior alternatives, and users should look at git-status --short or git-diff --name-status for more user-friendly alternatives.    This option identifies the file status with the following tags (followed by a space) at the start of each line:    H  cached  S  skip-worktree  M  unmerged  R  removed/deleted  C  modified/changed  K  to be killed  ?  other"),
					new GitCommandOption("-u", "-u", @"Show unmerged files in the output (forces --stage)"),
					new GitCommandOption("-v", "-v", @"Similar to -t, but use lowercase letters for files that are marked as assume unchanged (see git-update-index)."),
					new GitCommandOption("-X", "-X <file>", @"Read exclude patterns from <file>; 1 per line."),
					new GitCommandOption("-x", "-x <pattern>", @"Skip untracked files matching pattern. Note that pattern is a shell wildcard pattern. See EXCLUDE PATTERNS below for more information."),
					new GitCommandOption("-z", "-z", @"\0 line termination on output and do not quote filenames. See OUTPUT below for more information."),
					new GitCommandOption("?", "?", @"other"),
					new GitCommandOption("C", "C", @"modified/changed"),
					new GitCommandOption("H", "H", @"cached"),
					new GitCommandOption("K", "K", @"to be killed"),
					new GitCommandOption("M", "M", @"unmerged"),
					new GitCommandOption("R", "R", @"removed/deleted"),
					new GitCommandOption("S", "S", @"skip-worktree"),
				}, 
	"ls-remote" => new GitCommandOption[] {
					new GitCommandOption("<refs>…​", "<refs>…​", @"When unspecified, all references, after filtering done with --heads and --tags, are shown.  When <refs>…​ are specified, only references matching the given patterns are displayed."),
					new GitCommandOption("<repository>", "<repository>", @"The ""remote"" repository to query.  This parameter can be either a URL or the name of a remote (see the GIT URLS and REMOTES sections of git-fetch)."),
					new GitCommandOption("--exit-code", "--exit-code", @"Exit with status ""2"" when no matching refs are found in the remote repository. Usually the command exits with status ""0"" to indicate it successfully talked with the remote repository, whether it found any matching refs."),
					new GitCommandOption("--get-url", "--get-url", @"Expand the URL of the given remote repository taking into account any ""url.<base>.insteadOf"" config setting (See git-config) and exit without talking to the remote."),
					new GitCommandOption("--heads", "--heads", @"Limit to only refs/heads and refs/tags, respectively. These options are not mutually exclusive; when given both, references stored in refs/heads and refs/tags are displayed.  Note that git ls-remote -h used without anything else on the command line gives help, consistent with other git subcommands."),
					new GitCommandOption("--quiet", "--quiet", @"Do not print remote URL to stderr."),
					new GitCommandOption("--refs", "--refs", @"Do not show peeled tags or pseudorefs like HEAD in the output."),
					new GitCommandOption("--server-option", "--server-option=<option>", @"Transmit the given string to the server when communicating using protocol version 2.  The given string must not contain a NUL or LF character. When multiple --server-option=<option> are given, they are all sent to the other side in the order listed on the command line."),
					new GitCommandOption("--sort", "--sort=<key>", @"Sort based on the key given. Prefix - to sort in descending order of the value. Supports ""version:refname"" or ""v:refname"" (tag names are treated as versions). The ""version:refname"" sort order can also be affected by the ""versionsort.suffix"" configuration variable. See git-for-each-ref for more sort options, but be aware keys like committerdate that require access to the objects themselves will not work for refs whose objects have not yet been fetched from the remote, and will give a missing object error."),
					new GitCommandOption("--symref", "--symref", @"In addition to the object pointed by it, show the underlying ref pointed by it when showing a symbolic ref.  Currently, upload-pack only shows the symref HEAD, so it will be the only one shown by ls-remote."),
					new GitCommandOption("--tags", "--tags", @"Limit to only refs/heads and refs/tags, respectively. These options are not mutually exclusive; when given both, references stored in refs/heads and refs/tags are displayed.  Note that git ls-remote -h used without anything else on the command line gives help, consistent with other git subcommands."),
					new GitCommandOption("--upload-pack", "--upload-pack=<exec>", @"Specify the full path of git-upload-pack on the remote host. This allows listing references from repositories accessed via SSH and where the SSH daemon does not use the PATH configured by the user."),
					new GitCommandOption("-h", "-h", @"Limit to only refs/heads and refs/tags, respectively. These options are not mutually exclusive; when given both, references stored in refs/heads and refs/tags are displayed.  Note that git ls-remote -h used without anything else on the command line gives help, consistent with other git subcommands."),
					new GitCommandOption("-o", "-o <option>", @"Transmit the given string to the server when communicating using protocol version 2.  The given string must not contain a NUL or LF character. When multiple --server-option=<option> are given, they are all sent to the other side in the order listed on the command line."),
					new GitCommandOption("-q", "-q", @"Do not print remote URL to stderr."),
					new GitCommandOption("-t", "-t", @"Limit to only refs/heads and refs/tags, respectively. These options are not mutually exclusive; when given both, references stored in refs/heads and refs/tags are displayed.  Note that git ls-remote -h used without anything else on the command line gives help, consistent with other git subcommands."),
				}, 
	"ls-tree" => new GitCommandOption[] {
					new GitCommandOption("<tree-ish>", "<tree-ish>", @"Id of a tree-ish."),
					new GitCommandOption("--abbrev[", "--abbrev[=<n>]", @"Instead of showing the full 40-byte hexadecimal object lines, show the shortest prefix that is at least <n> hexdigits long that uniquely refers the object. Non default number of digits can be specified with --abbrev=<n>."),
					new GitCommandOption("--format", "--format=<format>", @"A string that interpolates %(fieldname) from the result being shown. It also interpolates %% to %, and %xx where xx are hex digits interpolates to character with hex code xx; for example %00 interpolates to \0 (NUL), %09 to \t (TAB) and %0a to \n (LF). When specified, --format cannot be combined with other format-altering options, including --long, --name-only and --object-only."),
					new GitCommandOption("--full-name", "--full-name", @"Instead of showing the path names relative to the current working directory, show the full path names."),
					new GitCommandOption("--full-tree", "--full-tree", @"Do not limit the listing to the current working directory. Implies --full-name."),
					new GitCommandOption("--long", "--long", @"Show object size of blob (file) entries."),
					new GitCommandOption("--name-only", "--name-only", @"List only filenames (instead of the ""long"" output), one per line. Cannot be combined with --object-only."),
					new GitCommandOption("--name-status", "--name-status", @"List only filenames (instead of the ""long"" output), one per line. Cannot be combined with --object-only."),
					new GitCommandOption("--object-only", "--object-only", @"List only names of the objects, one per line. Cannot be combined with --name-only or --name-status. This is equivalent to specifying --format='%(objectname)', but for both this option and that exact format the command takes a hand-optimized codepath instead of going through the generic formatting mechanism."),
					new GitCommandOption("-d", "-d", @"Show only the named tree entry itself, not its children."),
					new GitCommandOption("-l", "-l", @"Show object size of blob (file) entries."),
					new GitCommandOption("-r", "-r", @"Recurse into sub-trees."),
					new GitCommandOption("-t", "-t", @"Show tree entries even when going to recurse them. Has no effect if -r was not passed. -d implies -t."),
					new GitCommandOption("-z", "-z", @"\0 line termination on output and do not quote filenames. See OUTPUT FORMAT below for more information."),
					new GitCommandOption("[<path>…​]", "[<path>…​]", @"When paths are given, show them (note that this isn’t really raw pathnames, but rather a list of patterns to match).  Otherwise implicitly uses the root level of the tree as the sole path argument."),
				}, 
	"mailinfo" => new GitCommandOption[] {
					new GitCommandOption("<msg>", "<msg>", @"The commit log message extracted from e-mail, usually except the title line which comes from e-mail Subject."),
					new GitCommandOption("<patch>", "<patch>", @"The patch extracted from e-mail."),
					new GitCommandOption("--encoding", "--encoding=<encoding>", @"Similar to -u.  But when re-coding, the charset specified here is used instead of the one specified by i18n.commitEncoding or UTF-8."),
					new GitCommandOption("--message-id", "--message-id", @"Copy the Message-ID header at the end of the commit message.  This is useful in order to associate commits with mailing list discussions."),
					new GitCommandOption("--no-scissors", "--no-scissors", @"Ignore scissors lines. Useful for overriding mailinfo.scissors settings."),
					new GitCommandOption("--quoted-cr", "--quoted-cr=<action>", @"Action when processes email messages sent with base64 or quoted-printable encoding, and the decoded lines end with a CRLF instead of a simple LF.  The valid actions are:       nowarn: Git will do nothing when such a CRLF is found.   warn: Git will issue a warning for each message if such a CRLF is found.   strip: Git will convert those CRLF to LF.       The default action could be set by configuration option mailinfo.quotedCR. If no such configuration option has been set, warn will be used."),
					new GitCommandOption("--scissors", "--scissors", @"Remove everything in body before a scissors line (e.g. ""-- >8 --""). The line represents scissors and perforation marks, and is used to request the reader to cut the message at that line.  If that line appears in the body of the message before the patch, everything before it (including the scissors line itself) is ignored when this option is used.  This is useful if you want to begin your message in a discussion thread with comments and suggestions on the message you are responding to, and to conclude it with a patch submission, separating the discussion and the beginning of the proposed commit log message with a scissors line.   This can be enabled by default with the configuration option mailinfo.scissors."),
					new GitCommandOption("-b", "-b", @"When -k is not in effect, all leading strings bracketed with [ and ] pairs are stripped.  This option limits the stripping to only the pairs whose bracketed string contains the word ""PATCH""."),
					new GitCommandOption("-k", "-k", @"Usually the program removes email cruft from the Subject: header line to extract the title line for the commit log message.  This option prevents this munging, and is most useful when used to read back git format-patch -k output.  Specifically, the following are removed until none of them remain:       Leading and trailing whitespace.   Leading Re:, re:, and :.   Leading bracketed strings (between [ and ], usually [PATCH]).       Finally, runs of whitespace are normalized to a single ASCII space character."),
					new GitCommandOption("-m", "-m", @"Copy the Message-ID header at the end of the commit message.  This is useful in order to associate commits with mailing list discussions."),
					new GitCommandOption("-n", "-n", @"Disable all charset re-coding of the metadata."),
					new GitCommandOption("-u", "-u", @"The commit log message, author name and author email are taken from the e-mail, and after minimally decoding MIME transfer encoding, re-coded in the charset specified by i18n.commitEncoding (defaulting to UTF-8) by transliterating them.  This used to be optional but now it is the default.  Note that the patch is always used as-is without charset conversion, even with this flag."),
				}, 
	"mailsplit" => new GitCommandOption[] {
					new GitCommandOption("<Maildir>", "<Maildir>", @"Root of the Maildir to split. This directory should contain the cur, tmp and new subdirectories."),
					new GitCommandOption("<mbox>", "<mbox>", @"Mbox file to split.  If not given, the mbox is read from the standard input."),
					new GitCommandOption("--keep-cr", "--keep-cr", @"Do not remove \r from lines ending with \r\n."),
					new GitCommandOption("--mboxrd", "--mboxrd", @"Input is of the ""mboxrd"" format and ""^>+From "" line escaping is reversed."),
					new GitCommandOption("-b", "-b", @"If any file doesn’t begin with a From line, assume it is a single mail message instead of signaling error."),
					new GitCommandOption("-d<prec>", "-d<prec>", @"Instead of the default 4 digits with leading zeros, different precision can be specified for the generated filenames."),
					new GitCommandOption("-f<nn>", "-f<nn>", @"Skip the first <nn> numbers, for example if -f3 is specified, start the numbering with 0004."),
					new GitCommandOption("-o<directory>", "-o<directory>", @"Directory in which to place the individual messages."),
				}, 
	"maintenance" => new GitCommandOption[] {
					new GitCommandOption("--auto", "--auto", @"When combined with the run subcommand, run maintenance tasks only if certain thresholds are met. For example, the gc task runs when the number of loose objects exceeds the number stored in the gc.auto config setting, or when the number of pack-files exceeds the gc.autoPackLimit config setting. Not compatible with the --schedule option."),
					new GitCommandOption("--quiet", "--quiet", @"Do not report progress or other information over stderr."),
					new GitCommandOption("--schedule", "--schedule", @"When combined with the run subcommand, run maintenance tasks only if certain time conditions are met, as specified by the maintenance.<task>.schedule config value for each <task>. This config value specifies a number of seconds since the last time that task ran, according to the maintenance.<task>.lastRun config value. The tasks that are tested are those provided by the --task=<task> option(s) or those with maintenance.<task>.enabled set to true."),
					new GitCommandOption("--scheduler", "--scheduler=auto|crontab|systemd-timer|launchctl|schtasks", @"When combined with the start subcommand, specify the scheduler for running the hourly, daily and weekly executions of git maintenance run. Possible values for <scheduler> are auto, crontab (POSIX), systemd-timer (Linux), launchctl (macOS), and schtasks (Windows). When auto is specified, the appropriate platform-specific scheduler is used; on Linux, systemd-timer is used if available, otherwise crontab. Default is auto."),
					new GitCommandOption("--task", "--task=<task>", @"If this option is specified one or more times, then only run the specified tasks in the specified order. If no --task=<task> arguments are specified, then only the tasks with maintenance.<task>.enabled configured as true are considered. See the TASKS section for the list of accepted <task> values."),
				}, 
	"merge-base" => new GitCommandOption[] {
					new GitCommandOption("--all", "--all", @"Output all merge bases for the commits, instead of just one."),
					new GitCommandOption("-a", "-a", @"Output all merge bases for the commits, instead of just one."),
				}, 
	"merge-file" => new GitCommandOption[] {
					new GitCommandOption("--diff3", "--diff3", @"Show conflicts in ""diff3"" style."),
					new GitCommandOption("--ours", "--ours", @"Instead of leaving conflicts in the file, resolve conflicts favouring our (or their or both) side of the lines."),
					new GitCommandOption("--theirs", "--theirs", @"Instead of leaving conflicts in the file, resolve conflicts favouring our (or their or both) side of the lines."),
					new GitCommandOption("--union", "--union", @"Instead of leaving conflicts in the file, resolve conflicts favouring our (or their or both) side of the lines."),
					new GitCommandOption("--zdiff3", "--zdiff3", @"Show conflicts in ""zdiff3"" style."),
					new GitCommandOption("-L", "-L <label>", @"This option may be given up to three times, and specifies labels to be used in place of the corresponding file names in conflict reports. That is, git merge-file -L x -L y -L z a b c generates output that looks like it came from files x, y and z instead of from files a, b and c."),
					new GitCommandOption("-p", "-p", @"Send results to standard output instead of overwriting <current-file>."),
					new GitCommandOption("-q", "-q", @"Quiet; do not warn about conflicts."),
				}, 
	"merge-index" => new GitCommandOption[] {
					new GitCommandOption("--", "--", @"Do not interpret any more arguments as options."),
					new GitCommandOption("-a", "-a", @"Run merge against all files in the index that need merging."),
					new GitCommandOption("-o", "-o", @"Instead of stopping at the first failed merge, do all of them in one shot - continue with merging even when previous merges returned errors, and only return the error code after all the merges."),
					new GitCommandOption("-q", "-q", @"Do not complain about a failed merge program (a merge program failure usually indicates conflicts during the merge). This is for porcelains which might want to emit custom messages."),
				}, 
	"merge-one-file" => new GitCommandOption[] {
				}, 
	"merge-tree" => new GitCommandOption[] {
				}, 
	"merge" => new GitCommandOption[] {
					new GitCommandOption("<commit>…​", "<commit>…​", @"Commits, usually other branch heads, to merge into our branch. Specifying more than one commit will create a merge with more than two parents (affectionately called an Octopus merge).  If no commit is given from the command line, merge the remote-tracking branches that the current branch is configured to use as its upstream. See also the configuration section of this manual page.   When FETCH_HEAD (and no other commit) is specified, the branches recorded in the .git/FETCH_HEAD file by the previous invocation of git fetch for merging are merged to the current branch."),
					new GitCommandOption("--[no-]verify", "--[no-]verify", @"By default, the pre-merge and commit-msg hooks are run. When --no-verify is given, these are bypassed. See also githooks."),
					new GitCommandOption("--abort", "--abort", @"Abort the current conflict resolution process, and try to reconstruct the pre-merge state. If an autostash entry is present, apply it to the worktree.  If there were uncommitted worktree changes present when the merge started, git merge --abort will in some cases be unable to reconstruct these changes. It is therefore recommended to always commit or stash your changes before running git merge.   git merge --abort is equivalent to git reset --merge when MERGE_HEAD is present unless MERGE_AUTOSTASH is also present in which case git merge --abort applies the stash entry to the worktree whereas git reset --merge will save the stashed changes in the stash list."),
					new GitCommandOption("--allow-unrelated-histories", "--allow-unrelated-histories", @"By default, git merge command refuses to merge histories that do not share a common ancestor.  This option can be used to override this safety when merging histories of two projects that started their lives independently. As that is a very rare occasion, no configuration variable to enable this by default exists and will not be added."),
					new GitCommandOption("--autostash", "--autostash", @"Automatically create a temporary stash entry before the operation begins, record it in the special ref MERGE_AUTOSTASH and apply it after the operation ends.  This means that you can run the operation on a dirty worktree.  However, use with care: the final stash application after a successful merge might result in non-trivial conflicts."),
					new GitCommandOption("--cleanup", "--cleanup=<mode>", @"This option determines how the merge message will be cleaned up before committing. See git-commit for more details. In addition, if the <mode> is given a value of scissors, scissors will be appended to MERGE_MSG before being passed on to the commit machinery in the case of a merge conflict."),
					new GitCommandOption("--commit", "--commit", @"Perform the merge and commit the result. This option can be used to override --no-commit.  With --no-commit perform the merge and stop just before creating a merge commit, to give the user a chance to inspect and further tweak the merge result before committing.   Note that fast-forward updates do not create a merge commit and therefore there is no way to stop those merges with --no-commit. Thus, if you want to ensure your branch is not changed or updated by the merge command, use --no-ff with --no-commit."),
					new GitCommandOption("--continue", "--continue", @"After a git merge stops due to conflicts you can conclude the merge by running git merge --continue (see ""HOW TO RESOLVE CONFLICTS"" section below)."),
					new GitCommandOption("--edit", "--edit", @"Invoke an editor before committing successful mechanical merge to 	further edit the auto-generated merge message, so that the user 	can explain and justify the merge. The --no-edit option can be 	used to accept the auto-generated message (this is generally 	discouraged). The --edit (or -e) option is still useful if you are giving a draft message with the -m option from the command line and want to edit it in the editor.  Older scripts may depend on the historical behaviour of not allowing the user to edit the merge log message. They will see an editor opened when they run git merge. To make it easier to adjust such scripts to the updated behaviour, the environment variable GIT_MERGE_AUTOEDIT can be set to no at the beginning of them."),
					new GitCommandOption("--ff", "--ff", @"Specifies how a merge is handled when the merged-in history is already a descendant of the current history.  --ff is the default unless merging an annotated (and possibly signed) tag that is not stored in its natural place in the refs/tags/ hierarchy, in which case --no-ff is assumed.  With --ff, when possible resolve the merge as a fast-forward (only update the branch pointer to match the merged branch; do not create a merge commit).  When not possible (when the merged-in history is not a descendant of the current history), create a merge commit.   With --no-ff, create a merge commit in all cases, even when the merge could instead be resolved as a fast-forward.   With --ff-only, resolve the merge as a fast-forward when possible. When not possible, refuse to merge and exit with a non-zero status."),
					new GitCommandOption("--ff-only", "--ff-only", @"Specifies how a merge is handled when the merged-in history is already a descendant of the current history.  --ff is the default unless merging an annotated (and possibly signed) tag that is not stored in its natural place in the refs/tags/ hierarchy, in which case --no-ff is assumed.  With --ff, when possible resolve the merge as a fast-forward (only update the branch pointer to match the merged branch; do not create a merge commit).  When not possible (when the merged-in history is not a descendant of the current history), create a merge commit.   With --no-ff, create a merge commit in all cases, even when the merge could instead be resolved as a fast-forward.   With --ff-only, resolve the merge as a fast-forward when possible. When not possible, refuse to merge and exit with a non-zero status."),
					new GitCommandOption("--file", "--file=<file>", @"Read the commit message to be used for the merge commit (in case one is created).  If --log is specified, a shortlog of the commits being merged will be appended to the specified message."),
					new GitCommandOption("--gpg-sign[", "--gpg-sign[=<keyid>]", @"GPG-sign the resulting merge commit. The keyid argument is optional and defaults to the committer identity; if specified, it must be stuck to the option without a space. --no-gpg-sign is useful to countermand both commit.gpgSign configuration variable, and earlier --gpg-sign."),
					new GitCommandOption("--into-name", "--into-name <branch>", @"Prepare the default merge message as if merging to the branch <branch>, instead of the name of the real branch to which the merge is made."),
					new GitCommandOption("--log[", "--log[=<n>]", @"In addition to branch names, populate the log message with one-line descriptions from at most <n> actual commits that are being merged. See also git-fmt-merge-msg.  With --no-log do not list one-line descriptions from the actual commits being merged."),
					new GitCommandOption("--no-autostash", "--no-autostash", @"Automatically create a temporary stash entry before the operation begins, record it in the special ref MERGE_AUTOSTASH and apply it after the operation ends.  This means that you can run the operation on a dirty worktree.  However, use with care: the final stash application after a successful merge might result in non-trivial conflicts."),
					new GitCommandOption("--no-commit", "--no-commit", @"Perform the merge and commit the result. This option can be used to override --no-commit.  With --no-commit perform the merge and stop just before creating a merge commit, to give the user a chance to inspect and further tweak the merge result before committing.   Note that fast-forward updates do not create a merge commit and therefore there is no way to stop those merges with --no-commit. Thus, if you want to ensure your branch is not changed or updated by the merge command, use --no-ff with --no-commit."),
					new GitCommandOption("--no-edit", "--no-edit", @"Invoke an editor before committing successful mechanical merge to 	further edit the auto-generated merge message, so that the user 	can explain and justify the merge. The --no-edit option can be 	used to accept the auto-generated message (this is generally 	discouraged). The --edit (or -e) option is still useful if you are giving a draft message with the -m option from the command line and want to edit it in the editor.  Older scripts may depend on the historical behaviour of not allowing the user to edit the merge log message. They will see an editor opened when they run git merge. To make it easier to adjust such scripts to the updated behaviour, the environment variable GIT_MERGE_AUTOEDIT can be set to no at the beginning of them."),
					new GitCommandOption("--no-ff", "--no-ff", @"Specifies how a merge is handled when the merged-in history is already a descendant of the current history.  --ff is the default unless merging an annotated (and possibly signed) tag that is not stored in its natural place in the refs/tags/ hierarchy, in which case --no-ff is assumed.  With --ff, when possible resolve the merge as a fast-forward (only update the branch pointer to match the merged branch; do not create a merge commit).  When not possible (when the merged-in history is not a descendant of the current history), create a merge commit.   With --no-ff, create a merge commit in all cases, even when the merge could instead be resolved as a fast-forward.   With --ff-only, resolve the merge as a fast-forward when possible. When not possible, refuse to merge and exit with a non-zero status."),
					new GitCommandOption("--no-gpg-sign", "--no-gpg-sign", @"GPG-sign the resulting merge commit. The keyid argument is optional and defaults to the committer identity; if specified, it must be stuck to the option without a space. --no-gpg-sign is useful to countermand both commit.gpgSign configuration variable, and earlier --gpg-sign."),
					new GitCommandOption("--no-log", "--no-log", @"In addition to branch names, populate the log message with one-line descriptions from at most <n> actual commits that are being merged. See also git-fmt-merge-msg.  With --no-log do not list one-line descriptions from the actual commits being merged."),
					new GitCommandOption("--no-overwrite-ignore", "--no-overwrite-ignore", @"Silently overwrite ignored files from the merge result. This is the default behavior. Use --no-overwrite-ignore to abort."),
					new GitCommandOption("--no-progress", "--no-progress", @"Turn progress on/off explicitly. If neither is specified, progress is shown if standard error is connected to a terminal. Note that not all merge strategies may support progress reporting."),
					new GitCommandOption("--no-rerere-autoupdate", "--no-rerere-autoupdate", @"Allow the rerere mechanism to update the index with the result of auto-conflict resolution if possible."),
					new GitCommandOption("--no-signoff", "--no-signoff", @"Add a Signed-off-by trailer by the committer at the end of the commit log message.  The meaning of a signoff depends on the project to which you’re committing.  For example, it may certify that the committer has the rights to submit the work under the project’s license or agrees to some contributor representation, such as a Developer Certificate of Origin. (See http://developercertificate.org for the one used by the Linux kernel and Git projects.)  Consult the documentation or leadership of the project to which you’re contributing to understand how the signoffs are used in that project.  The --no-signoff option can be used to countermand an earlier --signoff option on the command line."),
					new GitCommandOption("--no-squash", "--no-squash", @"Produce the working tree and index state as if a real merge happened (except for the merge information), but do not actually make a commit, move the HEAD, or record $GIT_DIR/MERGE_HEAD (to cause the next git commit command to create a merge commit).  This allows you to create a single commit on top of the current branch whose effect is the same as merging another branch (or more in case of an octopus).  With --no-squash perform the merge and commit the result. This option can be used to override --squash.   With --squash, --commit is not allowed, and will fail."),
					new GitCommandOption("--no-stat", "--no-stat", @"Show a diffstat at the end of the merge. The diffstat is also controlled by the configuration option merge.stat.  With -n or --no-stat do not show a diffstat at the end of the merge."),
					new GitCommandOption("--no-summary", "--no-summary", @"Synonyms to --stat and --no-stat; these are deprecated and will be removed in the future."),
					new GitCommandOption("--no-verify-signatures", "--no-verify-signatures", @"Verify that the tip commit of the side branch being merged is signed with a valid key, i.e. a key that has a valid uid: in the default trust model, this means the signing key has been signed by a trusted key.  If the tip commit of the side branch is not signed with a valid key, the merge is aborted."),
					new GitCommandOption("--overwrite-ignore", "--overwrite-ignore", @"Silently overwrite ignored files from the merge result. This is the default behavior. Use --no-overwrite-ignore to abort."),
					new GitCommandOption("--progress", "--progress", @"Turn progress on/off explicitly. If neither is specified, progress is shown if standard error is connected to a terminal. Note that not all merge strategies may support progress reporting."),
					new GitCommandOption("--quiet", "--quiet", @"Operate quietly. Implies --no-progress."),
					new GitCommandOption("--quit", "--quit", @"Forget about the current merge in progress. Leave the index and the working tree as-is. If MERGE_AUTOSTASH is present, the stash entry will be saved to the stash list."),
					new GitCommandOption("--rerere-autoupdate", "--rerere-autoupdate", @"Allow the rerere mechanism to update the index with the result of auto-conflict resolution if possible."),
					new GitCommandOption("--signoff", "--signoff", @"Add a Signed-off-by trailer by the committer at the end of the commit log message.  The meaning of a signoff depends on the project to which you’re committing.  For example, it may certify that the committer has the rights to submit the work under the project’s license or agrees to some contributor representation, such as a Developer Certificate of Origin. (See http://developercertificate.org for the one used by the Linux kernel and Git projects.)  Consult the documentation or leadership of the project to which you’re contributing to understand how the signoffs are used in that project.  The --no-signoff option can be used to countermand an earlier --signoff option on the command line."),
					new GitCommandOption("--squash", "--squash", @"Produce the working tree and index state as if a real merge happened (except for the merge information), but do not actually make a commit, move the HEAD, or record $GIT_DIR/MERGE_HEAD (to cause the next git commit command to create a merge commit).  This allows you to create a single commit on top of the current branch whose effect is the same as merging another branch (or more in case of an octopus).  With --no-squash perform the merge and commit the result. This option can be used to override --squash.   With --squash, --commit is not allowed, and will fail."),
					new GitCommandOption("--stat", "--stat", @"Show a diffstat at the end of the merge. The diffstat is also controlled by the configuration option merge.stat.  With -n or --no-stat do not show a diffstat at the end of the merge."),
					new GitCommandOption("--strategy", "--strategy=<strategy>", @"Use the given merge strategy; can be supplied more than once to specify them in the order they should be tried. If there is no -s option, a built-in list of strategies is used instead (ort when merging a single head, octopus otherwise)."),
					new GitCommandOption("--strategy-option", "--strategy-option=<option>", @"Pass merge strategy specific option through to the merge strategy."),
					new GitCommandOption("--summary", "--summary", @"Synonyms to --stat and --no-stat; these are deprecated and will be removed in the future."),
					new GitCommandOption("--verbose", "--verbose", @"Be verbose."),
					new GitCommandOption("--verify-signatures", "--verify-signatures", @"Verify that the tip commit of the side branch being merged is signed with a valid key, i.e. a key that has a valid uid: in the default trust model, this means the signing key has been signed by a trusted key.  If the tip commit of the side branch is not signed with a valid key, the merge is aborted."),
					new GitCommandOption("-e", "-e", @"Invoke an editor before committing successful mechanical merge to 	further edit the auto-generated merge message, so that the user 	can explain and justify the merge. The --no-edit option can be 	used to accept the auto-generated message (this is generally 	discouraged). The --edit (or -e) option is still useful if you are giving a draft message with the -m option from the command line and want to edit it in the editor.  Older scripts may depend on the historical behaviour of not allowing the user to edit the merge log message. They will see an editor opened when they run git merge. To make it easier to adjust such scripts to the updated behaviour, the environment variable GIT_MERGE_AUTOEDIT can be set to no at the beginning of them."),
					new GitCommandOption("-F", "-F <file>", @"Read the commit message to be used for the merge commit (in case one is created).  If --log is specified, a shortlog of the commits being merged will be appended to the specified message."),
					new GitCommandOption("-m", "-m <msg>", @"Set the commit message to be used for the merge commit (in case one is created).  If --log is specified, a shortlog of the commits being merged will be appended to the specified message.   The git fmt-merge-msg command can be used to give a good default for automated git merge invocations. The automated message can include the branch description."),
					new GitCommandOption("-n", "-n", @"Show a diffstat at the end of the merge. The diffstat is also controlled by the configuration option merge.stat.  With -n or --no-stat do not show a diffstat at the end of the merge."),
					new GitCommandOption("-q", "-q", @"Operate quietly. Implies --no-progress."),
					new GitCommandOption("-s", "-s <strategy>", @"Use the given merge strategy; can be supplied more than once to specify them in the order they should be tried. If there is no -s option, a built-in list of strategies is used instead (ort when merging a single head, octopus otherwise)."),
					new GitCommandOption("-S[<keyid>]", "-S[<keyid>]", @"GPG-sign the resulting merge commit. The keyid argument is optional and defaults to the committer identity; if specified, it must be stuck to the option without a space. --no-gpg-sign is useful to countermand both commit.gpgSign configuration variable, and earlier --gpg-sign."),
					new GitCommandOption("-v", "-v", @"Be verbose."),
					new GitCommandOption("-X", "-X <option>", @"Pass merge strategy specific option through to the merge strategy."),
				}, 
	"mergetool--lib" => new GitCommandOption[] {
				}, 
	"mergetool" => new GitCommandOption[] {
					new GitCommandOption("--gui", "--gui", @"When git-mergetool is invoked with the -g or --gui option the default merge tool will be read from the configured merge.guitool variable instead of merge.tool. If merge.guitool is not set, we will fallback to the tool configured under merge.tool."),
					new GitCommandOption("--no-gui", "--no-gui", @"This overrides a previous -g or --gui setting and reads the default merge tool will be read from the configured merge.tool variable."),
					new GitCommandOption("--no-prompt", "--no-prompt", @"Don’t prompt before each invocation of the merge resolution program. This is the default if the merge resolution program is explicitly specified with the --tool option or with the merge.tool configuration variable."),
					new GitCommandOption("--prompt", "--prompt", @"Prompt before each invocation of the merge resolution program to give the user a chance to skip the path."),
					new GitCommandOption("--tool", "--tool=<tool>", @"Use the merge resolution program specified by <tool>. Valid values include emerge, gvimdiff, kdiff3, meld, vimdiff, and tortoisemerge. Run git mergetool --tool-help for the list of valid <tool> settings.  If a merge resolution program is not specified, git mergetool will use the configuration variable merge.tool.  If the configuration variable merge.tool is not set, git mergetool will pick a suitable default.   You can explicitly provide a full path to the tool by setting the configuration variable mergetool.<tool>.path. For example, you can configure the absolute path to kdiff3 by setting mergetool.kdiff3.path. Otherwise, git mergetool assumes the tool is available in PATH.   Instead of running one of the known merge tool programs, git mergetool can be customized to run an alternative program by specifying the command line to invoke in a configuration variable mergetool.<tool>.cmd.   When git mergetool is invoked with this tool (either through the -t or --tool option or the merge.tool configuration variable) the configured command line will be invoked with $BASE set to the name of a temporary file containing the common base for the merge, if available; $LOCAL set to the name of a temporary file containing the contents of the file on the current branch; $REMOTE set to the name of a temporary file containing the contents of the file to be merged, and $MERGED set to the name of the file to which the merge tool should write the result of the merge resolution.   If the custom merge tool correctly indicates the success of a merge resolution with its exit code, then the configuration variable mergetool.<tool>.trustExitCode can be set to true. Otherwise, git mergetool will prompt the user to indicate the success of the resolution after the custom tool has exited."),
					new GitCommandOption("--tool-help", "--tool-help", @"Print a list of merge tools that may be used with --tool."),
					new GitCommandOption("-g", "-g", @"When git-mergetool is invoked with the -g or --gui option the default merge tool will be read from the configured merge.guitool variable instead of merge.tool. If merge.guitool is not set, we will fallback to the tool configured under merge.tool."),
					new GitCommandOption("-O<orderfile>", "-O<orderfile>", @"Process files in the order specified in the <orderfile>, which has one shell glob pattern per line. This overrides the diff.orderFile configuration variable (see git-config).  To cancel diff.orderFile, use -O/dev/null."),
					new GitCommandOption("-t", "-t <tool>", @"Use the merge resolution program specified by <tool>. Valid values include emerge, gvimdiff, kdiff3, meld, vimdiff, and tortoisemerge. Run git mergetool --tool-help for the list of valid <tool> settings.  If a merge resolution program is not specified, git mergetool will use the configuration variable merge.tool.  If the configuration variable merge.tool is not set, git mergetool will pick a suitable default.   You can explicitly provide a full path to the tool by setting the configuration variable mergetool.<tool>.path. For example, you can configure the absolute path to kdiff3 by setting mergetool.kdiff3.path. Otherwise, git mergetool assumes the tool is available in PATH.   Instead of running one of the known merge tool programs, git mergetool can be customized to run an alternative program by specifying the command line to invoke in a configuration variable mergetool.<tool>.cmd.   When git mergetool is invoked with this tool (either through the -t or --tool option or the merge.tool configuration variable) the configured command line will be invoked with $BASE set to the name of a temporary file containing the common base for the merge, if available; $LOCAL set to the name of a temporary file containing the contents of the file on the current branch; $REMOTE set to the name of a temporary file containing the contents of the file to be merged, and $MERGED set to the name of the file to which the merge tool should write the result of the merge resolution.   If the custom merge tool correctly indicates the success of a merge resolution with its exit code, then the configuration variable mergetool.<tool>.trustExitCode can be set to true. Otherwise, git mergetool will prompt the user to indicate the success of the resolution after the custom tool has exited."),
					new GitCommandOption("-y", "-y", @"Don’t prompt before each invocation of the merge resolution program. This is the default if the merge resolution program is explicitly specified with the --tool option or with the merge.tool configuration variable."),
				}, 
	"mktag" => new GitCommandOption[] {
					new GitCommandOption("--strict", "--strict", @"By default mktag turns on the equivalent of git-fsck --strict mode. Use --no-strict to disable it."),
				}, 
	"mktree" => new GitCommandOption[] {
					new GitCommandOption("--batch", "--batch", @"Allow building of more than one tree object before exiting.  Each tree is separated by a single blank line. The final new-line is optional.  Note - if the -z option is used, lines are terminated with NUL."),
					new GitCommandOption("--missing", "--missing", @"Allow missing objects.  The default behaviour (without this option) is to verify that each tree entry’s sha1 identifies an existing object.  This option has no effect on the treatment of gitlink entries (aka ""submodules"") which are always allowed to be missing."),
					new GitCommandOption("-z", "-z", @"Read the NUL-terminated ls-tree -z output instead."),
				}, 
	"multi-pack-index" => new GitCommandOption[] {
					new GitCommandOption("--[no-]bitmap", "--[no-]bitmap", @"Control whether or not a multi-pack bitmap is written."),
					new GitCommandOption("--[no-]progress", "--[no-]progress", @"Turn progress on/off explicitly. If neither is specified, progress is shown if standard error is connected to a terminal. Supported by sub-commands write, verify, expire, and `repack."),
					new GitCommandOption("--object-dir", "--object-dir=<dir>", @"Use given directory for the location of Git objects. We check <dir>/packs/multi-pack-index for the current MIDX file, and <dir>/packs for the pack-files to index.  <dir> must be an alternate of the current repository."),
					new GitCommandOption("--preferred-pack", "--preferred-pack=<pack>", @"Optionally specify the tie-breaking pack used when multiple packs contain the same object. <pack> must contain at least one object. If not given, ties are broken in favor of the pack with the lowest mtime."),
					new GitCommandOption("--refs-snapshot", "--refs-snapshot=<path>", @"With --bitmap, optionally specify a file which contains a ""refs snapshot"" taken prior to repacking.  A reference snapshot is composed of line-delimited OIDs corresponding to the reference tips, usually taken by git repack prior to generating a new pack. A line may optionally start with a + character to indicate that the reference which corresponds to that OID is ""preferred"" (see git-config's pack.preferBitmapTips.)   The file given at <path> is expected to be readable, and can contain duplicates. (If a given OID is given more than once, it is marked as preferred if at least one instance of it begins with the special + marker)."),
					new GitCommandOption("--stdin-packs", "--stdin-packs", @"Write a multi-pack index containing only the set of line-delimited pack index basenames provided over stdin."),
					new GitCommandOption("expire", "expire", @"Delete the pack-files that are tracked 	by the MIDX file, but have no objects referenced by the MIDX. Rewrite the MIDX file afterward to remove all references to these pack-files."),
					new GitCommandOption("repack", "repack", @"Create a new pack-file containing objects in small pack-files referenced by the multi-pack-index. If the size given by the --batch-size=<size> argument is zero, then create a pack containing all objects referenced by the multi-pack-index. For a non-zero batch size, Select the pack-files by examining packs from oldest-to-newest, computing the ""expected size"" by counting the number of objects in the pack referenced by the multi-pack-index, then divide by the total number of objects in the pack and multiply by the pack size. We select packs with expected size below the batch size until the set of packs have total expected size at least the batch size, or all pack-files are considered. If only one pack-file is selected, then do nothing. If a new pack-file is created, rewrite the multi-pack-index to reference the new pack-file. A later run of git multi-pack-index expire will delete the pack-files that were part of this batch.  If repack.packKeptObjects is false, then any pack-files with an associated .keep file will not be selected for the batch to repack."),
					new GitCommandOption("verify", "verify", @"Verify the contents of the MIDX file."),
					new GitCommandOption("write", "write", @"Write a new MIDX file. The following options are available for the write sub-command:     --preferred-pack=<pack>  Optionally specify the tie-breaking pack used when multiple packs contain the same object. <pack> must contain at least one object. If not given, ties are broken in favor of the pack with the lowest mtime.  --[no-]bitmap  Control whether or not a multi-pack bitmap is written.  --stdin-packs  Write a multi-pack index containing only the set of line-delimited pack index basenames provided over stdin.  --refs-snapshot=<path>  With --bitmap, optionally specify a file which contains a ""refs snapshot"" taken prior to repacking.  A reference snapshot is composed of line-delimited OIDs corresponding to the reference tips, usually taken by git repack prior to generating a new pack. A line may optionally start with a + character to indicate that the reference which corresponds to that OID is ""preferred"" (see git-config's pack.preferBitmapTips.)   The file given at <path> is expected to be readable, and can contain duplicates. (If a given OID is given more than once, it is marked as preferred if at least one instance of it begins with the special + marker)."),
				}, 
	"mv" => new GitCommandOption[] {
					new GitCommandOption("--dry-run", "--dry-run", @"Do nothing; only show what would happen"),
					new GitCommandOption("--force", "--force", @"Force renaming or moving of a file even if the target exists"),
					new GitCommandOption("--verbose", "--verbose", @"Report the names of files as they are moved."),
					new GitCommandOption("-f", "-f", @"Force renaming or moving of a file even if the target exists"),
					new GitCommandOption("-k", "-k", @"Skip move or rename actions which would lead to an error condition. An error happens when a source is neither existing nor controlled by Git, or when it would overwrite an existing file unless -f is given."),
					new GitCommandOption("-n", "-n", @"Do nothing; only show what would happen"),
					new GitCommandOption("-v", "-v", @"Report the names of files as they are moved."),
				}, 
	"name-rev" => new GitCommandOption[] {
					new GitCommandOption("--all", "--all", @"List all commits reachable from all refs"),
					new GitCommandOption("--always", "--always", @"Show uniquely abbreviated commit object as fallback."),
					new GitCommandOption("--annotate-stdin", "--annotate-stdin", @"Transform stdin by substituting all the 40-character SHA-1 hexes (say $hex) with ""$hex ($rev_name)"".  When used with --name-only, substitute with ""$rev_name"", omitting $hex altogether.  For example:    $ cat sample.txt  An abbreviated revision 2ae0a9cb82 will not be substituted. The full name after substitution is 2ae0a9cb8298185a94e5998086f380a355dd8907, while its tree object is 70d105cc79e63b81cfdcb08a15297c23e60b07ad  $ git name-rev --annotate-stdin <sample.txt  An abbreviated revision 2ae0a9cb82 will not be substituted. The full name after substitution is 2ae0a9cb8298185a94e5998086f380a355dd8907 (master), while its tree object is 70d105cc79e63b81cfdcb08a15297c23e60b07ad  $ git name-rev --name-only --annotate-stdin <sample.txt  An abbreviated revision 2ae0a9cb82 will not be substituted. The full name after substitution is master, while its tree object is 70d105cc79e63b81cfdcb08a15297c23e60b07ad"),
					new GitCommandOption("--exclude", "--exclude=<pattern>", @"Do not use any ref whose name matches a given shell pattern. The pattern can be one of branch name, tag name or fully qualified ref name. If given multiple times, a ref will be excluded when it matches any of the given patterns. When used together with --refs, a ref will be used as a match only when it matches at least one --refs pattern and does not match any --exclude patterns. Use --no-exclude to clear the list of exclude patterns."),
					new GitCommandOption("--name-only", "--name-only", @"Instead of printing both the SHA-1 and the name, print only the name.  If given with --tags the usual tag prefix of ""tags/"" is also omitted from the name, matching the output of git-describe more closely."),
					new GitCommandOption("--no-undefined", "--no-undefined", @"Die with error code != 0 when a reference is undefined, instead of printing undefined."),
					new GitCommandOption("--refs", "--refs=<pattern>", @"Only use refs whose names match a given shell pattern.  The pattern can be one of branch name, tag name or fully qualified ref name. If given multiple times, use refs whose names match any of the given shell patterns. Use --no-refs to clear any previous ref patterns given."),
					new GitCommandOption("--stdin", "--stdin", @"This option is deprecated in favor of git name-rev --annotate-stdin. They are functionally equivalent."),
					new GitCommandOption("--tags", "--tags", @"Do not use branch names, but only tags to name the commits"),
				}, 
	"notes" => new GitCommandOption[] {
					new GitCommandOption("--abort", "--abort", @"Abort/reset an in-progress git notes merge, i.e. a notes merge with conflicts. This simply removes all files related to the notes merge."),
					new GitCommandOption("--allow-empty", "--allow-empty", @"Allow an empty note object to be stored. The default behavior is to automatically remove empty notes."),
					new GitCommandOption("--commit", "--commit", @"Finalize an in-progress git notes merge. Use this option when you have resolved the conflicts that git notes merge stored in .git/NOTES_MERGE_WORKTREE. This amends the partial merge commit created by git notes merge (stored in .git/NOTES_MERGE_PARTIAL) by adding the notes in .git/NOTES_MERGE_WORKTREE. The notes ref stored in the .git/NOTES_MERGE_REF symref is updated to the resulting commit."),
					new GitCommandOption("--dry-run", "--dry-run", @"Do not remove anything; just report the object names whose notes would be removed."),
					new GitCommandOption("--file", "--file=<file>", @"Take the note message from the given file.  Use - to read the note message from the standard input. Lines starting with # and empty lines other than a single line between paragraphs will be stripped out."),
					new GitCommandOption("--force", "--force", @"When adding notes to an object that already has notes, overwrite the existing notes (instead of aborting)."),
					new GitCommandOption("--ignore-missing", "--ignore-missing", @"Do not consider it an error to request removing notes from an object that does not have notes attached to it."),
					new GitCommandOption("--message", "--message=<msg>", @"Use the given note message (instead of prompting). If multiple -m options are given, their values are concatenated as separate paragraphs. Lines starting with # and empty lines other than a single line between paragraphs will be stripped out."),
					new GitCommandOption("--quiet", "--quiet", @"When merging notes, operate quietly."),
					new GitCommandOption("--reedit-message", "--reedit-message=<object>", @"Like -C, but with -c the editor is invoked, so that the user can further edit the note message."),
					new GitCommandOption("--ref", "--ref <ref>", @"Manipulate the notes tree in <ref>.  This overrides GIT_NOTES_REF and the ""core.notesRef"" configuration.  The ref specifies the full refname when it begins with refs/notes/; when it begins with notes/, refs/ and otherwise refs/notes/ is prefixed to form a full name of the ref."),
					new GitCommandOption("--reuse-message", "--reuse-message=<object>", @"Take the given blob object (for example, another note) as the note message. (Use git notes copy <object> instead to copy notes between objects.)"),
					new GitCommandOption("--stdin", "--stdin", @"Also read the object names to remove notes from the standard input (there is no reason you cannot combine this with object names from the command line)."),
					new GitCommandOption("--strategy", "--strategy=<strategy>", @"When merging notes, resolve notes conflicts using the given strategy. The following strategies are recognized: ""manual"" (default), ""ours"", ""theirs"", ""union"" and ""cat_sort_uniq"". This option overrides the ""notes.mergeStrategy"" configuration setting. See the ""NOTES MERGE STRATEGIES"" section below for more information on each notes merge strategy."),
					new GitCommandOption("--verbose", "--verbose", @"When merging notes, be more verbose. When pruning notes, report all object names whose notes are removed."),
					new GitCommandOption("-c", "-c <object>", @"Like -C, but with -c the editor is invoked, so that the user can further edit the note message."),
					new GitCommandOption("-C", "-C <object>", @"Take the given blob object (for example, another note) as the note message. (Use git notes copy <object> instead to copy notes between objects.)"),
					new GitCommandOption("-F", "-F <file>", @"Take the note message from the given file.  Use - to read the note message from the standard input. Lines starting with # and empty lines other than a single line between paragraphs will be stripped out."),
					new GitCommandOption("-f", "-f", @"When adding notes to an object that already has notes, overwrite the existing notes (instead of aborting)."),
					new GitCommandOption("-m", "-m <msg>", @"Use the given note message (instead of prompting). If multiple -m options are given, their values are concatenated as separate paragraphs. Lines starting with # and empty lines other than a single line between paragraphs will be stripped out."),
					new GitCommandOption("-n", "-n", @"Do not remove anything; just report the object names whose notes would be removed."),
					new GitCommandOption("-q", "-q", @"When merging notes, operate quietly."),
					new GitCommandOption("-s", "-s <strategy>", @"When merging notes, resolve notes conflicts using the given strategy. The following strategies are recognized: ""manual"" (default), ""ours"", ""theirs"", ""union"" and ""cat_sort_uniq"". This option overrides the ""notes.mergeStrategy"" configuration setting. See the ""NOTES MERGE STRATEGIES"" section below for more information on each notes merge strategy."),
					new GitCommandOption("-v", "-v", @"When merging notes, be more verbose. When pruning notes, report all object names whose notes are removed."),
				}, 
	"p4" => new GitCommandOption[] {
					new GitCommandOption("--bare", "--bare", @"Perform a bare clone.  See git-clone."),
					new GitCommandOption("--branch", "--branch <branch>", @"After submitting, sync this named branch instead of the default p4/master.  See the ""Sync options"" section above for more information."),
					new GitCommandOption("--branch", "--branch <ref>", @"Import changes into <ref> instead of refs/remotes/p4/master. If <ref> starts with refs/, it is used as is.  Otherwise, if it does not start with p4/, that prefix is added.  By default a <ref> not starting with refs/ is treated as the name of a remote-tracking branch (under refs/remotes/).  This behavior can be modified using the --import-local option.   The default <ref> is ""master"".   This example imports a new remote ""p4/proj2"" into an existing Git repository:        $ git init     $ git p4 sync --branch=refs/remotes/p4/proj2 //depot/proj2"),
					new GitCommandOption("--changes-block-size", "--changes-block-size <n>", @"The internal block size to use when converting a revision specifier such as @all into a list of specific change numbers. Instead of using a single call to p4 changes to find the full list of changes for the conversion, there are a sequence of calls to p4 changes -m, each of which requests one block of changes of the given size. The default block size is 500, which should usually be suitable."),
					new GitCommandOption("--changesfile", "--changesfile <file>", @"Import exactly the p4 change numbers listed in file, one per line.  Normally, git p4 inspects the current p4 repository state and detects the changes it should import."),
					new GitCommandOption("--commit", "--commit (<sha1>|<sha1>..<sha1>)", @"Submit only the specified commit or range of commits, instead of the full list of changes that are in the current Git branch."),
					new GitCommandOption("--conflict", "--conflict=(ask|skip|quit)", @"Conflicts can occur when applying a commit to p4.  When this happens, the default behavior (""ask"") is to prompt whether to skip this commit and continue, or quit.  This option can be used to bypass the prompt, causing conflicting commits to be automatically skipped, or to quit trying to apply commits, without prompting."),
					new GitCommandOption("--destination", "--destination <directory>", @"Where to create the Git repository.  If not provided, the last component in the p4 depot path is used to create a new directory."),
					new GitCommandOption("--detect-branches", "--detect-branches", @"Use the branch detection algorithm to find new paths in p4.  It is documented below in ""BRANCH DETECTION""."),
					new GitCommandOption("--detect-labels", "--detect-labels", @"Query p4 for labels associated with the depot paths, and add them as tags in Git. Limited usefulness as only imports labels associated with new changelists. Deprecated."),
					new GitCommandOption("--disable-p4sync", "--disable-p4sync", @"Disable the automatic sync of p4/master from Perforce after commits have been submitted. Implies --disable-rebase. Can also be set with git-p4.disableP4Sync. Sync with origin/master still goes ahead if possible."),
					new GitCommandOption("--disable-rebase", "--disable-rebase", @"Disable the automatic rebase after all commits have been successfully submitted. Can also be set with git-p4.disableRebase."),
					new GitCommandOption("--dry-run", "--dry-run", @"Show just what commits would be submitted to p4; do not change state in Git or p4."),
					new GitCommandOption("--export-labels", "--export-labels", @"Export tags from Git as p4 labels. Tags found in Git are applied to the perforce working directory."),
					new GitCommandOption("--git-dir", "--git-dir <dir>", @"Set the GIT_DIR environment variable.  See git."),
					new GitCommandOption("--import-labels", "--import-labels", @"Import labels from p4 into Git."),
					new GitCommandOption("--import-local", "--import-local", @"By default, p4 branches are stored in refs/remotes/p4/, where they will be treated as remote-tracking branches by git-branch and other commands.  This option instead puts p4 branches in refs/heads/p4/.  Note that future sync operations must specify --import-local as well so that they can find the p4 branches in refs/heads."),
					new GitCommandOption("--keep-path", "--keep-path", @"The mapping of file names from the p4 depot path to Git, by default, involves removing the entire depot path.  With this option, the full p4 depot path is retained in Git.  For example, path //depot/main/foo/bar.c, when imported from //depot/main/, becomes foo/bar.c.  With --keep-path, the Git path is instead depot/main/foo/bar.c."),
					new GitCommandOption("--max-changes", "--max-changes <n>", @"Import at most n changes, rather than the entire range of changes included in the given revision specifier. A typical usage would be use @all as the revision specifier, but then to use --max-changes 1000 to import only the last 1000 revisions rather than the entire revision history."),
					new GitCommandOption("--origin", "--origin <commit>", @"Upstream location from which commits are identified to submit to p4.  By default, this is the most recent p4 commit reachable from HEAD."),
					new GitCommandOption("--prepare-p4-only", "--prepare-p4-only", @"Apply a commit to the p4 workspace, opening, adding and deleting files in p4 as for a normal submit operation.  Do not issue the final ""p4 submit"", but instead print a message about how to submit manually or revert.  This option always stops after the first (oldest) commit.  Git tags are not exported to p4."),
					new GitCommandOption("--preserve-user", "--preserve-user", @"Re-author p4 changes before submitting to p4.  This option requires p4 admin privileges."),
					new GitCommandOption("--shelve", "--shelve", @"Instead of submitting create a series of shelved changelists. After creating each shelve, the relevant files are reverted/deleted. If you have multiple commits pending multiple shelves will be created."),
					new GitCommandOption("--silent", "--silent", @"Do not print any progress information."),
					new GitCommandOption("--update-shelve", "--update-shelve CHANGELIST", @"Update an existing shelved changelist with this commit. Implies --shelve. Repeat for multiple shelved changelists."),
					new GitCommandOption("--use-client-spec", "--use-client-spec", @"Use a client spec to find the list of interesting files in p4. See the ""CLIENT SPEC"" section below."),
					new GitCommandOption("--verbose", "--verbose", @"Provide more progress information."),
					new GitCommandOption("-/", "-/ <path>", @"Exclude selected depot paths when cloning or syncing."),
					new GitCommandOption("-M", "-M", @"Detect renames.  See git-diff.  Renames will be represented in p4 using explicit move operations.  There is no corresponding option to detect copies, but there are variables for both moves and copies."),
					new GitCommandOption("-n", "-n", @"Show just what commits would be submitted to p4; do not change state in Git or p4."),
					new GitCommandOption("-v", "-v", @"Provide more progress information."),
				}, 
	"pack-objects" => new GitCommandOption[] {
					new GitCommandOption("--[no-]sparse", "--[no-]sparse", @"Toggle the ""sparse"" algorithm to determine which objects to include in the pack, when combined with the ""--revs"" option. This algorithm only walks trees that appear in paths that introduce new objects. This can have significant performance benefits when computing a pack to send a small change. However, it is possible that extra objects are added to the pack-file if the included commits contain certain types of direct renames. If this option is not included, it defaults to the value of pack.useSparse, which is true unless otherwise specified."),
					new GitCommandOption("--all", "--all", @"This implies --revs.  In addition to the list of revision arguments read from the standard input, pretend as if all refs under refs/ are specified to be included."),
					new GitCommandOption("--all-progress", "--all-progress", @"When --stdout is specified then progress report is displayed during the object count and compression phases but inhibited during the write-out phase. The reason is that in some cases the output stream is directly linked to another command which may wish to display progress status of its own as it processes incoming pack data. This flag is like --progress except that it forces progress report for the write-out phase as well even if --stdout is used."),
					new GitCommandOption("--all-progress-implied", "--all-progress-implied", @"This is used to imply --all-progress whenever progress display is activated.  Unlike --all-progress this flag doesn’t actually force any progress display by itself."),
					new GitCommandOption("--compression", "--compression=<n>", @"Specifies compression level for newly-compressed data in the generated pack.  If not specified,  pack compression level is determined first by pack.compression,  then by core.compression, and defaults to -1,  the zlib default,  if neither is set. Add --no-reuse-object if you want to force a uniform compression level on all data no matter the source."),
					new GitCommandOption("--delta-base-offset", "--delta-base-offset", @"A packed archive can express the base object of a delta as either a 20-byte object name or as an offset in the stream, but ancient versions of Git don’t understand the latter.  By default, git pack-objects only uses the former format for better compatibility.  This option allows the command to use the latter format for compactness.  Depending on the average delta chain length, this option typically shrinks the resulting packfile by 3-5 per-cent.  Note: Porcelain commands such as git gc (see git-gc), git repack (see git-repack) pass this option by default in modern Git when they put objects in your repository into pack files. So does git bundle (see git-bundle) when it creates a bundle."),
					new GitCommandOption("--delta-islands", "--delta-islands", @"Restrict delta matches based on ""islands"". See DELTA ISLANDS below."),
					new GitCommandOption("--depth", "--depth=<n>", @"These two options affect how the objects contained in the pack are stored using delta compression.  The objects are first internally sorted by type, size and optionally names and compared against the other objects within --window to see if using delta compression saves space.  --depth limits the maximum delta depth; making it too deep affects the performance on the unpacker side, because delta data needs to be applied that many times to get to the necessary object.  The default value for --window is 10 and --depth is 50. The maximum depth is 4095."),
					new GitCommandOption("--exclude-promisor-objects", "--exclude-promisor-objects", @"Omit objects that are known to be in the promisor remote.  (This option has the purpose of operating only on locally created objects, so that when we repack, we still maintain a distinction between locally created objects [without .promisor] and objects from the promisor remote [with .promisor].)  This is used with partial clone."),
					new GitCommandOption("--filter", "--filter=<filter-spec>", @"Requires --stdout.  Omits certain objects (usually blobs) from the resulting packfile.  See git-rev-list for valid <filter-spec> forms."),
					new GitCommandOption("--honor-pack-keep", "--honor-pack-keep", @"This flag causes an object already in a local pack that has a .keep file to be ignored, even if it would have otherwise been packed."),
					new GitCommandOption("--include-tag", "--include-tag", @"Include unasked-for annotated tags if the object they reference was included in the resulting packfile.  This can be useful to send new tags to native Git clients."),
					new GitCommandOption("--incremental", "--incremental", @"This flag causes an object already in a pack to be ignored even if it would have otherwise been packed."),
					new GitCommandOption("--index-version", "--index-version=<version>[,<offset>]", @"This is intended to be used by the test suite only. It allows to force the version for the generated pack index, and to force 64-bit index entries on objects located above the given offset."),
					new GitCommandOption("--keep-pack", "--keep-pack=<pack-name>", @"This flag causes an object already in the given pack to be ignored, even if it would have otherwise been packed. <pack-name> is the pack file name without leading directory (e.g. pack-123.pack). The option could be specified multiple times to keep multiple packs."),
					new GitCommandOption("--keep-true-parents", "--keep-true-parents", @"With this option, parents that are hidden by grafts are packed nevertheless."),
					new GitCommandOption("--keep-unreachable", "--keep-unreachable", @"Objects unreachable from the refs in packs named with --unpacked= option are added to the resulting pack, in addition to the reachable objects that are not in packs marked with *.keep files. This implies --revs."),
					new GitCommandOption("--local", "--local", @"This flag causes an object that is borrowed from an alternate object store to be ignored even if it would have otherwise been packed."),
					new GitCommandOption("--max-pack-size", "--max-pack-size=<n>", @"In unusual scenarios, you may not be able to create files larger than a certain size on your filesystem, and this option can be used to tell the command to split the output packfile into multiple independent packfiles, each not larger than the given size. The size can be suffixed with ""k"", ""m"", or ""g"". The minimum size allowed is limited to 1 MiB. The default is unlimited, unless the config variable pack.packSizeLimit is set. Note that this option may result in a larger and slower repository; see the discussion in pack.packSizeLimit."),
					new GitCommandOption("--missing", "--missing=<missing-action>", @"A debug option to help with future ""partial clone"" development. This option specifies how missing objects are handled.  The form --missing=error requests that pack-objects stop with an error if a missing object is encountered.  If the repository is a partial clone, an attempt to fetch missing objects will be made before declaring them missing. This is the default action.   The form --missing=allow-any will allow object traversal to continue if a missing object is encountered.  No fetch of a missing object will occur. Missing objects will silently be omitted from the results.   The form --missing=allow-promisor is like allow-any, but will only allow object traversal to continue for EXPECTED promisor missing objects. No fetch of a missing object will occur.  An unexpected missing object will raise an error."),
					new GitCommandOption("--no-filter", "--no-filter", @"Turns off any previous --filter= argument."),
					new GitCommandOption("--no-reuse-delta", "--no-reuse-delta", @"When creating a packed archive in a repository that has existing packs, the command reuses existing deltas. This sometimes results in a slightly suboptimal pack. This flag tells the command not to reuse existing deltas but compute them from scratch."),
					new GitCommandOption("--no-reuse-object", "--no-reuse-object", @"This flag tells the command not to reuse existing object data at all, including non deltified object, forcing recompression of everything. This implies --no-reuse-delta. Useful only in the obscure case where wholesale enforcement of a different compression level on the packed data is desired."),
					new GitCommandOption("--non-empty", "--non-empty", @"Only create a packed archive if it would contain at least one object."),
					new GitCommandOption("--pack-loose-unreachable", "--pack-loose-unreachable", @"Pack unreachable loose objects (and their loose counterparts removed). This implies --revs."),
					new GitCommandOption("--progress", "--progress", @"Progress status is reported on the standard error stream by default when it is attached to a terminal, unless -q is specified. This flag forces progress status even if the standard error stream is not directed to a terminal."),
					new GitCommandOption("--revs", "--revs", @"Read the revision arguments from the standard input, instead of individual object names.  The revision arguments are processed the same way as git rev-list with the --objects flag uses its commit arguments to build the list of objects it outputs.  The objects on the resulting list are packed. Besides revisions, --not or --shallow <SHA-1> lines are also accepted."),
					new GitCommandOption("--shallow", "--shallow", @"Optimize a pack that will be provided to a client with a shallow repository.  This option, combined with --thin, can result in a smaller pack at the cost of speed."),
					new GitCommandOption("--stdin-packs", "--stdin-packs", @"Read the basenames of packfiles (e.g., pack-1234abcd.pack) from the standard input, instead of object names or revision arguments. The resulting pack contains all objects listed in the included packs (those not beginning with ^), excluding any objects listed in the excluded packs (beginning with ^).  Incompatible with --revs, or options that imply --revs (such as --all), with the exception of --unpacked, which is compatible."),
					new GitCommandOption("--stdout", "--stdout", @"Write the pack contents (what would have been written to .pack file) out to the standard output."),
					new GitCommandOption("--thin", "--thin", @"Create a ""thin"" pack by omitting the common objects between a sender and a receiver in order to reduce network transfer. This option only makes sense in conjunction with --stdout.  Note: A thin pack violates the packed archive format by omitting required objects and is thus unusable by Git without making it self-contained. Use git index-pack --fix-thin (see git-index-pack) to restore the self-contained property."),
					new GitCommandOption("--threads", "--threads=<n>", @"Specifies the number of threads to spawn when searching for best delta matches.  This requires that pack-objects be compiled with pthreads otherwise this option is ignored with a warning. This is meant to reduce packing time on multiprocessor machines. The required amount of memory for the delta search window is however multiplied by the number of threads. Specifying 0 will cause Git to auto-detect the number of CPU’s and set the number of threads accordingly."),
					new GitCommandOption("--unpack-unreachable", "--unpack-unreachable", @"Keep unreachable objects in loose form. This implies --revs."),
					new GitCommandOption("--unpacked", "--unpacked", @"This implies --revs.  When processing the list of revision arguments read from the standard input, limit the objects packed to those that are not already packed."),
					new GitCommandOption("--window", "--window=<n>", @"These two options affect how the objects contained in the pack are stored using delta compression.  The objects are first internally sorted by type, size and optionally names and compared against the other objects within --window to see if using delta compression saves space.  --depth limits the maximum delta depth; making it too deep affects the performance on the unpacker side, because delta data needs to be applied that many times to get to the necessary object.  The default value for --window is 10 and --depth is 50. The maximum depth is 4095."),
					new GitCommandOption("--window-memory", "--window-memory=<n>", @"This option provides an additional limit on top of --window; the window size will dynamically scale down so as to not take up more than <n> bytes in memory.  This is useful in repositories with a mix of large and small objects to not run out of memory with a large window, but still be able to take advantage of the large window for the smaller objects.  The size can be suffixed with ""k"", ""m"", or ""g"". --window-memory=0 makes memory usage unlimited.  The default is taken from the pack.windowMemory configuration variable."),
					new GitCommandOption("-q", "-q", @"This flag makes the command not to report its progress on the standard error stream."),
					new GitCommandOption("base-name", "base-name", @"Write into pairs of files (.pack and .idx), using <base-name> to determine the name of the created file. When this option is used, the two files in a pair are written in <base-name>-<SHA-1>.{pack,idx} files.  <SHA-1> is a hash based on the pack content and is written to the standard output of the command."),
				}, 
	"pack-redundant" => new GitCommandOption[] {
					new GitCommandOption("--all", "--all", @"Processes all packs. Any filenames on the command line are ignored."),
					new GitCommandOption("--alt-odb", "--alt-odb", @"Don’t require objects present in packs from alternate object directories to be present in local packs."),
					new GitCommandOption("--verbose", "--verbose", @"Outputs some statistics to stderr. Has a small performance penalty."),
				}, 
	"pack-refs" => new GitCommandOption[] {
					new GitCommandOption("--all", "--all", @"The command by default packs all tags and refs that are already packed, and leaves other refs alone.  This is because branches are expected to be actively developed and packing their tips does not help performance. This option causes branch tips to be packed as well.  Useful for a repository with many branches of historical interests."),
					new GitCommandOption("--no-prune", "--no-prune", @"The command usually removes loose refs under $GIT_DIR/refs hierarchy after packing them.  This option tells it not to."),
				}, 
	"patch-id" => new GitCommandOption[] {
					new GitCommandOption("--stable", "--stable", @"Use a ""stable"" sum of hashes as the patch ID. With this option:    Reordering file diffs that make up a patch does not affect the ID. In particular, two patches produced by comparing the same two trees with two different settings for ""-O<orderfile>"" result in the same patch ID signature, thereby allowing the computed result to be used as a key to index some meta-information about the change between the two trees;   Result is different from the value produced by git 1.9 and older or produced when an ""unstable"" hash (see --unstable below) is configured - even when used on a diff output taken without any use of ""-O<orderfile>"", thereby making existing databases storing such ""unstable"" or historical patch-ids unusable.   This is the default if patchid.stable is set to true."),
					new GitCommandOption("--unstable", "--unstable", @"Use an ""unstable"" hash as the patch ID. With this option, the result produced is compatible with the patch-id value produced by git 1.9 and older.  Users with pre-existing databases storing patch-ids produced by git 1.9 and older (who do not deal with reordered patches) may want to use this option.   This is the default."),
				}, 
	"prune-packed" => new GitCommandOption[] {
					new GitCommandOption("--dry-run", "--dry-run", @"Don’t actually remove any objects, only show those that would have been removed."),
					new GitCommandOption("--quiet", "--quiet", @"Squelch the progress indicator."),
					new GitCommandOption("-n", "-n", @"Don’t actually remove any objects, only show those that would have been removed."),
					new GitCommandOption("-q", "-q", @"Squelch the progress indicator."),
				}, 
	"prune" => new GitCommandOption[] {
					new GitCommandOption("<head>…​", "<head>…​", @"In addition to objects reachable from any of our references, keep objects reachable from listed <head>s."),
					new GitCommandOption("--", "--", @"Do not interpret any more arguments as options."),
					new GitCommandOption("--dry-run", "--dry-run", @"Do not remove anything; just report what it would remove."),
					new GitCommandOption("--expire", "--expire <time>", @"Only expire loose objects older than <time>."),
					new GitCommandOption("--progress", "--progress", @"Show progress."),
					new GitCommandOption("--verbose", "--verbose", @"Report all removed objects."),
					new GitCommandOption("-n", "-n", @"Do not remove anything; just report what it would remove."),
					new GitCommandOption("-v", "-v", @"Report all removed objects."),
				}, 
	"pull" => new GitCommandOption[] {
					new GitCommandOption("<refspec>", "<refspec>", @"Specifies which refs to fetch and which local refs to update. When no <refspec>s appear on the command line, the refs to fetch are read from remote.<repository>.fetch variables instead (see the section ""CONFIGURED REMOTE-TRACKING BRANCHES"" in git-fetch).  The format of a <refspec> parameter is an optional plus +, followed by the source <src>, followed by a colon :, followed by the destination ref <dst>. The colon can be omitted when <dst> is empty.  <src> is typically a ref, but it can also be a fully spelled hex object name.   A <refspec> may contain a * in its <src> to indicate a simple pattern match. Such a refspec functions like a glob that matches any ref with the same prefix. A pattern <refspec> must have a * in both the <src> and <dst>. It will map refs to the destination by replacing the * with the contents matched from the source.   If a refspec is prefixed by ^, it will be interpreted as a negative refspec. Rather than specifying which refs to fetch or which local refs to update, such a refspec will instead specify refs to exclude. A ref will be considered to match if it matches at least one positive refspec, and does not match any negative refspec. Negative refspecs can be useful to restrict the scope of a pattern refspec so that it will not include specific refs. Negative refspecs can themselves be pattern refspecs. However, they may only contain a <src> and do not specify a <dst>. Fully spelled out hex object names are also not supported.   tag <tag> means the same as refs/tags/<tag>:refs/tags/<tag>; it requests fetching everything up to the given tag.   The remote ref that matches <src> is fetched, and if <dst> is not an empty string, an attempt is made to update the local ref that matches it.   Whether that update is allowed without --force depends on the ref namespace it’s being fetched to, the type of object being fetched, and whether the update is considered to be a fast-forward. Generally, the same rules apply for fetching as when pushing, see the <refspec>... section of git-push for what those are. Exceptions to those rules particular to git fetch are noted below.   Until Git version 2.20, and unlike when pushing with git-push, any updates to refs/tags/* would be accepted without + in the refspec (or --force). When fetching, we promiscuously considered all tag updates from a remote to be forced fetches.  Since Git version 2.20, fetching to update refs/tags/* works the same way as when pushing. I.e. any updates will be rejected without + in the refspec (or --force).   Unlike when pushing with git-push, any updates outside of refs/{tags,heads}/* will be accepted without + in the refspec (or --force), whether that’s swapping e.g. a tree object for a blob, or a commit for another commit that’s doesn’t have the previous commit as an ancestor etc.   Unlike when pushing with git-push, there is no configuration which’ll amend these rules, and nothing like a pre-fetch hook analogous to the pre-receive hook.   As with pushing with git-push, all of the rules described above about what’s not allowed as an update can be overridden by adding an the optional leading + to a refspec (or using --force command line option). The only exception to this is that no amount of forcing will make the refs/heads/* namespace accept a non-commit object.      Note   When the remote branch you want to fetch is known to be rewound and rebased regularly, it is expected that its new tip will not be descendant of its previous tip (as stored in your remote-tracking branch the last time you fetched).  You would want to use the + sign to indicate non-fast-forward updates will be needed for such branches.  There is no way to determine or declare that a branch will be made available in a repository with this behavior; the pulling user simply must know this is the expected usage pattern for a branch.         Note   There is a difference between listing multiple <refspec> directly on git pull command line and having multiple remote.<repository>.fetch entries in your configuration for a <repository> and running a git pull command without any explicit <refspec> parameters. <refspec>s listed explicitly on the command line are always merged into the current branch after fetching.  In other words, if you list more than one remote ref, git pull will create an Octopus merge.  On the other hand, if you do not list any explicit <refspec> parameter on the command line, git pull will fetch all the <refspec>s it finds in the remote.<repository>.fetch configuration and merge only the first <refspec> found into the current branch. This is because making an Octopus from remote refs is rarely done, while keeping track of multiple remote heads in one-go by fetching more than one is often useful."),
					new GitCommandOption("<repository>", "<repository>", @"The ""remote"" repository that is the source of a fetch or pull operation.  This parameter can be either a URL (see the section GIT URLS below) or the name of a remote (see the section REMOTES below)."),
					new GitCommandOption("--[no-]recurse-submodules[", "--[no-]recurse-submodules[=yes|on-demand|no]", @"This option controls if new commits of populated submodules should be fetched, and if the working trees of active submodules should be updated, too (see git-fetch, git-config and gitmodules).  If the checkout is done via rebase, local submodule commits are rebased as well.   If the update is done via merge, the submodule conflicts are resolved and checked out."),
					new GitCommandOption("--[no-]verify", "--[no-]verify", @"By default, the pre-merge and commit-msg hooks are run. When --no-verify is given, these are bypassed. See also githooks. Only useful when merging."),
					new GitCommandOption("--all", "--all", @"Fetch all remotes."),
					new GitCommandOption("--allow-unrelated-histories", "--allow-unrelated-histories", @"By default, git merge command refuses to merge histories that do not share a common ancestor.  This option can be used to override this safety when merging histories of two projects that started their lives independently. As that is a very rare occasion, no configuration variable to enable this by default exists and will not be added.  Only useful when merging."),
					new GitCommandOption("--append", "--append", @"Append ref names and object names of fetched refs to the existing contents of .git/FETCH_HEAD.  Without this option old data in .git/FETCH_HEAD will be overwritten."),
					new GitCommandOption("--atomic", "--atomic", @"Use an atomic transaction to update local refs. Either all refs are updated, or on error, no refs are updated."),
					new GitCommandOption("--autostash", "--autostash", @"Automatically create a temporary stash entry before the operation begins, record it in the special ref MERGE_AUTOSTASH and apply it after the operation ends.  This means that you can run the operation on a dirty worktree.  However, use with care: the final stash application after a successful merge might result in non-trivial conflicts."),
					new GitCommandOption("--cleanup", "--cleanup=<mode>", @"This option determines how the merge message will be cleaned up before committing. See git-commit for more details. In addition, if the <mode> is given a value of scissors, scissors will be appended to MERGE_MSG before being passed on to the commit machinery in the case of a merge conflict."),
					new GitCommandOption("--commit", "--commit", @"Perform the merge and commit the result. This option can be used to override --no-commit. Only useful when merging.  With --no-commit perform the merge and stop just before creating a merge commit, to give the user a chance to inspect and further tweak the merge result before committing.   Note that fast-forward updates do not create a merge commit and therefore there is no way to stop those merges with --no-commit. Thus, if you want to ensure your branch is not changed or updated by the merge command, use --no-ff with --no-commit."),
					new GitCommandOption("--deepen", "--deepen=<depth>", @"Similar to --depth, except it specifies the number of commits from the current shallow boundary instead of from the tip of each remote branch history."),
					new GitCommandOption("--depth", "--depth=<depth>", @"Limit fetching to the specified number of commits from the tip of each remote branch history. If fetching to a shallow repository created by git clone with --depth=<depth> option (see git-clone), deepen or shorten the history to the specified number of commits. Tags for the deepened commits are not fetched."),
					new GitCommandOption("--dry-run", "--dry-run", @"Show what would be done, without making any changes."),
					new GitCommandOption("--edit", "--edit", @"Invoke an editor before committing successful mechanical merge to further edit the auto-generated merge message, so that the user can explain and justify the merge. The --no-edit option can be used to accept the auto-generated message (this is generally discouraged).  Older scripts may depend on the historical behaviour of not allowing the user to edit the merge log message. They will see an editor opened when they run git merge. To make it easier to adjust such scripts to the updated behaviour, the environment variable GIT_MERGE_AUTOEDIT can be set to no at the beginning of them."),
					new GitCommandOption("--ff", "--ff", @"When merging rather than rebasing, specifies how a merge is handled when the merged-in history is already a descendant of the current history.  If merging is requested, --ff is the default unless merging an annotated (and possibly signed) tag that is not stored in its natural place in the refs/tags/ hierarchy, in which case --no-ff is assumed.  With --ff, when possible resolve the merge as a fast-forward (only update the branch pointer to match the merged branch; do not create a merge commit).  When not possible (when the merged-in history is not a descendant of the current history), create a merge commit.   With --no-ff, create a merge commit in all cases, even when the merge could instead be resolved as a fast-forward."),
					new GitCommandOption("--ff-only", "--ff-only", @"Only update to the new history if there is no divergent local history.  This is the default when no method for reconciling divergent histories is provided (via the --rebase=* flags)."),
					new GitCommandOption("--force", "--force", @"When git fetch is used with <src>:<dst> refspec it may refuse to update the local branch as discussed in the <refspec> part of the git-fetch documentation. This option overrides that check."),
					new GitCommandOption("--gpg-sign[", "--gpg-sign[=<keyid>]", @"GPG-sign the resulting merge commit. The keyid argument is optional and defaults to the committer identity; if specified, it must be stuck to the option without a space. --no-gpg-sign is useful to countermand both commit.gpgSign configuration variable, and earlier --gpg-sign."),
					new GitCommandOption("--ipv4", "--ipv4", @"Use IPv4 addresses only, ignoring IPv6 addresses."),
					new GitCommandOption("--ipv6", "--ipv6", @"Use IPv6 addresses only, ignoring IPv4 addresses."),
					new GitCommandOption("--jobs", "--jobs=<n>", @"Number of parallel children to be used for all forms of fetching.  If the --multiple option was specified, the different remotes will be fetched in parallel. If multiple submodules are fetched, they will be fetched in parallel. To control them independently, use the config settings fetch.parallel and submodule.fetchJobs (see git-config).   Typically, parallel recursive and multi-remote fetches will be faster. By default fetches are performed sequentially, not in parallel."),
					new GitCommandOption("--keep", "--keep", @"Keep downloaded pack."),
					new GitCommandOption("--log[", "--log[=<n>]", @"In addition to branch names, populate the log message with one-line descriptions from at most <n> actual commits that are being merged. See also git-fmt-merge-msg. Only useful when merging.  With --no-log do not list one-line descriptions from the actual commits being merged."),
					new GitCommandOption("--negotiate-only", "--negotiate-only", @"Do not fetch anything from the server, and instead print the ancestors of the provided --negotiation-tip=* arguments, which we have in common with the server.  This is incompatible with --recurse-submodules=[yes|on-demand]. Internally this is used to implement the push.negotiate option, see git-config."),
					new GitCommandOption("--negotiation-tip", "--negotiation-tip=<commit|glob>", @"By default, Git will report, to the server, commits reachable from all local refs to find common commits in an attempt to reduce the size of the to-be-received packfile. If specified, Git will only report commits reachable from the given tips. This is useful to speed up fetches when the user knows which local ref is likely to have commits in common with the upstream ref being fetched.  This option may be specified more than once; if so, Git will report commits reachable from any of the given commits.   The argument to this option may be a glob on ref names, a ref, or the (possibly abbreviated) SHA-1 of a commit. Specifying a glob is equivalent to specifying this option multiple times, one for each matching ref name.   See also the fetch.negotiationAlgorithm and push.negotiate configuration variables documented in git-config, and the --negotiate-only option below."),
					new GitCommandOption("--no-autostash", "--no-autostash", @"Automatically create a temporary stash entry before the operation begins, record it in the special ref MERGE_AUTOSTASH and apply it after the operation ends.  This means that you can run the operation on a dirty worktree.  However, use with care: the final stash application after a successful merge might result in non-trivial conflicts."),
					new GitCommandOption("--no-commit", "--no-commit", @"Perform the merge and commit the result. This option can be used to override --no-commit. Only useful when merging.  With --no-commit perform the merge and stop just before creating a merge commit, to give the user a chance to inspect and further tweak the merge result before committing.   Note that fast-forward updates do not create a merge commit and therefore there is no way to stop those merges with --no-commit. Thus, if you want to ensure your branch is not changed or updated by the merge command, use --no-ff with --no-commit."),
					new GitCommandOption("--no-edit", "--no-edit", @"Invoke an editor before committing successful mechanical merge to further edit the auto-generated merge message, so that the user can explain and justify the merge. The --no-edit option can be used to accept the auto-generated message (this is generally discouraged).  Older scripts may depend on the historical behaviour of not allowing the user to edit the merge log message. They will see an editor opened when they run git merge. To make it easier to adjust such scripts to the updated behaviour, the environment variable GIT_MERGE_AUTOEDIT can be set to no at the beginning of them."),
					new GitCommandOption("--no-ff", "--no-ff", @"When merging rather than rebasing, specifies how a merge is handled when the merged-in history is already a descendant of the current history.  If merging is requested, --ff is the default unless merging an annotated (and possibly signed) tag that is not stored in its natural place in the refs/tags/ hierarchy, in which case --no-ff is assumed.  With --ff, when possible resolve the merge as a fast-forward (only update the branch pointer to match the merged branch; do not create a merge commit).  When not possible (when the merged-in history is not a descendant of the current history), create a merge commit.   With --no-ff, create a merge commit in all cases, even when the merge could instead be resolved as a fast-forward."),
					new GitCommandOption("--no-gpg-sign", "--no-gpg-sign", @"GPG-sign the resulting merge commit. The keyid argument is optional and defaults to the committer identity; if specified, it must be stuck to the option without a space. --no-gpg-sign is useful to countermand both commit.gpgSign configuration variable, and earlier --gpg-sign."),
					new GitCommandOption("--no-log", "--no-log", @"In addition to branch names, populate the log message with one-line descriptions from at most <n> actual commits that are being merged. See also git-fmt-merge-msg. Only useful when merging.  With --no-log do not list one-line descriptions from the actual commits being merged."),
					new GitCommandOption("--no-rebase", "--no-rebase", @"This is shorthand for --rebase=false."),
					new GitCommandOption("--no-show-forced-updates", "--no-show-forced-updates", @"By default, git checks if a branch is force-updated during fetch. Pass --no-show-forced-updates or set fetch.showForcedUpdates to false to skip this check for performance reasons. If used during git-pull the --ff-only option will still check for forced updates before attempting a fast-forward update. See git-config."),
					new GitCommandOption("--no-signoff", "--no-signoff", @"Add a Signed-off-by trailer by the committer at the end of the commit log message.  The meaning of a signoff depends on the project to which you’re committing.  For example, it may certify that the committer has the rights to submit the work under the project’s license or agrees to some contributor representation, such as a Developer Certificate of Origin. (See http://developercertificate.org for the one used by the Linux kernel and Git projects.)  Consult the documentation or leadership of the project to which you’re contributing to understand how the signoffs are used in that project.  The --no-signoff option can be used to countermand an earlier --signoff option on the command line."),
					new GitCommandOption("--no-squash", "--no-squash", @"Produce the working tree and index state as if a real merge happened (except for the merge information), but do not actually make a commit, move the HEAD, or record $GIT_DIR/MERGE_HEAD (to cause the next git commit command to create a merge commit).  This allows you to create a single commit on top of the current branch whose effect is the same as merging another branch (or more in case of an octopus).  With --no-squash perform the merge and commit the result. This option can be used to override --squash.   With --squash, --commit is not allowed, and will fail.   Only useful when merging."),
					new GitCommandOption("--no-stat", "--no-stat", @"Show a diffstat at the end of the merge. The diffstat is also controlled by the configuration option merge.stat.  With -n or --no-stat do not show a diffstat at the end of the merge."),
					new GitCommandOption("--no-summary", "--no-summary", @"Synonyms to --stat and --no-stat; these are deprecated and will be removed in the future."),
					new GitCommandOption("--no-tags", "--no-tags", @"By default, tags that point at objects that are downloaded from the remote repository are fetched and stored locally. This option disables this automatic tag following. The default behavior for a remote may be specified with the remote.<name>.tagOpt setting. See git-config."),
					new GitCommandOption("--no-verify-signatures", "--no-verify-signatures", @"Verify that the tip commit of the side branch being merged is signed with a valid key, i.e. a key that has a valid uid: in the default trust model, this means the signing key has been signed by a trusted key.  If the tip commit of the side branch is not signed with a valid key, the merge is aborted.  Only useful when merging."),
					new GitCommandOption("--prefetch", "--prefetch", @"Modify the configured refspec to place all refs into the refs/prefetch/ namespace. See the prefetch task in git-maintenance."),
					new GitCommandOption("--progress", "--progress", @"Progress status is reported on the standard error stream by default when it is attached to a terminal, unless -q is specified. This flag forces progress status even if the standard error stream is not directed to a terminal."),
					new GitCommandOption("--prune", "--prune", @"Before fetching, remove any remote-tracking references that no longer exist on the remote.  Tags are not subject to pruning if they are fetched only because of the default tag auto-following or due to a --tags option.  However, if tags are fetched due to an explicit refspec (either on the command line or in the remote configuration, for example if the remote was cloned with the --mirror option), then they are also subject to pruning. Supplying --prune-tags is a shorthand for providing the tag refspec."),
					new GitCommandOption("--quiet", "--quiet", @"This is passed to both underlying git-fetch to squelch reporting of during transfer, and underlying git-merge to squelch output during merging."),
					new GitCommandOption("--rebase[", "--rebase[=false|true|merges|interactive]", @"When true, rebase the current branch on top of the upstream branch after fetching. If there is a remote-tracking branch corresponding to the upstream branch and the upstream branch was rebased since last fetched, the rebase uses that information to avoid rebasing non-local changes.  When set to merges, rebase using git rebase --rebase-merges so that the local merge commits are included in the rebase (see git-rebase for details).   When false, merge the upstream branch into the current branch.   When interactive, enable the interactive mode of rebase.   See pull.rebase, branch.<name>.rebase and branch.autoSetupRebase in git-config if you want to make git pull always use --rebase instead of merging.      Note   This is a potentially dangerous mode of operation. It rewrites history, which does not bode well when you published that history already.  Do not use this option unless you have read git-rebase carefully."),
					new GitCommandOption("--refmap", "--refmap=<refspec>", @"When fetching refs listed on the command line, use the specified refspec (can be given more than once) to map the refs to remote-tracking branches, instead of the values of remote.*.fetch configuration variables for the remote repository.  Providing an empty <refspec> to the --refmap option causes Git to ignore the configured refspecs and rely entirely on the refspecs supplied as command-line arguments. See section on ""Configured Remote-tracking Branches"" for details."),
					new GitCommandOption("--server-option", "--server-option=<option>", @"Transmit the given string to the server when communicating using protocol version 2.  The given string must not contain a NUL or LF character.  The server’s handling of server options, including unknown ones, is server-specific. When multiple --server-option=<option> are given, they are all sent to the other side in the order listed on the command line."),
					new GitCommandOption("--set-upstream", "--set-upstream", @"If the remote is fetched successfully, add upstream (tracking) reference, used by argument-less git-pull and other commands. For more information, see branch.<name>.merge and branch.<name>.remote in git-config."),
					new GitCommandOption("--shallow-exclude", "--shallow-exclude=<revision>", @"Deepen or shorten the history of a shallow repository to exclude commits reachable from a specified remote branch or tag. This option can be specified multiple times."),
					new GitCommandOption("--shallow-since", "--shallow-since=<date>", @"Deepen or shorten the history of a shallow repository to include all reachable commits after <date>."),
					new GitCommandOption("--show-forced-updates", "--show-forced-updates", @"By default, git checks if a branch is force-updated during fetch. This can be disabled through fetch.showForcedUpdates, but the --show-forced-updates option guarantees this check occurs. See git-config."),
					new GitCommandOption("--signoff", "--signoff", @"Add a Signed-off-by trailer by the committer at the end of the commit log message.  The meaning of a signoff depends on the project to which you’re committing.  For example, it may certify that the committer has the rights to submit the work under the project’s license or agrees to some contributor representation, such as a Developer Certificate of Origin. (See http://developercertificate.org for the one used by the Linux kernel and Git projects.)  Consult the documentation or leadership of the project to which you’re contributing to understand how the signoffs are used in that project.  The --no-signoff option can be used to countermand an earlier --signoff option on the command line."),
					new GitCommandOption("--squash", "--squash", @"Produce the working tree and index state as if a real merge happened (except for the merge information), but do not actually make a commit, move the HEAD, or record $GIT_DIR/MERGE_HEAD (to cause the next git commit command to create a merge commit).  This allows you to create a single commit on top of the current branch whose effect is the same as merging another branch (or more in case of an octopus).  With --no-squash perform the merge and commit the result. This option can be used to override --squash.   With --squash, --commit is not allowed, and will fail.   Only useful when merging."),
					new GitCommandOption("--stat", "--stat", @"Show a diffstat at the end of the merge. The diffstat is also controlled by the configuration option merge.stat.  With -n or --no-stat do not show a diffstat at the end of the merge."),
					new GitCommandOption("--strategy", "--strategy=<strategy>", @"Use the given merge strategy; can be supplied more than once to specify them in the order they should be tried. If there is no -s option, a built-in list of strategies is used instead (ort when merging a single head, octopus otherwise)."),
					new GitCommandOption("--strategy-option", "--strategy-option=<option>", @"Pass merge strategy specific option through to the merge strategy."),
					new GitCommandOption("--summary", "--summary", @"Synonyms to --stat and --no-stat; these are deprecated and will be removed in the future."),
					new GitCommandOption("--tags", "--tags", @"Fetch all tags from the remote (i.e., fetch remote tags refs/tags/* into local tags with the same name), in addition to whatever else would otherwise be fetched.  Using this option alone does not subject tags to pruning, even if --prune is used (though tags may be pruned anyway if they are also the destination of an explicit refspec; see --prune)."),
					new GitCommandOption("--unshallow", "--unshallow", @"If the source repository is complete, convert a shallow repository to a complete one, removing all the limitations imposed by shallow repositories.  If the source repository is shallow, fetch as much as possible so that the current repository has the same history as the source repository."),
					new GitCommandOption("--update-shallow", "--update-shallow", @"By default when fetching from a shallow repository, git fetch refuses refs that require updating .git/shallow. This option updates .git/shallow and accept such refs."),
					new GitCommandOption("--upload-pack", "--upload-pack <upload-pack>", @"When given, and the repository to fetch from is handled by git fetch-pack, --exec=<upload-pack> is passed to the command to specify non-default path for the command run on the other end."),
					new GitCommandOption("--verbose", "--verbose", @"Pass --verbose to git-fetch and git-merge."),
					new GitCommandOption("--verify-signatures", "--verify-signatures", @"Verify that the tip commit of the side branch being merged is signed with a valid key, i.e. a key that has a valid uid: in the default trust model, this means the signing key has been signed by a trusted key.  If the tip commit of the side branch is not signed with a valid key, the merge is aborted.  Only useful when merging."),
					new GitCommandOption("-4", "-4", @"Use IPv4 addresses only, ignoring IPv6 addresses."),
					new GitCommandOption("-6", "-6", @"Use IPv6 addresses only, ignoring IPv4 addresses."),
					new GitCommandOption("-a", "-a", @"Append ref names and object names of fetched refs to the existing contents of .git/FETCH_HEAD.  Without this option old data in .git/FETCH_HEAD will be overwritten."),
					new GitCommandOption("-e", "-e", @"Invoke an editor before committing successful mechanical merge to further edit the auto-generated merge message, so that the user can explain and justify the merge. The --no-edit option can be used to accept the auto-generated message (this is generally discouraged).  Older scripts may depend on the historical behaviour of not allowing the user to edit the merge log message. They will see an editor opened when they run git merge. To make it easier to adjust such scripts to the updated behaviour, the environment variable GIT_MERGE_AUTOEDIT can be set to no at the beginning of them."),
					new GitCommandOption("-f", "-f", @"When git fetch is used with <src>:<dst> refspec it may refuse to update the local branch as discussed in the <refspec> part of the git-fetch documentation. This option overrides that check."),
					new GitCommandOption("-j", "-j", @"Number of parallel children to be used for all forms of fetching.  If the --multiple option was specified, the different remotes will be fetched in parallel. If multiple submodules are fetched, they will be fetched in parallel. To control them independently, use the config settings fetch.parallel and submodule.fetchJobs (see git-config).   Typically, parallel recursive and multi-remote fetches will be faster. By default fetches are performed sequentially, not in parallel."),
					new GitCommandOption("-k", "-k", @"Keep downloaded pack."),
					new GitCommandOption("-n", "-n", @"Show a diffstat at the end of the merge. The diffstat is also controlled by the configuration option merge.stat.  With -n or --no-stat do not show a diffstat at the end of the merge."),
					new GitCommandOption("-o", "-o <option>", @"Transmit the given string to the server when communicating using protocol version 2.  The given string must not contain a NUL or LF character.  The server’s handling of server options, including unknown ones, is server-specific. When multiple --server-option=<option> are given, they are all sent to the other side in the order listed on the command line."),
					new GitCommandOption("-p", "-p", @"Before fetching, remove any remote-tracking references that no longer exist on the remote.  Tags are not subject to pruning if they are fetched only because of the default tag auto-following or due to a --tags option.  However, if tags are fetched due to an explicit refspec (either on the command line or in the remote configuration, for example if the remote was cloned with the --mirror option), then they are also subject to pruning. Supplying --prune-tags is a shorthand for providing the tag refspec."),
					new GitCommandOption("-q", "-q", @"This is passed to both underlying git-fetch to squelch reporting of during transfer, and underlying git-merge to squelch output during merging."),
					new GitCommandOption("-r", "-r", @"When true, rebase the current branch on top of the upstream branch after fetching. If there is a remote-tracking branch corresponding to the upstream branch and the upstream branch was rebased since last fetched, the rebase uses that information to avoid rebasing non-local changes.  When set to merges, rebase using git rebase --rebase-merges so that the local merge commits are included in the rebase (see git-rebase for details).   When false, merge the upstream branch into the current branch.   When interactive, enable the interactive mode of rebase.   See pull.rebase, branch.<name>.rebase and branch.autoSetupRebase in git-config if you want to make git pull always use --rebase instead of merging.      Note   This is a potentially dangerous mode of operation. It rewrites history, which does not bode well when you published that history already.  Do not use this option unless you have read git-rebase carefully."),
					new GitCommandOption("-s", "-s <strategy>", @"Use the given merge strategy; can be supplied more than once to specify them in the order they should be tried. If there is no -s option, a built-in list of strategies is used instead (ort when merging a single head, octopus otherwise)."),
					new GitCommandOption("-S[<keyid>]", "-S[<keyid>]", @"GPG-sign the resulting merge commit. The keyid argument is optional and defaults to the committer identity; if specified, it must be stuck to the option without a space. --no-gpg-sign is useful to countermand both commit.gpgSign configuration variable, and earlier --gpg-sign."),
					new GitCommandOption("-t", "-t", @"Fetch all tags from the remote (i.e., fetch remote tags refs/tags/* into local tags with the same name), in addition to whatever else would otherwise be fetched.  Using this option alone does not subject tags to pruning, even if --prune is used (though tags may be pruned anyway if they are also the destination of an explicit refspec; see --prune)."),
					new GitCommandOption("-v", "-v", @"Pass --verbose to git-fetch and git-merge."),
					new GitCommandOption("-X", "-X <option>", @"Pass merge strategy specific option through to the merge strategy."),
				}, 
	"push" => new GitCommandOption[] {
					new GitCommandOption("<refspec>…​", "<refspec>…​", @"Specify what destination ref to update with what source object. The format of a <refspec> parameter is an optional plus +, followed by the source object <src>, followed by a colon :, followed by the destination ref <dst>.  The <src> is often the name of the branch you would want to push, but it can be any arbitrary ""SHA-1 expression"", such as master~4 or HEAD (see gitrevisions).   The <dst> tells which ref on the remote side is updated with this push. Arbitrary expressions cannot be used here, an actual ref must be named. If git push [<repository>] without any <refspec> argument is set to update some ref at the destination with <src> with remote.<repository>.push configuration variable, :<dst> part can be omitted—​such a push will update a ref that <src> normally updates without any <refspec> on the command line.  Otherwise, missing :<dst> means to update the same ref as the <src>.   If <dst> doesn’t start with refs/ (e.g. refs/heads/master) we will try to infer where in refs/* on the destination <repository> it belongs based on the type of <src> being pushed and whether <dst> is ambiguous.       If <dst> unambiguously refers to a ref on the <repository> remote, then push to that ref.   If <src> resolves to a ref starting with refs/heads/ or refs/tags/, then prepend that to <dst>.   Other ambiguity resolutions might be added in the future, but for now any other cases will error out with an error indicating what we tried, and depending on the advice.pushUnqualifiedRefname configuration (see git-config) suggest what refs/ namespace you may have wanted to push to.       The object referenced by <src> is used to update the <dst> reference on the remote side. Whether this is allowed depends on where in refs/* the <dst> reference lives as described in detail below, in those sections ""update"" means any modifications except deletes, which as noted after the next few sections are treated differently.   The refs/heads/* namespace will only accept commit objects, and updates only if they can be fast-forwarded.   The refs/tags/* namespace will accept any kind of object (as commits, trees and blobs can be tagged), and any updates to them will be rejected.   It’s possible to push any type of object to any namespace outside of refs/{tags,heads}/*. In the case of tags and commits, these will be treated as if they were the commits inside refs/heads/* for the purposes of whether the update is allowed.   I.e. a fast-forward of commits and tags outside refs/{tags,heads}/* is allowed, even in cases where what’s being fast-forwarded is not a commit, but a tag object which happens to point to a new commit which is a fast-forward of the commit the last tag (or commit) it’s replacing. Replacing a tag with an entirely different tag is also allowed, if it points to the same commit, as well as pushing a peeled tag, i.e. pushing the commit that existing tag object points to, or a new tag object which an existing commit points to.   Tree and blob objects outside of refs/{tags,heads}/* will be treated the same way as if they were inside refs/tags/*, any update of them will be rejected.   All of the rules described above about what’s not allowed as an update can be overridden by adding an the optional leading + to a refspec (or using --force command line option). The only exception to this is that no amount of forcing will make the refs/heads/* namespace accept a non-commit object. Hooks and configuration can also override or amend these rules, see e.g. receive.denyNonFastForwards in git-config and pre-receive and update in githooks.   Pushing an empty <src> allows you to delete the <dst> ref from the remote repository. Deletions are always accepted without a leading + in the refspec (or --force), except when forbidden by configuration or hooks. See receive.denyDeletes in git-config and pre-receive and update in githooks.   The special refspec : (or +: to allow non-fast-forward updates) directs Git to push ""matching"" branches: for every branch that exists on the local side, the remote side is updated if a branch of the same name already exists on the remote side.   tag <tag> means the same as refs/tags/<tag>:refs/tags/<tag>."),
					new GitCommandOption("<repository>", "<repository>", @"The ""remote"" repository that is destination of a push operation.  This parameter can be either a URL (see the section GIT URLS below) or the name of a remote (see the section REMOTES below)."),
					new GitCommandOption("--[no-]atomic", "--[no-]atomic", @"Use an atomic transaction on the remote side if available. Either all refs are updated, or on error, no refs are updated. If the server does not support atomic pushes the push will fail."),
					new GitCommandOption("--[no-]force-if-includes", "--[no-]force-if-includes", @"Force an update only if the tip of the remote-tracking ref has been integrated locally.  This option enables a check that verifies if the tip of the remote-tracking ref is reachable from one of the ""reflog"" entries of the local branch based in it for a rewrite. The check ensures that any updates from the remote have been incorporated locally by rejecting the forced update if that is not the case.   If the option is passed without specifying --force-with-lease, or specified along with --force-with-lease=<refname>:<expect>, it is a ""no-op"".   Specifying --no-force-if-includes disables this behavior."),
					new GitCommandOption("--[no-]force-with-lease", "--[no-]force-with-lease", @"Usually, ""git push"" refuses to update a remote ref that is not an ancestor of the local ref used to overwrite it.  This option overrides this restriction if the current value of the remote ref is the expected value.  ""git push"" fails otherwise.   Imagine that you have to rebase what you have already published. You will have to bypass the ""must fast-forward"" rule in order to replace the history you originally published with the rebased history. If somebody else built on top of your original history while you are rebasing, the tip of the branch at the remote may advance with their commit, and blindly pushing with --force will lose their work.   This option allows you to say that you expect the history you are updating is what you rebased and want to replace. If the remote ref still points at the commit you specified, you can be sure that no other people did anything to the ref. It is like taking a ""lease"" on the ref without explicitly locking it, and the remote ref is updated only if the ""lease"" is still valid.   --force-with-lease alone, without specifying the details, will protect all remote refs that are going to be updated by requiring their current value to be the same as the remote-tracking branch we have for them.   --force-with-lease=<refname>, without specifying the expected value, will protect the named ref (alone), if it is going to be updated, by requiring its current value to be the same as the remote-tracking branch we have for it.   --force-with-lease=<refname>:<expect> will protect the named ref (alone), if it is going to be updated, by requiring its current value to be the same as the specified value <expect> (which is allowed to be different from the remote-tracking branch we have for the refname, or we do not even have to have such a remote-tracking branch when this form is used).  If <expect> is the empty string, then the named ref must not already exist.   Note that all forms other than --force-with-lease=<refname>:<expect> that specifies the expected current value of the ref explicitly are still experimental and their semantics may change as we gain experience with this feature.   ""--no-force-with-lease"" will cancel all the previous --force-with-lease on the command line.   A general note on safety: supplying this option without an expected value, i.e. as --force-with-lease or --force-with-lease=<refname> interacts very badly with anything that implicitly runs git fetch on the remote to be pushed to in the background, e.g. git fetch origin on your repository in a cronjob.   The protection it offers over --force is ensuring that subsequent changes your work wasn’t based on aren’t clobbered, but this is trivially defeated if some background process is updating refs in the background. We don’t have anything except the remote tracking info to go by as a heuristic for refs you’re expected to have seen & are willing to clobber.   If your editor or some other system is running git fetch in the background for you a way to mitigate this is to simply set up another remote:    git remote add origin-push $(git config remote.origin.url) git fetch origin-push    Now when the background process runs git fetch origin the references on origin-push won’t be updated, and thus commands like:    git push --force-with-lease origin-push    Will fail unless you manually run git fetch origin-push. This method is of course entirely defeated by something that runs git fetch --all, in that case you’d need to either disable it or do something more tedious like:    git fetch              # update 'master' from remote git tag base master    # mark our base point git rebase -i master   # rewrite some commits git push --force-with-lease=master:base master:master    I.e. create a base tag for versions of the upstream code that you’ve seen and are willing to overwrite, then rewrite history, and finally force push changes to master if the remote version is still at base, regardless of what your local remotes/origin/master has been updated to in the background.   Alternatively, specifying --force-if-includes as an ancillary option along with --force-with-lease[=<refname>] (i.e., without saying what exact commit the ref on the remote side must be pointing at, or which refs on the remote side are being protected) at the time of ""push"" will verify if updates from the remote-tracking refs that may have been implicitly updated in the background are integrated locally before allowing a forced update."),
					new GitCommandOption("--[no-]signed", "--[no-]signed", @"GPG-sign the push request to update refs on the receiving side, to allow it to be checked by the hooks and/or be logged.  If false or --no-signed, no signing will be attempted.  If true or --signed, the push will fail if the server does not support signed pushes.  If set to if-asked, sign if and only if the server supports signed pushes.  The push will also fail if the actual call to gpg --sign fails.  See git-receive-pack for the details on the receiving end."),
					new GitCommandOption("--[no-]thin", "--[no-]thin", @"These options are passed to git-send-pack. A thin transfer significantly reduces the amount of sent data when the sender and receiver share many of the same objects in common. The default is --thin."),
					new GitCommandOption("--[no-]verify", "--[no-]verify", @"Toggle the pre-push hook (see githooks).  The default is --verify, giving the hook a chance to prevent the push.  With --no-verify, the hook is bypassed completely."),
					new GitCommandOption("--all", "--all", @"Push all branches (i.e. refs under refs/heads/); cannot be used with other <refspec>."),
					new GitCommandOption("--delete", "--delete", @"All listed refs are deleted from the remote repository. This is the same as prefixing all refs with a colon."),
					new GitCommandOption("--dry-run", "--dry-run", @"Do everything except actually send the updates."),
					new GitCommandOption("--exec", "--exec=<git-receive-pack>", @"Path to the git-receive-pack program on the remote end.  Sometimes useful when pushing to a remote repository over ssh, and you do not have the program in a directory on the default $PATH."),
					new GitCommandOption("--follow-tags", "--follow-tags", @"Push all the refs that would be pushed without this option, and also push annotated tags in refs/tags that are missing from the remote but are pointing at commit-ish that are reachable from the refs being pushed.  This can also be specified with configuration variable push.followTags.  For more information, see push.followTags in git-config."),
					new GitCommandOption("--force", "--force", @"Usually, the command refuses to update a remote ref that is not an ancestor of the local ref used to overwrite it. Also, when --force-with-lease option is used, the command refuses to update a remote ref whose current value does not match what is expected.  This flag disables these checks, and can cause the remote repository to lose commits; use it with care.   Note that --force applies to all the refs that are pushed, hence using it with push.default set to matching or with multiple push destinations configured with remote.*.push may overwrite refs other than the current branch (including local refs that are strictly behind their remote counterpart).  To force a push to only one branch, use a + in front of the refspec to push (e.g git push origin +master to force a push to the master branch). See the <refspec>... section above for details."),
					new GitCommandOption("--force-with-lease", "--force-with-lease=<refname>:<expect>", @"Usually, ""git push"" refuses to update a remote ref that is not an ancestor of the local ref used to overwrite it.  This option overrides this restriction if the current value of the remote ref is the expected value.  ""git push"" fails otherwise.   Imagine that you have to rebase what you have already published. You will have to bypass the ""must fast-forward"" rule in order to replace the history you originally published with the rebased history. If somebody else built on top of your original history while you are rebasing, the tip of the branch at the remote may advance with their commit, and blindly pushing with --force will lose their work.   This option allows you to say that you expect the history you are updating is what you rebased and want to replace. If the remote ref still points at the commit you specified, you can be sure that no other people did anything to the ref. It is like taking a ""lease"" on the ref without explicitly locking it, and the remote ref is updated only if the ""lease"" is still valid.   --force-with-lease alone, without specifying the details, will protect all remote refs that are going to be updated by requiring their current value to be the same as the remote-tracking branch we have for them.   --force-with-lease=<refname>, without specifying the expected value, will protect the named ref (alone), if it is going to be updated, by requiring its current value to be the same as the remote-tracking branch we have for it.   --force-with-lease=<refname>:<expect> will protect the named ref (alone), if it is going to be updated, by requiring its current value to be the same as the specified value <expect> (which is allowed to be different from the remote-tracking branch we have for the refname, or we do not even have to have such a remote-tracking branch when this form is used).  If <expect> is the empty string, then the named ref must not already exist.   Note that all forms other than --force-with-lease=<refname>:<expect> that specifies the expected current value of the ref explicitly are still experimental and their semantics may change as we gain experience with this feature.   ""--no-force-with-lease"" will cancel all the previous --force-with-lease on the command line.   A general note on safety: supplying this option without an expected value, i.e. as --force-with-lease or --force-with-lease=<refname> interacts very badly with anything that implicitly runs git fetch on the remote to be pushed to in the background, e.g. git fetch origin on your repository in a cronjob.   The protection it offers over --force is ensuring that subsequent changes your work wasn’t based on aren’t clobbered, but this is trivially defeated if some background process is updating refs in the background. We don’t have anything except the remote tracking info to go by as a heuristic for refs you’re expected to have seen & are willing to clobber.   If your editor or some other system is running git fetch in the background for you a way to mitigate this is to simply set up another remote:    git remote add origin-push $(git config remote.origin.url) git fetch origin-push    Now when the background process runs git fetch origin the references on origin-push won’t be updated, and thus commands like:    git push --force-with-lease origin-push    Will fail unless you manually run git fetch origin-push. This method is of course entirely defeated by something that runs git fetch --all, in that case you’d need to either disable it or do something more tedious like:    git fetch              # update 'master' from remote git tag base master    # mark our base point git rebase -i master   # rewrite some commits git push --force-with-lease=master:base master:master    I.e. create a base tag for versions of the upstream code that you’ve seen and are willing to overwrite, then rewrite history, and finally force push changes to master if the remote version is still at base, regardless of what your local remotes/origin/master has been updated to in the background.   Alternatively, specifying --force-if-includes as an ancillary option along with --force-with-lease[=<refname>] (i.e., without saying what exact commit the ref on the remote side must be pointing at, or which refs on the remote side are being protected) at the time of ""push"" will verify if updates from the remote-tracking refs that may have been implicitly updated in the background are integrated locally before allowing a forced update."),
					new GitCommandOption("--force-with-lease", "--force-with-lease=<refname>", @"Usually, ""git push"" refuses to update a remote ref that is not an ancestor of the local ref used to overwrite it.  This option overrides this restriction if the current value of the remote ref is the expected value.  ""git push"" fails otherwise.   Imagine that you have to rebase what you have already published. You will have to bypass the ""must fast-forward"" rule in order to replace the history you originally published with the rebased history. If somebody else built on top of your original history while you are rebasing, the tip of the branch at the remote may advance with their commit, and blindly pushing with --force will lose their work.   This option allows you to say that you expect the history you are updating is what you rebased and want to replace. If the remote ref still points at the commit you specified, you can be sure that no other people did anything to the ref. It is like taking a ""lease"" on the ref without explicitly locking it, and the remote ref is updated only if the ""lease"" is still valid.   --force-with-lease alone, without specifying the details, will protect all remote refs that are going to be updated by requiring their current value to be the same as the remote-tracking branch we have for them.   --force-with-lease=<refname>, without specifying the expected value, will protect the named ref (alone), if it is going to be updated, by requiring its current value to be the same as the remote-tracking branch we have for it.   --force-with-lease=<refname>:<expect> will protect the named ref (alone), if it is going to be updated, by requiring its current value to be the same as the specified value <expect> (which is allowed to be different from the remote-tracking branch we have for the refname, or we do not even have to have such a remote-tracking branch when this form is used).  If <expect> is the empty string, then the named ref must not already exist.   Note that all forms other than --force-with-lease=<refname>:<expect> that specifies the expected current value of the ref explicitly are still experimental and their semantics may change as we gain experience with this feature.   ""--no-force-with-lease"" will cancel all the previous --force-with-lease on the command line.   A general note on safety: supplying this option without an expected value, i.e. as --force-with-lease or --force-with-lease=<refname> interacts very badly with anything that implicitly runs git fetch on the remote to be pushed to in the background, e.g. git fetch origin on your repository in a cronjob.   The protection it offers over --force is ensuring that subsequent changes your work wasn’t based on aren’t clobbered, but this is trivially defeated if some background process is updating refs in the background. We don’t have anything except the remote tracking info to go by as a heuristic for refs you’re expected to have seen & are willing to clobber.   If your editor or some other system is running git fetch in the background for you a way to mitigate this is to simply set up another remote:    git remote add origin-push $(git config remote.origin.url) git fetch origin-push    Now when the background process runs git fetch origin the references on origin-push won’t be updated, and thus commands like:    git push --force-with-lease origin-push    Will fail unless you manually run git fetch origin-push. This method is of course entirely defeated by something that runs git fetch --all, in that case you’d need to either disable it or do something more tedious like:    git fetch              # update 'master' from remote git tag base master    # mark our base point git rebase -i master   # rewrite some commits git push --force-with-lease=master:base master:master    I.e. create a base tag for versions of the upstream code that you’ve seen and are willing to overwrite, then rewrite history, and finally force push changes to master if the remote version is still at base, regardless of what your local remotes/origin/master has been updated to in the background.   Alternatively, specifying --force-if-includes as an ancillary option along with --force-with-lease[=<refname>] (i.e., without saying what exact commit the ref on the remote side must be pointing at, or which refs on the remote side are being protected) at the time of ""push"" will verify if updates from the remote-tracking refs that may have been implicitly updated in the background are integrated locally before allowing a forced update."),
					new GitCommandOption("--ipv4", "--ipv4", @"Use IPv4 addresses only, ignoring IPv6 addresses."),
					new GitCommandOption("--ipv6", "--ipv6", @"Use IPv6 addresses only, ignoring IPv4 addresses."),
					new GitCommandOption("--mirror", "--mirror", @"Instead of naming each ref to push, specifies that all refs under refs/ (which includes but is not limited to refs/heads/, refs/remotes/, and refs/tags/) be mirrored to the remote repository.  Newly created local refs will be pushed to the remote end, locally updated refs will be force updated on the remote end, and deleted refs will be removed from the remote end.  This is the default if the configuration option remote.<remote>.mirror is set."),
					new GitCommandOption("--no-recurse-submodules", "--no-recurse-submodules", @"May be used to make sure all submodule commits used by the revisions to be pushed are available on a remote-tracking branch. If check is used Git will verify that all submodule commits that changed in the revisions to be pushed are available on at least one remote of the submodule. If any commits are missing the push will be aborted and exit with non-zero status. If on-demand is used all submodules that changed in the revisions to be pushed will be pushed. If on-demand was not able to push all necessary revisions it will also be aborted and exit with non-zero status. If only is used all submodules will be recursively pushed while the superproject is left unpushed. A value of no or using --no-recurse-submodules can be used to override the push.recurseSubmodules configuration variable when no submodule recursion is required."),
					new GitCommandOption("--porcelain", "--porcelain", @"Produce machine-readable output.  The output status line for each ref will be tab-separated and sent to stdout instead of stderr.  The full symbolic names of the refs will be given."),
					new GitCommandOption("--progress", "--progress", @"Progress status is reported on the standard error stream by default when it is attached to a terminal, unless -q is specified. This flag forces progress status even if the standard error stream is not directed to a terminal."),
					new GitCommandOption("--prune", "--prune", @"Remove remote branches that don’t have a local counterpart. For example a remote branch tmp will be removed if a local branch with the same name doesn’t exist any more. This also respects refspecs, e.g. git push --prune remote refs/heads/*:refs/tmp/* would make sure that remote refs/tmp/foo will be removed if refs/heads/foo doesn’t exist."),
					new GitCommandOption("--push-option", "--push-option=<option>", @"Transmit the given string to the server, which passes them to the pre-receive as well as the post-receive hook. The given string must not contain a NUL or LF character. When multiple --push-option=<option> are given, they are all sent to the other side in the order listed on the command line. When no --push-option=<option> is given from the command line, the values of configuration variable push.pushOption are used instead."),
					new GitCommandOption("--quiet", "--quiet", @"Suppress all output, including the listing of updated refs, unless an error occurs. Progress is not reported to the standard error stream."),
					new GitCommandOption("--receive-pack", "--receive-pack=<git-receive-pack>", @"Path to the git-receive-pack program on the remote end.  Sometimes useful when pushing to a remote repository over ssh, and you do not have the program in a directory on the default $PATH."),
					new GitCommandOption("--recurse-submodules", "--recurse-submodules=check|on-demand|only|no", @"May be used to make sure all submodule commits used by the revisions to be pushed are available on a remote-tracking branch. If check is used Git will verify that all submodule commits that changed in the revisions to be pushed are available on at least one remote of the submodule. If any commits are missing the push will be aborted and exit with non-zero status. If on-demand is used all submodules that changed in the revisions to be pushed will be pushed. If on-demand was not able to push all necessary revisions it will also be aborted and exit with non-zero status. If only is used all submodules will be recursively pushed while the superproject is left unpushed. A value of no or using --no-recurse-submodules can be used to override the push.recurseSubmodules configuration variable when no submodule recursion is required."),
					new GitCommandOption("--repo", "--repo=<repository>", @"This option is equivalent to the <repository> argument. If both are specified, the command-line argument takes precedence."),
					new GitCommandOption("--set-upstream", "--set-upstream", @"For every branch that is up to date or successfully pushed, add upstream (tracking) reference, used by argument-less git-pull and other commands. For more information, see branch.<name>.merge in git-config."),
					new GitCommandOption("--signed", "--signed=(true|false|if-asked)", @"GPG-sign the push request to update refs on the receiving side, to allow it to be checked by the hooks and/or be logged.  If false or --no-signed, no signing will be attempted.  If true or --signed, the push will fail if the server does not support signed pushes.  If set to if-asked, sign if and only if the server supports signed pushes.  The push will also fail if the actual call to gpg --sign fails.  See git-receive-pack for the details on the receiving end."),
					new GitCommandOption("--tags", "--tags", @"All refs under refs/tags are pushed, in addition to refspecs explicitly listed on the command line."),
					new GitCommandOption("--verbose", "--verbose", @"Run verbosely."),
					new GitCommandOption("-4", "-4", @"Use IPv4 addresses only, ignoring IPv6 addresses."),
					new GitCommandOption("-6", "-6", @"Use IPv6 addresses only, ignoring IPv4 addresses."),
					new GitCommandOption("-d", "-d", @"All listed refs are deleted from the remote repository. This is the same as prefixing all refs with a colon."),
					new GitCommandOption("-f", "-f", @"Usually, the command refuses to update a remote ref that is not an ancestor of the local ref used to overwrite it. Also, when --force-with-lease option is used, the command refuses to update a remote ref whose current value does not match what is expected.  This flag disables these checks, and can cause the remote repository to lose commits; use it with care.   Note that --force applies to all the refs that are pushed, hence using it with push.default set to matching or with multiple push destinations configured with remote.*.push may overwrite refs other than the current branch (including local refs that are strictly behind their remote counterpart).  To force a push to only one branch, use a + in front of the refspec to push (e.g git push origin +master to force a push to the master branch). See the <refspec>... section above for details."),
					new GitCommandOption("-n", "-n", @"Do everything except actually send the updates."),
					new GitCommandOption("-o", "-o <option>", @"Transmit the given string to the server, which passes them to the pre-receive as well as the post-receive hook. The given string must not contain a NUL or LF character. When multiple --push-option=<option> are given, they are all sent to the other side in the order listed on the command line. When no --push-option=<option> is given from the command line, the values of configuration variable push.pushOption are used instead."),
					new GitCommandOption("-q", "-q", @"Suppress all output, including the listing of updated refs, unless an error occurs. Progress is not reported to the standard error stream."),
					new GitCommandOption("-u", "-u", @"For every branch that is up to date or successfully pushed, add upstream (tracking) reference, used by argument-less git-pull and other commands. For more information, see branch.<name>.merge in git-config."),
					new GitCommandOption("-v", "-v", @"Run verbosely."),
				}, 
	"quiltimport" => new GitCommandOption[] {
					new GitCommandOption("--author", "--author Author Name <Author Email>", @"The author name and email address to use when no author information can be found in the patch description."),
					new GitCommandOption("--dry-run", "--dry-run", @"Walk through the patches in the series and warn if we cannot find all of the necessary information to commit a patch.  At the time of this writing only missing author information is warned about."),
					new GitCommandOption("--keep-non-patch", "--keep-non-patch", @"Pass -b flag to git mailinfo (see git-mailinfo)."),
					new GitCommandOption("--patches", "--patches <dir>", @"The directory to find the quilt patches.  The default for the patch directory is patches or the value of the $QUILT_PATCHES environment variable."),
					new GitCommandOption("--series", "--series <file>", @"The quilt series file.  The default for the series file is <patches>/series or the value of the $QUILT_SERIES environment variable."),
					new GitCommandOption("-n", "-n", @"Walk through the patches in the series and warn if we cannot find all of the necessary information to commit a patch.  At the time of this writing only missing author information is warned about."),
				}, 
	"range-diff" => new GitCommandOption[] {
					new GitCommandOption("<base>", "<base> <rev1> <rev2>", @"Equivalent to passing <base>..<rev1> and <base>..<rev2>. Note that <base> does not need to be the exact branch point of the branches. Example: after rebasing a branch my-topic, git range-diff my-topic@{u} my-topic@{1} my-topic would show the differences introduced by the rebase."),
					new GitCommandOption("<range1>", "<range1> <range2>", @"Compare the commits specified by the two ranges, where <range1> is considered an older version of <range2>."),
					new GitCommandOption("<rev1>…​<rev2>", "<rev1>…​<rev2>", @"Equivalent to passing <rev2>..<rev1> and <rev1>..<rev2>."),
					new GitCommandOption("--[no-]notes[", "--[no-]notes[=<ref>]", @"This flag is passed to the git log program (see git-log) that generates the patches."),
					new GitCommandOption("--creation-factor", "--creation-factor=<percent>", @"Set the creation/deletion cost fudge factor to <percent>. Defaults to 60. Try a larger value if git range-diff erroneously considers a large change a total rewrite (deletion of one commit and addition of another), and a smaller one in the reverse case. See the ``Algorithm`` section below for an explanation why this is needed."),
					new GitCommandOption("--left-only", "--left-only", @"Suppress commits that are missing from the first specified range (or the ""left range"" when using the <rev1>...<rev2> format)."),
					new GitCommandOption("--no-dual-color", "--no-dual-color", @"When the commit diffs differ, git range-diff recreates the original diffs' coloring, and adds outer -/+ diff markers with the background being red/green to make it easier to see e.g. when there was a change in what exact lines were added.  Additionally, the commit diff lines that are only present in the first commit range are shown ""dimmed"" (this can be overridden using the color.diff.<slot> config setting where <slot> is one of contextDimmed, oldDimmed and newDimmed), and the commit diff lines that are only present in the second commit range are shown in bold (which can be overridden using the config settings color.diff.<slot> with <slot> being one of contextBold, oldBold or newBold).   This is known to range-diff as ""dual coloring"". Use --no-dual-color to revert to color all lines according to the outer diff markers (and completely ignore the inner diff when it comes to color)."),
					new GitCommandOption("--right-only", "--right-only", @"Suppress commits that are missing from the second specified range (or the ""right range"" when using the <rev1>...<rev2> format)."),
				}, 
	"read-tree" => new GitCommandOption[] {
					new GitCommandOption("<tree-ish#>", "<tree-ish#>", @"The id of the tree object(s) to be read/merged."),
					new GitCommandOption("--[no-]recurse-submodules", "--[no-]recurse-submodules", @"Using --recurse-submodules will update the content of all active submodules according to the commit recorded in the superproject by calling read-tree recursively, also setting the submodules' HEAD to be detached at that commit."),
					new GitCommandOption("--aggressive", "--aggressive", @"Usually a three-way merge by git read-tree resolves the merge for really trivial cases and leaves other cases unresolved in the index, so that porcelains can implement different merge policies.  This flag makes the command resolve a few more cases internally:    when one side removes a path and the other side leaves the path unmodified.  The resolution is to remove that path.   when both sides remove a path.  The resolution is to remove that path.   when both sides add a path identically.  The resolution is to add that path."),
					new GitCommandOption("--dry-run", "--dry-run", @"Check if the command would error out, without updating the index or the files in the working tree for real."),
					new GitCommandOption("--empty", "--empty", @"Instead of reading tree object(s) into the index, just empty it."),
					new GitCommandOption("--index-output", "--index-output=<file>", @"Instead of writing the results out to $GIT_INDEX_FILE, write the resulting index in the named file.  While the command is operating, the original index file is locked with the same mechanism as usual.  The file must allow to be renameed into from a temporary file that is created next to the usual index file; typically this means it needs to be on the same filesystem as the index file itself, and you need write permission to the directories the index file and index output file are located in."),
					new GitCommandOption("--no-sparse-checkout", "--no-sparse-checkout", @"Disable sparse checkout support even if core.sparseCheckout is true."),
					new GitCommandOption("--prefix", "--prefix=<prefix>", @"Keep the current index contents, and read the contents of the named tree-ish under the directory at <prefix>. The command will refuse to overwrite entries that already existed in the original index file."),
					new GitCommandOption("--quiet", "--quiet", @"Quiet, suppress feedback messages."),
					new GitCommandOption("--reset", "--reset", @"Same as -m, except that unmerged entries are discarded instead of failing.  When used with -u, updates leading to loss of working tree changes or untracked files or directories will not abort the operation."),
					new GitCommandOption("--trivial", "--trivial", @"Restrict three-way merge by git read-tree to happen only if there is no file-level merging required, instead of resolving merge for trivial cases and leaving conflicting files unresolved in the index."),
					new GitCommandOption("-i", "-i", @"Usually a merge requires the index file as well as the files in the working tree to be up to date with the current head commit, in order not to lose local changes.  This flag disables the check with the working tree and is meant to be used when creating a merge of trees that are not directly related to the current working tree status into a temporary index file."),
					new GitCommandOption("-m", "-m", @"Perform a merge, not just a read.  The command will refuse to run if your index file has unmerged entries, indicating that you have not finished previous merge you started."),
					new GitCommandOption("-n", "-n", @"Check if the command would error out, without updating the index or the files in the working tree for real."),
					new GitCommandOption("-q", "-q", @"Quiet, suppress feedback messages."),
					new GitCommandOption("-u", "-u", @"After a successful merge, update the files in the work tree with the result of the merge."),
					new GitCommandOption("-v", "-v", @"Show the progress of checking files out."),
				}, 
	"rebase" => new GitCommandOption[] {
					new GitCommandOption("<branch>", "<branch>", @"Working branch; defaults to HEAD."),
					new GitCommandOption("<upstream>", "<upstream>", @"Upstream branch to compare against.  May be any valid commit, not just an existing branch name. Defaults to the configured upstream for the current branch."),
					new GitCommandOption("--abort", "--abort", @"Abort the rebase operation and reset HEAD to the original branch. If <branch> was provided when the rebase operation was started, then HEAD will be reset to <branch>. Otherwise HEAD will be reset to where it was when the rebase operation was started."),
					new GitCommandOption("--allow-empty-message", "--allow-empty-message", @"No-op.  Rebasing commits with an empty message used to fail and this option would override that behavior, allowing commits with empty messages to be rebased.  Now commits with an empty message do not cause rebasing to halt.  See also INCOMPATIBLE OPTIONS below."),
					new GitCommandOption("--apply", "--apply", @"Use applying strategies to rebase (calling git-am internally).  This option may become a no-op in the future once the merge backend handles everything the apply one does.  See also INCOMPATIBLE OPTIONS below."),
					new GitCommandOption("--autosquash", "--autosquash", @"When the commit log message begins with ""squash! …​"" or ""fixup! …​"" or ""amend! …​"", and there is already a commit in the todo list that matches the same ..., automatically modify the todo list of rebase -i, so that the commit marked for squashing comes right after the commit to be modified, and change the action of the moved commit from pick to squash or fixup or fixup -C respectively. A commit matches the ... if the commit subject matches, or if the ... refers to the commit’s hash. As a fall-back, partial matches of the commit subject work, too. The recommended way to create fixup/amend/squash commits is by using the --fixup, --fixup=amend: or --fixup=reword: and --squash options respectively of git-commit.  If the --autosquash option is enabled by default using the configuration variable rebase.autoSquash, this option can be used to override and disable this setting.   See also INCOMPATIBLE OPTIONS below."),
					new GitCommandOption("--autostash", "--autostash", @"Automatically create a temporary stash entry before the operation begins, and apply it after the operation ends.  This means that you can run rebase on a dirty worktree.  However, use with care: the final stash application after a successful rebase might result in non-trivial conflicts."),
					new GitCommandOption("--committer-date-is-author-date", "--committer-date-is-author-date", @"Instead of using the current time as the committer date, use the author date of the commit being rebased as the committer date. This option implies --force-rebase."),
					new GitCommandOption("--continue", "--continue", @"Restart the rebasing process after having resolved a merge conflict."),
					new GitCommandOption("--edit-todo", "--edit-todo", @"Edit the todo list during an interactive rebase."),
					new GitCommandOption("--empty", "--empty={drop,keep,ask}", @"How to handle commits that are not empty to start and are not clean cherry-picks of any upstream commit, but which become empty after rebasing (because they contain a subset of already upstream changes).  With drop (the default), commits that become empty are dropped.  With keep, such commits are kept. With ask (implied by --interactive), the rebase will halt when an empty commit is applied allowing you to choose whether to drop it, edit files more, or just commit the empty changes. Other options, like --exec, will use the default of drop unless -i/--interactive is explicitly specified.  Note that commits which start empty are kept (unless --no-keep-empty is specified), and commits which are clean cherry-picks (as determined by git log --cherry-mark ...) are detected and dropped as a preliminary step (unless --reapply-cherry-picks is passed).   See also INCOMPATIBLE OPTIONS below."),
					new GitCommandOption("--exec", "--exec <cmd>", @"Append ""exec <cmd>"" after each line creating a commit in the final history. <cmd> will be interpreted as one or more shell commands. Any command that fails will interrupt the rebase, with exit code 1.  You may execute several commands by either using one instance of --exec with several commands:    git rebase -i --exec ""cmd1 && cmd2 && ...""    or by giving more than one --exec:    git rebase -i --exec ""cmd1"" --exec ""cmd2"" --exec ...    If --autosquash is used, ""exec"" lines will not be appended for the intermediate commits, and will only appear at the end of each squash/fixup series.   This uses the --interactive machinery internally, but it can be run without an explicit --interactive.   See also INCOMPATIBLE OPTIONS below."),
					new GitCommandOption("--force-rebase", "--force-rebase", @"Individually replay all rebased commits instead of fast-forwarding over the unchanged ones.  This ensures that the entire history of the rebased branch is composed of new commits.  You may find this helpful after reverting a topic branch merge, as this option recreates the topic branch with fresh commits so it can be remerged successfully without needing to ""revert the reversion"" (see the revert-a-faulty-merge How-To for details)."),
					new GitCommandOption("--fork-point", "--fork-point", @"Use reflog to find a better common ancestor between <upstream> and <branch> when calculating which commits have been introduced by <branch>.  When --fork-point is active, fork_point will be used instead of <upstream> to calculate the set of commits to rebase, where fork_point is the result of git merge-base --fork-point <upstream> <branch> command (see git-merge-base).  If fork_point ends up being empty, the <upstream> will be used as a fallback.   If <upstream> is given on the command line, then the default is --no-fork-point, otherwise the default is --fork-point. See also rebase.forkpoint in git-config.   If your branch was based on <upstream> but <upstream> was rewound and your branch contains commits which were dropped, this option can be used with --keep-base in order to drop those commits from your branch.   See also INCOMPATIBLE OPTIONS below."),
					new GitCommandOption("--gpg-sign[", "--gpg-sign[=<keyid>]", @"GPG-sign commits. The keyid argument is optional and defaults to the committer identity; if specified, it must be stuck to the option without a space. --no-gpg-sign is useful to countermand both commit.gpgSign configuration variable, and earlier --gpg-sign."),
					new GitCommandOption("--ignore-date", "--ignore-date", @"Instead of using the author date of the original commit, use the current time as the	author date of the rebased commit.  This option implies --force-rebase.  See also INCOMPATIBLE OPTIONS below."),
					new GitCommandOption("--ignore-whitespace", "--ignore-whitespace", @"Ignore whitespace differences when trying to reconcile differences. Currently, each backend implements an approximation of this behavior:  apply backend: When applying a patch, ignore changes in whitespace in context lines. Unfortunately, this means that if the ""old"" lines being replaced by the patch differ only in whitespace from the existing file, you will get a merge conflict instead of a successful patch application.   merge backend: Treat lines with only whitespace changes as unchanged when merging. Unfortunately, this means that any patch hunks that were intended to modify whitespace and nothing else will be dropped, even if the other side had no changes that conflicted."),
					new GitCommandOption("--interactive", "--interactive", @"Make a list of the commits which are about to be rebased.  Let the user edit that list before rebasing.  This mode can also be used to split commits (see SPLITTING COMMITS below).  The commit list format can be changed by setting the configuration option rebase.instructionFormat.  A customized instruction format will automatically have the long commit hash prepended to the format.   See also INCOMPATIBLE OPTIONS below."),
					new GitCommandOption("--keep-base", "--keep-base", @"Set the starting point at which to create the new commits to the merge base of <upstream> <branch>. Running git rebase --keep-base <upstream> <branch> is equivalent to running git rebase --onto <upstream>…​ <upstream>.  This option is useful in the case where one is developing a feature on top of an upstream branch. While the feature is being worked on, the upstream branch may advance and it may not be the best idea to keep rebasing on top of the upstream but to keep the base commit as-is.   Although both this option and --fork-point find the merge base between <upstream> and <branch>, this option uses the merge base as the starting point on which new commits will be created, whereas --fork-point uses the merge base to determine the set of commits which will be rebased.   See also INCOMPATIBLE OPTIONS below."),
					new GitCommandOption("--keep-empty", "--keep-empty", @"Do not keep commits that start empty before the rebase (i.e. that do not change anything from its parent) in the result.  The default is to keep commits which start empty, since creating such commits requires passing the --allow-empty override flag to git commit, signifying that a user is very intentionally creating such a commit and thus wants to keep it.  Usage of this flag will probably be rare, since you can get rid of commits that start empty by just firing up an interactive rebase and removing the lines corresponding to the commits you don’t want.  This flag exists as a convenient shortcut, such as for cases where external tools generate many empty commits and you want them all removed.   For commits which do not start empty but become empty after rebasing, see the --empty flag.   See also INCOMPATIBLE OPTIONS below."),
					new GitCommandOption("--merge", "--merge", @"Using merging strategies to rebase (default).  Note that a rebase merge works by replaying each commit from the working branch on top of the <upstream> branch.  Because of this, when a merge conflict happens, the side reported as ours is the so-far rebased series, starting with <upstream>, and theirs is the working branch.  In other words, the sides are swapped.   See also INCOMPATIBLE OPTIONS below."),
					new GitCommandOption("--no-autosquash", "--no-autosquash", @"When the commit log message begins with ""squash! …​"" or ""fixup! …​"" or ""amend! …​"", and there is already a commit in the todo list that matches the same ..., automatically modify the todo list of rebase -i, so that the commit marked for squashing comes right after the commit to be modified, and change the action of the moved commit from pick to squash or fixup or fixup -C respectively. A commit matches the ... if the commit subject matches, or if the ... refers to the commit’s hash. As a fall-back, partial matches of the commit subject work, too. The recommended way to create fixup/amend/squash commits is by using the --fixup, --fixup=amend: or --fixup=reword: and --squash options respectively of git-commit.  If the --autosquash option is enabled by default using the configuration variable rebase.autoSquash, this option can be used to override and disable this setting.   See also INCOMPATIBLE OPTIONS below."),
					new GitCommandOption("--no-autostash", "--no-autostash", @"Automatically create a temporary stash entry before the operation begins, and apply it after the operation ends.  This means that you can run rebase on a dirty worktree.  However, use with care: the final stash application after a successful rebase might result in non-trivial conflicts."),
					new GitCommandOption("--no-ff", "--no-ff", @"Individually replay all rebased commits instead of fast-forwarding over the unchanged ones.  This ensures that the entire history of the rebased branch is composed of new commits.  You may find this helpful after reverting a topic branch merge, as this option recreates the topic branch with fresh commits so it can be remerged successfully without needing to ""revert the reversion"" (see the revert-a-faulty-merge How-To for details)."),
					new GitCommandOption("--no-fork-point", "--no-fork-point", @"Use reflog to find a better common ancestor between <upstream> and <branch> when calculating which commits have been introduced by <branch>.  When --fork-point is active, fork_point will be used instead of <upstream> to calculate the set of commits to rebase, where fork_point is the result of git merge-base --fork-point <upstream> <branch> command (see git-merge-base).  If fork_point ends up being empty, the <upstream> will be used as a fallback.   If <upstream> is given on the command line, then the default is --no-fork-point, otherwise the default is --fork-point. See also rebase.forkpoint in git-config.   If your branch was based on <upstream> but <upstream> was rewound and your branch contains commits which were dropped, this option can be used with --keep-base in order to drop those commits from your branch.   See also INCOMPATIBLE OPTIONS below."),
					new GitCommandOption("--no-gpg-sign", "--no-gpg-sign", @"GPG-sign commits. The keyid argument is optional and defaults to the committer identity; if specified, it must be stuck to the option without a space. --no-gpg-sign is useful to countermand both commit.gpgSign configuration variable, and earlier --gpg-sign."),
					new GitCommandOption("--no-keep-empty", "--no-keep-empty", @"Do not keep commits that start empty before the rebase (i.e. that do not change anything from its parent) in the result.  The default is to keep commits which start empty, since creating such commits requires passing the --allow-empty override flag to git commit, signifying that a user is very intentionally creating such a commit and thus wants to keep it.  Usage of this flag will probably be rare, since you can get rid of commits that start empty by just firing up an interactive rebase and removing the lines corresponding to the commits you don’t want.  This flag exists as a convenient shortcut, such as for cases where external tools generate many empty commits and you want them all removed.   For commits which do not start empty but become empty after rebasing, see the --empty flag.   See also INCOMPATIBLE OPTIONS below."),
					new GitCommandOption("--no-reapply-cherry-picks", "--no-reapply-cherry-picks", @"Reapply all clean cherry-picks of any upstream commit instead of preemptively dropping them. (If these commits then become empty after rebasing, because they contain a subset of already upstream changes, the behavior towards them is controlled by the --empty flag.)  By default (or if --no-reapply-cherry-picks is given), these commits will be automatically dropped.  Because this necessitates reading all upstream commits, this can be expensive in repos with a large number of upstream commits that need to be read.  When using the merge backend, warnings will be issued for each dropped commit (unless --quiet is given). Advice will also be issued unless advice.skippedCherryPicks is set to false (see git-config).   --reapply-cherry-picks allows rebase to forgo reading all upstream commits, potentially improving performance.   See also INCOMPATIBLE OPTIONS below."),
					new GitCommandOption("--no-rerere-autoupdate", "--no-rerere-autoupdate", @"Allow the rerere mechanism to update the index with the result of auto-conflict resolution if possible."),
					new GitCommandOption("--no-reschedule-failed-exec", "--no-reschedule-failed-exec", @"Automatically reschedule exec commands that failed. This only makes sense in interactive mode (or when an --exec option was provided).  Even though this option applies once a rebase is started, it’s set for the whole rebase at the start based on either the rebase.rescheduleFailedExec configuration (see git-config or ""CONFIGURATION"" below) or whether this option is provided. Otherwise an explicit --no-reschedule-failed-exec at the start would be overridden by the presence of rebase.rescheduleFailedExec=true configuration."),
					new GitCommandOption("--no-stat", "--no-stat", @"Do not show a diffstat as part of the rebase process."),
					new GitCommandOption("--no-verify", "--no-verify", @"This option bypasses the pre-rebase hook.  See also githooks."),
					new GitCommandOption("--onto", "--onto <newbase>", @"Starting point at which to create the new commits. If the --onto option is not specified, the starting point is <upstream>.  May be any valid commit, and not just an existing branch name.  As a special case, you may use ""A...B"" as a shortcut for the merge base of A and B if there is exactly one merge base. You can leave out at most one of A and B, in which case it defaults to HEAD."),
					new GitCommandOption("--quiet", "--quiet", @"Be quiet. Implies --no-stat."),
					new GitCommandOption("--quit", "--quit", @"Abort the rebase operation but HEAD is not reset back to the original branch. The index and working tree are also left unchanged as a result. If a temporary stash entry was created using --autostash, it will be saved to the stash list."),
					new GitCommandOption("--reapply-cherry-picks", "--reapply-cherry-picks", @"Reapply all clean cherry-picks of any upstream commit instead of preemptively dropping them. (If these commits then become empty after rebasing, because they contain a subset of already upstream changes, the behavior towards them is controlled by the --empty flag.)  By default (or if --no-reapply-cherry-picks is given), these commits will be automatically dropped.  Because this necessitates reading all upstream commits, this can be expensive in repos with a large number of upstream commits that need to be read.  When using the merge backend, warnings will be issued for each dropped commit (unless --quiet is given). Advice will also be issued unless advice.skippedCherryPicks is set to false (see git-config).   --reapply-cherry-picks allows rebase to forgo reading all upstream commits, potentially improving performance.   See also INCOMPATIBLE OPTIONS below."),
					new GitCommandOption("--rebase-merges[", "--rebase-merges[=(rebase-cousins|no-rebase-cousins)]", @"By default, a rebase will simply drop merge commits from the todo list, and put the rebased commits into a single, linear branch. With --rebase-merges, the rebase will instead try to preserve the branching structure within the commits that are to be rebased, by recreating the merge commits. Any resolved merge conflicts or manual amendments in these merge commits will have to be resolved/re-applied manually.  By default, or when no-rebase-cousins was specified, commits which do not have <upstream> as direct ancestor will keep their original branch point, i.e. commits that would be excluded by git-log's --ancestry-path option will keep their original ancestry by default. If the rebase-cousins mode is turned on, such commits are instead rebased onto <upstream> (or <onto>, if specified).   It is currently only possible to recreate the merge commits using the ort merge strategy; different merge strategies can be used only via explicit exec git merge -s <strategy> [...] commands.   See also REBASING MERGES and INCOMPATIBLE OPTIONS below."),
					new GitCommandOption("--rerere-autoupdate", "--rerere-autoupdate", @"Allow the rerere mechanism to update the index with the result of auto-conflict resolution if possible."),
					new GitCommandOption("--reschedule-failed-exec", "--reschedule-failed-exec", @"Automatically reschedule exec commands that failed. This only makes sense in interactive mode (or when an --exec option was provided).  Even though this option applies once a rebase is started, it’s set for the whole rebase at the start based on either the rebase.rescheduleFailedExec configuration (see git-config or ""CONFIGURATION"" below) or whether this option is provided. Otherwise an explicit --no-reschedule-failed-exec at the start would be overridden by the presence of rebase.rescheduleFailedExec=true configuration."),
					new GitCommandOption("--reset-author-date", "--reset-author-date", @"Instead of using the author date of the original commit, use the current time as the	author date of the rebased commit.  This option implies --force-rebase.  See also INCOMPATIBLE OPTIONS below."),
					new GitCommandOption("--root", "--root", @"Rebase all commits reachable from <branch>, instead of limiting them with an <upstream>.  This allows you to rebase the root commit(s) on a branch.  When used with --onto, it will skip changes already contained in <newbase> (instead of <upstream>) whereas without --onto it will operate on every change.  See also INCOMPATIBLE OPTIONS below."),
					new GitCommandOption("--show-current-patch", "--show-current-patch", @"Show the current patch in an interactive rebase or when rebase is stopped because of conflicts. This is the equivalent of git show REBASE_HEAD."),
					new GitCommandOption("--signoff", "--signoff", @"Add a Signed-off-by trailer to all the rebased commits. Note that if --interactive is given then only commits marked to be picked, edited or reworded will have the trailer added.  See also INCOMPATIBLE OPTIONS below."),
					new GitCommandOption("--skip", "--skip", @"Restart the rebasing process by skipping the current patch."),
					new GitCommandOption("--stat", "--stat", @"Show a diffstat of what changed upstream since the last rebase. The diffstat is also controlled by the configuration option rebase.stat."),
					new GitCommandOption("--strategy", "--strategy=<strategy>", @"Use the given merge strategy, instead of the default ort. This implies --merge.  Because git rebase replays each commit from the working branch on top of the <upstream> branch using the given strategy, using the ours strategy simply empties all patches from the <branch>, which makes little sense.   See also INCOMPATIBLE OPTIONS below."),
					new GitCommandOption("--strategy-option", "--strategy-option=<strategy-option>", @"Pass the <strategy-option> through to the merge strategy. This implies --merge and, if no strategy has been specified, -s ort.  Note the reversal of ours and theirs as noted above for the -m option.  See also INCOMPATIBLE OPTIONS below."),
					new GitCommandOption("--verbose", "--verbose", @"Be verbose. Implies --stat."),
					new GitCommandOption("--verify", "--verify", @"Allows the pre-rebase hook to run, which is the default.  This option can be used to override --no-verify.  See also githooks."),
					new GitCommandOption("--whitespace", "--whitespace=<option>", @"This flag is passed to the git apply program (see git-apply) that applies the patch. Implies --apply.  See also INCOMPATIBLE OPTIONS below."),
					new GitCommandOption("-C<n>", "-C<n>", @"Ensure at least <n> lines of surrounding context match before and after each change.  When fewer lines of surrounding context exist they all must match.  By default no context is ever ignored.  Implies --apply.  See also INCOMPATIBLE OPTIONS below."),
					new GitCommandOption("-f", "-f", @"Individually replay all rebased commits instead of fast-forwarding over the unchanged ones.  This ensures that the entire history of the rebased branch is composed of new commits.  You may find this helpful after reverting a topic branch merge, as this option recreates the topic branch with fresh commits so it can be remerged successfully without needing to ""revert the reversion"" (see the revert-a-faulty-merge How-To for details)."),
					new GitCommandOption("-i", "-i", @"Make a list of the commits which are about to be rebased.  Let the user edit that list before rebasing.  This mode can also be used to split commits (see SPLITTING COMMITS below).  The commit list format can be changed by setting the configuration option rebase.instructionFormat.  A customized instruction format will automatically have the long commit hash prepended to the format.   See also INCOMPATIBLE OPTIONS below."),
					new GitCommandOption("-m", "-m", @"Using merging strategies to rebase (default).  Note that a rebase merge works by replaying each commit from the working branch on top of the <upstream> branch.  Because of this, when a merge conflict happens, the side reported as ours is the so-far rebased series, starting with <upstream>, and theirs is the working branch.  In other words, the sides are swapped.   See also INCOMPATIBLE OPTIONS below."),
					new GitCommandOption("-n", "-n", @"Do not show a diffstat as part of the rebase process."),
					new GitCommandOption("-q", "-q", @"Be quiet. Implies --no-stat."),
					new GitCommandOption("-r", "-r", @"By default, a rebase will simply drop merge commits from the todo list, and put the rebased commits into a single, linear branch. With --rebase-merges, the rebase will instead try to preserve the branching structure within the commits that are to be rebased, by recreating the merge commits. Any resolved merge conflicts or manual amendments in these merge commits will have to be resolved/re-applied manually.  By default, or when no-rebase-cousins was specified, commits which do not have <upstream> as direct ancestor will keep their original branch point, i.e. commits that would be excluded by git-log's --ancestry-path option will keep their original ancestry by default. If the rebase-cousins mode is turned on, such commits are instead rebased onto <upstream> (or <onto>, if specified).   It is currently only possible to recreate the merge commits using the ort merge strategy; different merge strategies can be used only via explicit exec git merge -s <strategy> [...] commands.   See also REBASING MERGES and INCOMPATIBLE OPTIONS below."),
					new GitCommandOption("-s", "-s <strategy>", @"Use the given merge strategy, instead of the default ort. This implies --merge.  Because git rebase replays each commit from the working branch on top of the <upstream> branch using the given strategy, using the ours strategy simply empties all patches from the <branch>, which makes little sense.   See also INCOMPATIBLE OPTIONS below."),
					new GitCommandOption("-S[<keyid>]", "-S[<keyid>]", @"GPG-sign commits. The keyid argument is optional and defaults to the committer identity; if specified, it must be stuck to the option without a space. --no-gpg-sign is useful to countermand both commit.gpgSign configuration variable, and earlier --gpg-sign."),
					new GitCommandOption("-v", "-v", @"Be verbose. Implies --stat."),
					new GitCommandOption("-X", "-X <strategy-option>", @"Pass the <strategy-option> through to the merge strategy. This implies --merge and, if no strategy has been specified, -s ort.  Note the reversal of ours and theirs as noted above for the -m option.  See also INCOMPATIBLE OPTIONS below."),
					new GitCommandOption("-x", "-x <cmd>", @"Append ""exec <cmd>"" after each line creating a commit in the final history. <cmd> will be interpreted as one or more shell commands. Any command that fails will interrupt the rebase, with exit code 1.  You may execute several commands by either using one instance of --exec with several commands:    git rebase -i --exec ""cmd1 && cmd2 && ...""    or by giving more than one --exec:    git rebase -i --exec ""cmd1"" --exec ""cmd2"" --exec ...    If --autosquash is used, ""exec"" lines will not be appended for the intermediate commits, and will only appear at the end of each squash/fixup series.   This uses the --interactive machinery internally, but it can be run without an explicit --interactive.   See also INCOMPATIBLE OPTIONS below."),
				}, 
	"receive-pack" => new GitCommandOption[] {
					new GitCommandOption("<directory>", "<directory>", @"The repository to sync into."),
					new GitCommandOption("--http-backend-info-refs", "--http-backend-info-refs", @"Used by git-http-backend to serve up $GIT_URL/info/refs?service=git-receive-pack requests. See --http-backend-info-refs in git-upload-pack."),
				}, 
	"reflog" => new GitCommandOption[] {
					new GitCommandOption("--all", "--all", @"Process the reflogs of all references."),
					new GitCommandOption("--dry-run", "--dry-run", @"Do not actually prune any entries; just show what would have been pruned."),
					new GitCommandOption("--expire", "--expire=<time>", @"Prune entries older than the specified time. If this option is not specified, the expiration time is taken from the configuration setting gc.reflogExpire, which in turn defaults to 90 days. --expire=all prunes entries regardless of their age; --expire=never turns off pruning of reachable entries (but see --expire-unreachable)."),
					new GitCommandOption("--expire-unreachable", "--expire-unreachable=<time>", @"Prune entries older than <time> that are not reachable from the current tip of the branch. If this option is not specified, the expiration time is taken from the configuration setting gc.reflogExpireUnreachable, which in turn defaults to 30 days. --expire-unreachable=all prunes unreachable entries regardless of their age; --expire-unreachable=never turns off early pruning of unreachable entries (but see --expire)."),
					new GitCommandOption("--rewrite", "--rewrite", @"If a reflog entry’s predecessor is pruned, adjust its ""old"" SHA-1 to be equal to the ""new"" SHA-1 field of the entry that now precedes it."),
					new GitCommandOption("--single-worktree", "--single-worktree", @"By default when --all is specified, reflogs from all working trees are processed. This option limits the processing to reflogs from the current working tree only."),
					new GitCommandOption("--stale-fix", "--stale-fix", @"Prune any reflog entries that point to ""broken commits"". A broken commit is a commit that is not reachable from any of the reference tips and that refers, directly or indirectly, to a missing commit, tree, or blob object.  This computation involves traversing all the reachable objects, i.e. it has the same cost as git prune.  It is primarily intended to fix corruption caused by garbage collecting using older versions of Git, which didn’t protect objects referred to by reflogs."),
					new GitCommandOption("--updateref", "--updateref", @"Update the reference to the value of the top reflog entry (i.e. <ref>@{0}) if the previous top entry was pruned.  (This option is ignored for symbolic references.)"),
					new GitCommandOption("--verbose", "--verbose", @"Print extra information on screen."),
					new GitCommandOption("-n", "-n", @"Do not actually prune any entries; just show what would have been pruned."),
				}, 
	"remote-ext" => new GitCommandOption[] {
				}, 
	"remote-fd" => new GitCommandOption[] {
				}, 
	"remote" => new GitCommandOption[] {
					new GitCommandOption("--verbose", "--verbose", @"Be a little more verbose and show remote url after name. NOTE: This must be placed between remote and subcommand."),
					new GitCommandOption("-v", "-v", @"Be a little more verbose and show remote url after name. NOTE: This must be placed between remote and subcommand."),
				}, 
	"repack" => new GitCommandOption[] {
					new GitCommandOption("--delta-islands", "--delta-islands", @"Pass the --delta-islands option to git-pack-objects, see git-pack-objects."),
					new GitCommandOption("--depth", "--depth=<n>", @"These two options affect how the objects contained in the pack are stored using delta compression. The objects are first internally sorted by type, size and optionally names and compared against the other objects within --window to see if using delta compression saves space. --depth limits the maximum delta depth; making it too deep affects the performance on the unpacker side, because delta data needs to be applied that many times to get to the necessary object.  The default value for --window is 10 and --depth is 50. The maximum depth is 4095."),
					new GitCommandOption("--geometric", "--geometric=<factor>", @"Arrange resulting pack structure so that each successive pack contains at least <factor> times the number of objects as the next-largest pack.  git repack ensures this by determining a ""cut"" of packfiles that need to be repacked into one in order to ensure a geometric progression. It picks the smallest set of packfiles such that as many of the larger packfiles (by count of objects contained in that pack) may be left intact.   Unlike other repack modes, the set of objects to pack is determined uniquely by the set of packs being ""rolled-up""; in other words, the packs determined to need to be combined in order to restore a geometric progression.   When --unpacked is specified, loose objects are implicitly included in this ""roll-up"", without respect to their reachability. This is subject to change in the future. This option (implying a drastically different repack mode) is not guaranteed to work with all other combinations of option to git repack.   When writing a multi-pack bitmap, git repack selects the largest resulting pack as the preferred pack for object selection by the MIDX (see git-multi-pack-index)."),
					new GitCommandOption("--keep-pack", "--keep-pack=<pack-name>", @"Exclude the given pack from repacking. This is the equivalent of having .keep file on the pack. <pack-name> is the pack file name without leading directory (e.g. pack-123.pack). The option could be specified multiple times to keep multiple packs."),
					new GitCommandOption("--keep-unreachable", "--keep-unreachable", @"When used with -ad, any unreachable objects from existing packs will be appended to the end of the packfile instead of being removed. In addition, any unreachable loose objects will be packed (and their loose counterparts removed)."),
					new GitCommandOption("--max-pack-size", "--max-pack-size=<n>", @"Maximum size of each output pack file. The size can be suffixed with ""k"", ""m"", or ""g"". The minimum size allowed is limited to 1 MiB. If specified, multiple packfiles may be created, which also prevents the creation of a bitmap index. The default is unlimited, unless the config variable pack.packSizeLimit is set. Note that this option may result in a larger and slower repository; see the discussion in pack.packSizeLimit."),
					new GitCommandOption("--pack-kept-objects", "--pack-kept-objects", @"Include objects in .keep files when repacking.  Note that we still do not delete .keep packs after pack-objects finishes. This means that we may duplicate objects, but this makes the option safe to use when there are concurrent pushes or fetches. This option is generally only useful if you are writing bitmaps with -b or repack.writeBitmaps, as it ensures that the bitmapped packfile has the necessary objects."),
					new GitCommandOption("--quiet", "--quiet", @"Show no progress over the standard error stream and pass the -q option to git pack-objects. See git-pack-objects."),
					new GitCommandOption("--threads", "--threads=<n>", @"This option is passed through to git pack-objects."),
					new GitCommandOption("--unpack-unreachable", "--unpack-unreachable=<when>", @"When loosening unreachable objects, do not bother loosening any objects older than <when>. This can be used to optimize out the write of any objects that would be immediately pruned by a follow-up git prune."),
					new GitCommandOption("--window", "--window=<n>", @"These two options affect how the objects contained in the pack are stored using delta compression. The objects are first internally sorted by type, size and optionally names and compared against the other objects within --window to see if using delta compression saves space. --depth limits the maximum delta depth; making it too deep affects the performance on the unpacker side, because delta data needs to be applied that many times to get to the necessary object.  The default value for --window is 10 and --depth is 50. The maximum depth is 4095."),
					new GitCommandOption("--window-memory", "--window-memory=<n>", @"This option provides an additional limit on top of --window; the window size will dynamically scale down so as to not take up more than <n> bytes in memory.  This is useful in repositories with a mix of large and small objects to not run out of memory with a large window, but still be able to take advantage of the large window for the smaller objects.  The size can be suffixed with ""k"", ""m"", or ""g"". --window-memory=0 makes memory usage unlimited.  The default is taken from the pack.windowMemory configuration variable. Note that the actual memory usage will be the limit multiplied by the number of threads used by git-pack-objects."),
					new GitCommandOption("--write-bitmap-index", "--write-bitmap-index", @"Write a reachability bitmap index as part of the repack. This only makes sense when used with -a, -A or -m, as the bitmaps must be able to refer to all reachable objects. This option overrides the setting of repack.writeBitmaps. This option has no effect if multiple packfiles are created, unless writing a MIDX (in which case a multi-pack bitmap is created)."),
					new GitCommandOption("--write-midx", "--write-midx", @"Write a multi-pack index (see git-multi-pack-index) containing the non-redundant packs."),
					new GitCommandOption("-A", "-A", @"Same as -a, unless -d is used.  Then any unreachable objects in a previous pack become loose, unpacked objects, instead of being left in the old pack.  Unreachable objects are never intentionally added to a pack, even when repacking. This option prevents unreachable objects from being immediately deleted by way of being left in the old pack and then removed.  Instead, the loose unreachable objects will be pruned according to normal expiry rules with the next git gc invocation. See git-gc."),
					new GitCommandOption("-a", "-a", @"Instead of incrementally packing the unpacked objects, pack everything referenced into a single pack. Especially useful when packing a repository that is used for private development. Use with -d.  This will clean up the objects that git prune leaves behind, but git fsck --full --dangling shows as dangling.  Note that users fetching over dumb protocols will have to fetch the whole new pack in order to get any contained object, no matter how many other objects in that pack they already have locally.   Promisor packfiles are repacked separately: if there are packfiles that have an associated "".promisor"" file, these packfiles will be repacked into another separate pack, and an empty "".promisor"" file corresponding to the new separate pack will be written."),
					new GitCommandOption("-b", "-b", @"Write a reachability bitmap index as part of the repack. This only makes sense when used with -a, -A or -m, as the bitmaps must be able to refer to all reachable objects. This option overrides the setting of repack.writeBitmaps. This option has no effect if multiple packfiles are created, unless writing a MIDX (in which case a multi-pack bitmap is created)."),
					new GitCommandOption("-d", "-d", @"After packing, if the newly created packs make some existing packs redundant, remove the redundant packs. Also run  git prune-packed to remove redundant loose object files."),
					new GitCommandOption("-F", "-F", @"Pass the --no-reuse-object option to git-pack-objects, see git-pack-objects."),
					new GitCommandOption("-f", "-f", @"Pass the --no-reuse-delta option to git-pack-objects, see git-pack-objects."),
					new GitCommandOption("-g", "-g=<factor>", @"Arrange resulting pack structure so that each successive pack contains at least <factor> times the number of objects as the next-largest pack.  git repack ensures this by determining a ""cut"" of packfiles that need to be repacked into one in order to ensure a geometric progression. It picks the smallest set of packfiles such that as many of the larger packfiles (by count of objects contained in that pack) may be left intact.   Unlike other repack modes, the set of objects to pack is determined uniquely by the set of packs being ""rolled-up""; in other words, the packs determined to need to be combined in order to restore a geometric progression.   When --unpacked is specified, loose objects are implicitly included in this ""roll-up"", without respect to their reachability. This is subject to change in the future. This option (implying a drastically different repack mode) is not guaranteed to work with all other combinations of option to git repack.   When writing a multi-pack bitmap, git repack selects the largest resulting pack as the preferred pack for object selection by the MIDX (see git-multi-pack-index)."),
					new GitCommandOption("-i", "-i", @"Pass the --delta-islands option to git-pack-objects, see git-pack-objects."),
					new GitCommandOption("-k", "-k", @"When used with -ad, any unreachable objects from existing packs will be appended to the end of the packfile instead of being removed. In addition, any unreachable loose objects will be packed (and their loose counterparts removed)."),
					new GitCommandOption("-l", "-l", @"Pass the --local option to git pack-objects. See git-pack-objects."),
					new GitCommandOption("-m", "-m", @"Write a multi-pack index (see git-multi-pack-index) containing the non-redundant packs."),
					new GitCommandOption("-n", "-n", @"Do not update the server information with git update-server-info.  This option skips updating local catalog files needed to publish this repository (or a direct copy of it) over HTTP or FTP.  See git-update-server-info."),
					new GitCommandOption("-q", "-q", @"Show no progress over the standard error stream and pass the -q option to git pack-objects. See git-pack-objects."),
				}, 
	"replace" => new GitCommandOption[] {
					new GitCommandOption("--convert-graft-file", "--convert-graft-file", @"Creates graft commits for all entries in $GIT_DIR/info/grafts and deletes that file upon success. The purpose is to help users with transitioning off of the now-deprecated graft file."),
					new GitCommandOption("--delete", "--delete", @"Delete existing replace refs for the given objects."),
					new GitCommandOption("--edit", "--edit <object>", @"Edit an object’s content interactively. The existing content for <object> is pretty-printed into a temporary file, an editor is launched on the file, and the result is parsed to create a new object of the same type as <object>. A replacement ref is then created to replace <object> with the newly created object. See git-var for details about how the editor will be chosen."),
					new GitCommandOption("--force", "--force", @"If an existing replace ref for the same object exists, it will be overwritten (instead of failing)."),
					new GitCommandOption("--format", "--format=<format>", @"When listing, use the specified <format>, which can be one of short, medium and long. When omitted, the format defaults to short."),
					new GitCommandOption("--graft", "--graft <commit> [<parent>…​]", @"Create a graft commit. A new commit is created with the same content as <commit> except that its parents will be [<parent>…​] instead of <commit>'s parents. A replacement ref is then created to replace <commit> with the newly created commit. Use --convert-graft-file to convert a $GIT_DIR/info/grafts file and use replace refs instead."),
					new GitCommandOption("--list", "--list <pattern>", @"List replace refs for objects that match the given pattern (or all if no pattern is given). Typing ""git replace"" without arguments, also lists all replace refs."),
					new GitCommandOption("--raw", "--raw", @"When editing, provide the raw object contents rather than pretty-printed ones. Currently this only affects trees, which will be shown in their binary form. This is harder to work with, but can help when repairing a tree that is so corrupted it cannot be pretty-printed. Note that you may need to configure your editor to cleanly read and write binary data."),
					new GitCommandOption("-d", "-d", @"Delete existing replace refs for the given objects."),
					new GitCommandOption("-f", "-f", @"If an existing replace ref for the same object exists, it will be overwritten (instead of failing)."),
					new GitCommandOption("-l", "-l <pattern>", @"List replace refs for objects that match the given pattern (or all if no pattern is given). Typing ""git replace"" without arguments, also lists all replace refs."),
				}, 
	"request-pull" => new GitCommandOption[] {
					new GitCommandOption("<end>", "<end>", @"Commit to end at (defaults to HEAD).  This names the commit at the tip of the history you are asking to be pulled.  When the repository named by <URL> has the commit at a tip of a ref that is different from the ref you have locally, you can use the <local>:<remote> syntax, to have its local name, a colon :, and its remote name."),
					new GitCommandOption("<start>", "<start>", @"Commit to start at.  This names a commit that is already in the upstream history."),
					new GitCommandOption("<URL>", "<URL>", @"The repository URL to be pulled from."),
					new GitCommandOption("-p", "-p", @"Include patch text in the output."),
				}, 
	"rerere" => new GitCommandOption[] {
				}, 
	"reset" => new GitCommandOption[] {
					new GitCommandOption("<pathspec>…​", "<pathspec>…​", @"Limits the paths affected by the operation.  For more details, see the pathspec entry in gitglossary."),
					new GitCommandOption("--", "--", @"Do not interpret any more arguments as options."),
					new GitCommandOption("--no-refresh", "--no-refresh", @"Refresh the index after a mixed reset. Enabled by default."),
					new GitCommandOption("--pathspec-file-nul", "--pathspec-file-nul", @"Only meaningful with --pathspec-from-file. Pathspec elements are separated with NUL character and all other characters are taken literally (including newlines and quotes)."),
					new GitCommandOption("--pathspec-from-file", "--pathspec-from-file=<file>", @"Pathspec is passed in <file> instead of commandline args. If <file> is exactly - then standard input is used. Pathspec elements are separated by LF or CR/LF. Pathspec elements can be quoted as explained for the configuration variable core.quotePath (see git-config). See also --pathspec-file-nul and global --literal-pathspecs."),
					new GitCommandOption("--quiet", "--quiet", @"Be quiet, only report errors."),
					new GitCommandOption("--refresh", "--refresh", @"Refresh the index after a mixed reset. Enabled by default."),
					new GitCommandOption("--stdin", "--stdin", @"DEPRECATED (use --pathspec-from-file=- instead): Instead of taking list of paths from the command line, read list of paths from the standard input. Paths are separated by LF (i.e. one path per line) by default."),
					new GitCommandOption("-q", "-q", @"Be quiet, only report errors."),
					new GitCommandOption("-z", "-z", @"DEPRECATED (use --pathspec-file-nul instead): Only meaningful with --stdin; paths are separated with NUL character instead of LF."),
				}, 
	"restore" => new GitCommandOption[] {
					new GitCommandOption("<pathspec>…​", "<pathspec>…​", @"Limits the paths affected by the operation.  For more details, see the pathspec entry in gitglossary."),
					new GitCommandOption("--", "--", @"Do not interpret any more arguments as options."),
					new GitCommandOption("--conflict", "--conflict=<style>", @"The same as --merge option above, but changes the way the conflicting hunks are presented, overriding the merge.conflictStyle configuration variable.  Possible values are ""merge"" (default), ""diff3"", and ""zdiff3""."),
					new GitCommandOption("--ignore-skip-worktree-bits", "--ignore-skip-worktree-bits", @"In sparse checkout mode, by default is to only update entries matched by <pathspec> and sparse patterns in $GIT_DIR/info/sparse-checkout. This option ignores the sparse patterns and unconditionally restores any files in <pathspec>."),
					new GitCommandOption("--ignore-unmerged", "--ignore-unmerged", @"When restoring files on the working tree from the index, do not abort the operation if there are unmerged entries and neither --ours, --theirs, --merge or --conflict is specified. Unmerged paths on the working tree are left alone."),
					new GitCommandOption("--merge", "--merge", @"When restoring files on the working tree from the index, recreate the conflicted merge in the unmerged paths."),
					new GitCommandOption("--no-overlay", "--no-overlay", @"In overlay mode, the command never removes files when restoring. In no-overlay mode, tracked files that do not appear in the --source tree are removed, to make them match <tree> exactly. The default is no-overlay mode."),
					new GitCommandOption("--no-progress", "--no-progress", @"Progress status is reported on the standard error stream by default when it is attached to a terminal, unless --quiet is specified. This flag enables progress reporting even if not attached to a terminal, regardless of --quiet."),
					new GitCommandOption("--no-recurse-submodules", "--no-recurse-submodules", @"If <pathspec> names an active submodule and the restore location includes the working tree, the submodule will only be updated if this option is given, in which case its working tree will be restored to the commit recorded in the superproject, and any local modifications overwritten. If nothing (or --no-recurse-submodules) is used, submodules working trees will not be updated. Just like git-checkout, this will detach HEAD of the submodule."),
					new GitCommandOption("--ours", "--ours", @"When restoring files in the working tree from the index, use stage #2 (ours) or #3 (theirs) for unmerged paths.  Note that during git rebase and git pull --rebase, ours and theirs may appear swapped. See the explanation of the same options in git-checkout for details."),
					new GitCommandOption("--overlay", "--overlay", @"In overlay mode, the command never removes files when restoring. In no-overlay mode, tracked files that do not appear in the --source tree are removed, to make them match <tree> exactly. The default is no-overlay mode."),
					new GitCommandOption("--patch", "--patch", @"Interactively select hunks in the difference between the restore source and the restore location. See the “Interactive Mode” section of git-add to learn how to operate the --patch mode.  Note that --patch can accept no pathspec and will prompt to restore all modified paths."),
					new GitCommandOption("--pathspec-file-nul", "--pathspec-file-nul", @"Only meaningful with --pathspec-from-file. Pathspec elements are separated with NUL character and all other characters are taken literally (including newlines and quotes)."),
					new GitCommandOption("--pathspec-from-file", "--pathspec-from-file=<file>", @"Pathspec is passed in <file> instead of commandline args. If <file> is exactly - then standard input is used. Pathspec elements are separated by LF or CR/LF. Pathspec elements can be quoted as explained for the configuration variable core.quotePath (see git-config). See also --pathspec-file-nul and global --literal-pathspecs."),
					new GitCommandOption("--progress", "--progress", @"Progress status is reported on the standard error stream by default when it is attached to a terminal, unless --quiet is specified. This flag enables progress reporting even if not attached to a terminal, regardless of --quiet."),
					new GitCommandOption("--quiet", "--quiet", @"Quiet, suppress feedback messages. Implies --no-progress."),
					new GitCommandOption("--recurse-submodules", "--recurse-submodules", @"If <pathspec> names an active submodule and the restore location includes the working tree, the submodule will only be updated if this option is given, in which case its working tree will be restored to the commit recorded in the superproject, and any local modifications overwritten. If nothing (or --no-recurse-submodules) is used, submodules working trees will not be updated. Just like git-checkout, this will detach HEAD of the submodule."),
					new GitCommandOption("--source", "--source=<tree>", @"Restore the working tree files with the content from the given tree. It is common to specify the source tree by naming a commit, branch or tag associated with it.  If not specified, the contents are restored from HEAD if --staged is given, otherwise from the index.   As a special case, you may use ""A...B"" as a shortcut for the merge base of A and B if there is exactly one merge base. You can leave out at most one of A and B, in which case it defaults to HEAD."),
					new GitCommandOption("--staged", "--staged", @"Specify the restore location. If neither option is specified, by default the working tree is restored. Specifying --staged will only restore the index. Specifying both restores both."),
					new GitCommandOption("--theirs", "--theirs", @"When restoring files in the working tree from the index, use stage #2 (ours) or #3 (theirs) for unmerged paths.  Note that during git rebase and git pull --rebase, ours and theirs may appear swapped. See the explanation of the same options in git-checkout for details."),
					new GitCommandOption("--worktree", "--worktree", @"Specify the restore location. If neither option is specified, by default the working tree is restored. Specifying --staged will only restore the index. Specifying both restores both."),
					new GitCommandOption("-m", "-m", @"When restoring files on the working tree from the index, recreate the conflicted merge in the unmerged paths."),
					new GitCommandOption("-p", "-p", @"Interactively select hunks in the difference between the restore source and the restore location. See the “Interactive Mode” section of git-add to learn how to operate the --patch mode.  Note that --patch can accept no pathspec and will prompt to restore all modified paths."),
					new GitCommandOption("-q", "-q", @"Quiet, suppress feedback messages. Implies --no-progress."),
					new GitCommandOption("-S", "-S", @"Specify the restore location. If neither option is specified, by default the working tree is restored. Specifying --staged will only restore the index. Specifying both restores both."),
					new GitCommandOption("-s", "-s <tree>", @"Restore the working tree files with the content from the given tree. It is common to specify the source tree by naming a commit, branch or tag associated with it.  If not specified, the contents are restored from HEAD if --staged is given, otherwise from the index.   As a special case, you may use ""A...B"" as a shortcut for the merge base of A and B if there is exactly one merge base. You can leave out at most one of A and B, in which case it defaults to HEAD."),
					new GitCommandOption("-W", "-W", @"Specify the restore location. If neither option is specified, by default the working tree is restored. Specifying --staged will only restore the index. Specifying both restores both."),
				}, 
	"rev-list" => new GitCommandOption[] {
					new GitCommandOption("<paths>", "<paths>", @"Commits modifying the given <paths> are selected."),
					new GitCommandOption("--abbrev-commit", "--abbrev-commit", @"Instead of showing the full 40-byte hexadecimal commit object name, show a prefix that names the object uniquely. ""--abbrev=<n>"" (which also modifies diff output, if it is displayed) option can be used to specify the minimum length of the prefix.  This should make ""--pretty=oneline"" a whole lot more readable for people using 80-column terminals."),
					new GitCommandOption("--after", "--after=<date>", @"Show commits more recent than a specific date."),
					new GitCommandOption("--all", "--all", @"Pretend as if all the refs in refs/, along with HEAD, are listed on the command line as <commit>."),
					new GitCommandOption("--all-match", "--all-match", @"Limit the commits output to ones that match all given --grep, instead of ones that match at least one."),
					new GitCommandOption("--alternate-refs", "--alternate-refs", @"Pretend as if all objects mentioned as ref tips of alternate repositories were listed on the command line. An alternate repository is any repository whose object directory is specified in objects/info/alternates.  The set of included objects may be modified by core.alternateRefsCommand, etc. See git-config."),
					new GitCommandOption("--ancestry-path", "--ancestry-path", @"Limit the displayed commits to those directly on the ancestry chain between the “from” and “to” commits in the given commit range. I.e. only display commits that are ancestor of the “to” commit and descendants of the “from” commit.  As an example use case, consider the following commit history:                D---E-------F            /     \       \           B---C---G---H---I---J          /                     \         A-------K---------------L--M    A regular D..M computes the set of commits that are ancestors of M, but excludes the ones that are ancestors of D. This is useful to see what happened to the history leading to M since D, in the sense that “what does M have that did not exist in D”. The result in this example would be all the commits, except A and B (and D itself, of course).   When we want to find out what commits in M are contaminated with the bug introduced by D and need fixing, however, we might want to view only the subset of D..M that are actually descendants of D, i.e. excluding C and K. This is exactly what the --ancestry-path option does. Applied to the D..M range, it results in:                    E-------F                  \       \                   G---H---I---J                                \                                 L--M"),
					new GitCommandOption("--ancestry-path", "--ancestry-path", @"When given a range of commits to display (e.g. commit1..commit2 or commit2 ^commit1), only display commits that exist directly on the ancestry chain between the commit1 and commit2, i.e. commits that are both descendants of commit1, and ancestors of commit2."),
					new GitCommandOption("--author", "--author=<pattern>", @"Limit the commits output to ones with author/committer header lines that match the specified pattern (regular expression).  With more than one --author=<pattern>, commits whose author matches any of the given patterns are chosen (similarly for multiple --committer=<pattern>)."),
					new GitCommandOption("--author-date-order", "--author-date-order", @"Show no parents before all of its children are shown, but otherwise show commits in the author timestamp order."),
					new GitCommandOption("--basic-regexp", "--basic-regexp", @"Consider the limiting patterns to be basic regular expressions; this is the default."),
					new GitCommandOption("--before", "--before=<date>", @"Show commits older than a specific date."),
					new GitCommandOption("--bisect", "--bisect", @"Limit output to the one commit object which is roughly halfway between included and excluded commits. Note that the bad bisection ref refs/bisect/bad is added to the included commits (if it exists) and the good bisection refs refs/bisect/good-* are added to the excluded commits (if they exist). Thus, supposing there are no refs in refs/bisect/, if           $ git rev-list --bisect foo ^bar ^baz    outputs midpoint, the output of the two commands            $ git rev-list foo ^midpoint         $ git rev-list midpoint ^bar ^baz    would be of roughly the same length.  Finding the change which introduces a regression is thus reduced to a binary search: repeatedly generate and test new 'midpoint’s until the commit chain is of length one."),
					new GitCommandOption("--bisect-all", "--bisect-all", @"This outputs all the commit objects between the included and excluded commits, ordered by their distance to the included and excluded commits. Refs in refs/bisect/ are not used. The farthest from them is displayed first. (This is the only one displayed by --bisect.)  This is useful because it makes it easy to choose a good commit to test when you want to avoid to test some of them for some reason (they may not compile for example).   This option can be used along with --bisect-vars, in this case, after all the sorted commit objects, there will be the same text as if --bisect-vars had been used alone."),
					new GitCommandOption("--bisect-vars", "--bisect-vars", @"This calculates the same as --bisect, except that refs in refs/bisect/ are not used, and except that this outputs text ready to be eval’ed by the shell. These lines will assign the name of the midpoint revision to the variable bisect_rev, and the expected number of commits to be tested after bisect_rev is tested to bisect_nr, the expected number of commits to be tested if bisect_rev turns out to be good to bisect_good, the expected number of commits to be tested if bisect_rev turns out to be bad to bisect_bad, and the number of commits we are bisecting right now to bisect_all."),
					new GitCommandOption("--boundary", "--boundary", @"Output excluded boundary commits. Boundary commits are prefixed with -."),
					new GitCommandOption("--branches[", "--branches[=<pattern>]", @"Pretend as if all the refs in refs/heads are listed on the command line as <commit>. If <pattern> is given, limit branches to ones matching given shell glob. If pattern lacks ?, *, or [, /* at the end is implied."),
					new GitCommandOption("--cherry", "--cherry", @"A synonym for --right-only --cherry-mark --no-merges; useful to limit the output to the commits on our side and mark those that have been applied to the other side of a forked history with git log --cherry upstream...mybranch, similar to git cherry upstream mybranch."),
					new GitCommandOption("--cherry-mark", "--cherry-mark", @"Like --cherry-pick (see below) but mark equivalent commits with = rather than omitting them, and inequivalent ones with +."),
					new GitCommandOption("--cherry-pick", "--cherry-pick", @"Omit any commit that introduces the same change as another commit on the “other side” when the set of commits are limited with symmetric difference.  For example, if you have two branches, A and B, a usual way to list all commits on only one side of them is with --left-right (see the example below in the description of the --left-right option). However, it shows the commits that were cherry-picked from the other branch (for example, “3rd on b” may be cherry-picked from branch A). With this option, such pairs of commits are excluded from the output."),
					new GitCommandOption("--children", "--children", @"Print also the children of the commit (in the form ""commit child…​""). Also enables parent rewriting, see History Simplification above."),
					new GitCommandOption("--commit-header", "--commit-header", @"Overrides a previous --no-commit-header."),
					new GitCommandOption("--committer", "--committer=<pattern>", @"Limit the commits output to ones with author/committer header lines that match the specified pattern (regular expression).  With more than one --author=<pattern>, commits whose author matches any of the given patterns are chosen (similarly for multiple --committer=<pattern>)."),
					new GitCommandOption("--count", "--count", @"Print a number stating how many commits would have been listed, and suppress all other output.  When used together with --left-right, instead print the counts for left and right commits, separated by a tab. When used together with --cherry-mark, omit patch equivalent commits from these counts and print the count for equivalent commits separated by a tab."),
					new GitCommandOption("--date", "--date=<format>", @"Only takes effect for dates shown in human-readable format, such as when using --pretty. log.date config variable sets a default value for the log command’s --date option. By default, dates are shown in the original time zone (either committer’s or author’s). If -local is appended to the format (e.g., iso-local), the user’s local time zone is used instead.    --date=relative shows dates relative to the current time, e.g. “2 hours ago”. The -local option has no effect for --date=relative.   --date=local is an alias for --date=default-local.   --date=iso (or --date=iso8601) shows timestamps in a ISO 8601-like format. The differences to the strict ISO 8601 format are:     a space instead of the T date/time delimiter   a space between time and time zone   no colon between hours and minutes of the time zone     --date=iso-strict (or --date=iso8601-strict) shows timestamps in strict ISO 8601 format.   --date=rfc (or --date=rfc2822) shows timestamps in RFC 2822 format, often found in email messages.   --date=short shows only the date, but not the time, in YYYY-MM-DD format.   --date=raw shows the date as seconds since the epoch (1970-01-01 00:00:00 UTC), followed by a space, and then the timezone as an offset from UTC (a + or - with four digits; the first two are hours, and the second two are minutes). I.e., as if the timestamp were formatted with strftime(""%s %z"")). Note that the -local option does not affect the seconds-since-epoch value (which is always measured in UTC), but does switch the accompanying timezone value.   --date=human shows the timezone if the timezone does not match the current time-zone, and doesn’t print the whole date if that matches (ie skip printing year for dates that are ""this year"", but also skip the whole date itself if it’s in the last few days and we can just say what weekday it was).  For older dates the hour and minute is also omitted.   --date=unix shows the date as a Unix epoch timestamp (seconds since 1970).  As with --raw, this is always in UTC and therefore -local has no effect.   --date=format:... feeds the format ... to your system strftime, except for %s, %z, and %Z, which are handled internally. Use --date=format:%c to show the date in your system locale’s preferred format.  See the strftime manual for a complete list of format placeholders. When using -local, the correct syntax is --date=format-local:....   --date=default is the default format, and is similar to --date=rfc2822, with a few exceptions:       there is no comma after the day-of-week   the time zone is omitted when the local time zone is used"),
					new GitCommandOption("--date-order", "--date-order", @"Show no parents before all of its children are shown, but otherwise show commits in the commit timestamp order."),
					new GitCommandOption("--dense", "--dense", @"Commits that are walked are included if they are not TREESAME to any parent."),
					new GitCommandOption("--dense", "--dense", @"Only the selected commits are shown, plus some to have a meaningful history."),
					new GitCommandOption("--disk-usage", "--disk-usage", @"Suppress normal output; instead, print the sum of the bytes used for on-disk storage by the selected commits or objects. This is equivalent to piping the output into git cat-file --batch-check='%(objectsize:disk)', except that it runs much faster (especially with --use-bitmap-index). See the CAVEATS section in git-cat-file for the limitations of what ""on-disk storage"" means."),
					new GitCommandOption("--do-walk", "--do-walk", @"Overrides a previous --no-walk."),
					new GitCommandOption("--encoding", "--encoding=<encoding>", @"Commit objects record the character encoding used for the log message in their encoding header; this option can be used to tell the command to re-code the commit log message in the encoding preferred by the user.  For non plumbing commands this defaults to UTF-8. Note that if an object claims to be encoded in X and we are outputting in X, we will output the object verbatim; this means that invalid sequences in the original commit may be copied to the output. Likewise, if iconv fails to convert the commit, we will quietly output the original object verbatim."),
					new GitCommandOption("--exclude", "--exclude=<glob-pattern>", @"Do not include refs matching <glob-pattern> that the next --all, --branches, --tags, --remotes, or --glob would otherwise consider. Repetitions of this option accumulate exclusion patterns up to the next --all, --branches, --tags, --remotes, or --glob option (other options or arguments do not clear accumulated patterns).  The patterns given should not begin with refs/heads, refs/tags, or refs/remotes when applied to --branches, --tags, or --remotes, respectively, and they must begin with refs/ when applied to --glob or --all. If a trailing /* is intended, it must be given explicitly."),
					new GitCommandOption("--exclude-first-parent-only", "--exclude-first-parent-only", @"When finding commits to exclude (with a ^), follow only the first parent commit upon seeing a merge commit. This can be used to find the set of changes in a topic branch from the point where it diverged from the remote branch, given that arbitrary merges can be valid topic branch changes."),
					new GitCommandOption("--exclude-promisor-objects", "--exclude-promisor-objects", @"(For internal use only.)  Prefilter object traversal at promisor boundary.  This is used with partial clone.  This is stronger than --missing=allow-promisor because it limits the traversal, rather than just silencing errors about missing objects."),
					new GitCommandOption("--expand-tabs", "--expand-tabs=<n>", @"Perform a tab expansion (replace each tab with enough spaces to fill to the next display column that is multiple of <n>) in the log message before showing it in the output. --expand-tabs is a short-hand for --expand-tabs=8, and --no-expand-tabs is a short-hand for --expand-tabs=0, which disables tab expansion.  By default, tabs are expanded in pretty formats that indent the log message by 4 spaces (i.e.  medium, which is the default, full, and fuller)."),
					new GitCommandOption("--expand-tabs", "--expand-tabs", @"Perform a tab expansion (replace each tab with enough spaces to fill to the next display column that is multiple of <n>) in the log message before showing it in the output. --expand-tabs is a short-hand for --expand-tabs=8, and --no-expand-tabs is a short-hand for --expand-tabs=0, which disables tab expansion.  By default, tabs are expanded in pretty formats that indent the log message by 4 spaces (i.e.  medium, which is the default, full, and fuller)."),
					new GitCommandOption("--extended-regexp", "--extended-regexp", @"Consider the limiting patterns to be extended regular expressions instead of the default basic regular expressions."),
					new GitCommandOption("--filter", "--filter=<filter-spec>", @"Only useful with one of the --objects*; omits objects (usually blobs) from the list of printed objects.  The <filter-spec> may be one of the following:  The form --filter=blob:none omits all blobs.   The form --filter=blob:limit=<n>[kmg] omits blobs larger than n bytes or units.  n may be zero.  The suffixes k, m, and g can be used to name units in KiB, MiB, or GiB.  For example, blob:limit=1k is the same as blob:limit=1024.   The form --filter=object:type=(tag|commit|tree|blob) omits all objects which are not of the requested type.   The form --filter=sparse:oid=<blob-ish> uses a sparse-checkout specification contained in the blob (or blob-expression) <blob-ish> to omit blobs that would not be required for a sparse checkout on the requested refs.   The form --filter=tree:<depth> omits all blobs and trees whose depth from the root tree is >= <depth> (minimum depth if an object is located at multiple depths in the commits traversed). <depth>=0 will not include any trees or blobs unless included explicitly in the command-line (or standard input when --stdin is used). <depth>=1 will include only the tree and blobs which are referenced directly by a commit reachable from <commit> or an explicitly-given object. <depth>=2 is like <depth>=1 while also including trees and blobs one more level removed from an explicitly-given commit or tree.   Note that the form --filter=sparse:path=<path> that wants to read from an arbitrary path on the filesystem has been dropped for security reasons.   Multiple --filter= flags can be specified to combine filters. Only objects which are accepted by every filter are included.   The form --filter=combine:<filter1>+<filter2>+…​<filterN> can also be used to combined several filters, but this is harder than just repeating the --filter flag and is usually not necessary. Filters are joined by + and individual filters are %-encoded (i.e. URL-encoded). Besides the + and % characters, the following characters are reserved and also must be encoded: ~!@#$^&*()[]{}\;"",<>?'` as well as all characters with ASCII code <= 0x20, which includes space and newline.   Other arbitrary characters can also be encoded. For instance, combine:tree:3+blob:none and combine:tree%3A3+blob%3Anone are equivalent."),
					new GitCommandOption("--filter-print-omitted", "--filter-print-omitted", @"Only useful with --filter=; prints a list of the objects omitted by the filter.  Object IDs are prefixed with a “~” character."),
					new GitCommandOption("--filter-provided-objects", "--filter-provided-objects", @"Filter the list of explicitly provided objects, which would otherwise always be printed even if they did not match any of the filters. Only useful with --filter=."),
					new GitCommandOption("--first-parent", "--first-parent", @"When finding commits to include, follow only the first parent commit upon seeing a merge commit.  This option can give a better overview when viewing the evolution of a particular topic branch, because merges into a topic branch tend to be only about adjusting to updated upstream from time to time, and this option allows you to ignore the individual commits brought in to your history by such a merge."),
					new GitCommandOption("--fixed-strings", "--fixed-strings", @"Consider the limiting patterns to be fixed strings (don’t interpret pattern as a regular expression)."),
					new GitCommandOption("--format", "--format=<format>", @"Pretty-print the contents of the commit logs in a given format, where <format> can be one of oneline, short, medium, full, fuller, reference, email, raw, format:<string> and tformat:<string>.  When <format> is none of the above, and has %placeholder in it, it acts as if --pretty=tformat:<format> were given.  See the ""PRETTY FORMATS"" section for some additional details for each format.  When =<format> part is omitted, it defaults to medium.   Note: you can specify the default pretty format in the repository configuration (see git-config)."),
					new GitCommandOption("--full-history", "--full-history without parent rewriting", @"This mode differs from the default in one point: always follow all parents of a merge, even if it is TREESAME to one of them. Even if more than one side of the merge has commits that are included, this does not imply that the merge itself is!  In the example, we get           I  A  B  N  D  O  P  Q    M was excluded because it is TREESAME to both parents.  E, C and B were all walked, but only B was !TREESAME, so the others do not appear.   Note that without parent rewriting, it is not really possible to talk about the parent/child relationships between the commits, so we show them disconnected."),
					new GitCommandOption("--full-history", "--full-history with parent rewriting", @"Ordinary commits are only included if they are !TREESAME (though this can be changed, see --sparse below).  Merges are always included.  However, their parent list is rewritten: Along each parent, prune away commits that are not included themselves.  This results in              .-A---M---N---O---P---Q          /     /   /   /   /         I     B   /   D   /          \   /   /   /   /           `-------------'    Compare to --full-history without rewriting above.  Note that E was pruned away because it is TREESAME, but the parent list of P was rewritten to contain E's parent I.  The same happened for C and N, and X, Y and Q."),
					new GitCommandOption("--full-history", "--full-history", @"Same as the default mode, but does not prune some history."),
					new GitCommandOption("--glob", "--glob=<glob-pattern>", @"Pretend as if all the refs matching shell glob <glob-pattern> are listed on the command line as <commit>. Leading refs/, is automatically prepended if missing. If pattern lacks ?, *, or [, /* at the end is implied."),
					new GitCommandOption("--graph", "--graph", @"Draw a text-based graphical representation of the commit history on the left hand side of the output.  This may cause extra lines to be printed in between commits, in order for the graph history to be drawn properly. Cannot be combined with --no-walk.  This enables parent rewriting, see History Simplification above.   This implies the --topo-order option by default, but the --date-order option may also be specified."),
					new GitCommandOption("--grep", "--grep=<pattern>", @"Limit the commits output to ones with log message that matches the specified pattern (regular expression).  With more than one --grep=<pattern>, commits whose message matches any of the given patterns are chosen (but see --all-match)."),
					new GitCommandOption("--grep-reflog", "--grep-reflog=<pattern>", @"Limit the commits output to ones with reflog entries that match the specified pattern (regular expression). With more than one --grep-reflog, commits whose reflog message matches any of the given patterns are chosen.  It is an error to use this option unless --walk-reflogs is in use."),
					new GitCommandOption("--header", "--header", @"Print the contents of the commit in raw-format; each record is separated with a NUL character."),
					new GitCommandOption("--ignore-missing", "--ignore-missing", @"Upon seeing an invalid object name in the input, pretend as if the bad input was not given."),
					new GitCommandOption("--in-commit-order", "--in-commit-order", @"Print tree and blob ids in order of the commits. The tree and blob ids are printed after they are first referenced by a commit."),
					new GitCommandOption("--indexed-objects", "--indexed-objects", @"Pretend as if all trees and blobs used by the index are listed on the command line.  Note that you probably want to use --objects, too."),
					new GitCommandOption("--invert-grep", "--invert-grep", @"Limit the commits output to ones with log message that do not match the pattern specified with --grep=<pattern>."),
					new GitCommandOption("--left-only", "--left-only", @"List only commits on the respective side of a symmetric difference, i.e. only those which would be marked < resp. > by --left-right.  For example, --cherry-pick --right-only A...B omits those commits from B which are in A or are patch-equivalent to a commit in A. In other words, this lists the + commits from git cherry A B. More precisely, --cherry-pick --right-only --no-merges gives the exact list."),
					new GitCommandOption("--left-right", "--left-right", @"Mark which side of a symmetric difference a commit is reachable from. Commits from the left side are prefixed with < and those from the right with >.  If combined with --boundary, those commits are prefixed with -.  For example, if you have this topology:                 y---b---b  branch B             / \ /            /   .           /   / \          o---x---a---a  branch A    you would get an output like this:            $ git rev-list --left-right --boundary --pretty=oneline A...B          >bbbbbbb... 3rd on b         >bbbbbbb... 2nd on b         <aaaaaaa... 3rd on a         <aaaaaaa... 2nd on a         -yyyyyyy... 1st on b         -xxxxxxx... 1st on a"),
					new GitCommandOption("--max-age", "--max-age=<timestamp>", @"Limit the commits output to specified time range."),
					new GitCommandOption("--max-count", "--max-count=<number>", @"Limit the number of commits to output."),
					new GitCommandOption("--max-parents", "--max-parents=<number>", @"Show only commits which have at least (or at most) that many parent commits. In particular, --max-parents=1 is the same as --no-merges, --min-parents=2 is the same as --merges.  --max-parents=0 gives all root commits and --min-parents=3 all octopus merges.  --no-min-parents and --no-max-parents reset these limits (to no limit) again.  Equivalent forms are --min-parents=0 (any commit has 0 or more parents) and --max-parents=-1 (negative numbers denote no upper limit)."),
					new GitCommandOption("--merge", "--merge", @"After a failed merge, show refs that touch files having a conflict and don’t exist on all heads to merge."),
					new GitCommandOption("--merges", "--merges", @"Print only merge commits. This is exactly the same as --min-parents=2."),
					new GitCommandOption("--min-age", "--min-age=<timestamp>", @"Limit the commits output to specified time range."),
					new GitCommandOption("--min-parents", "--min-parents=<number>", @"Show only commits which have at least (or at most) that many parent commits. In particular, --max-parents=1 is the same as --no-merges, --min-parents=2 is the same as --merges.  --max-parents=0 gives all root commits and --min-parents=3 all octopus merges.  --no-min-parents and --no-max-parents reset these limits (to no limit) again.  Equivalent forms are --min-parents=0 (any commit has 0 or more parents) and --max-parents=-1 (negative numbers denote no upper limit)."),
					new GitCommandOption("--missing", "--missing=<missing-action>", @"A debug option to help with future ""partial clone"" development. This option specifies how missing objects are handled.  The form --missing=error requests that rev-list stop with an error if a missing object is encountered.  This is the default action.   The form --missing=allow-any will allow object traversal to continue if a missing object is encountered.  Missing objects will silently be omitted from the results.   The form --missing=allow-promisor is like allow-any, but will only allow object traversal to continue for EXPECTED promisor missing objects. Unexpected missing objects will raise an error.   The form --missing=print is like allow-any, but will also print a list of the missing objects.  Object IDs are prefixed with a “?” character."),
					new GitCommandOption("--no-abbrev-commit", "--no-abbrev-commit", @"Show the full 40-byte hexadecimal commit object name. This negates --abbrev-commit, either explicit or implied by other options such as ""--oneline"". It also overrides the log.abbrevCommit variable."),
					new GitCommandOption("--no-commit-header", "--no-commit-header", @"Suppress the header line containing ""commit"" and the object ID printed before the specified format.  This has no effect on the built-in formats; only custom formats are affected."),
					new GitCommandOption("--no-expand-tabs", "--no-expand-tabs", @"Perform a tab expansion (replace each tab with enough spaces to fill to the next display column that is multiple of <n>) in the log message before showing it in the output. --expand-tabs is a short-hand for --expand-tabs=8, and --no-expand-tabs is a short-hand for --expand-tabs=0, which disables tab expansion.  By default, tabs are expanded in pretty formats that indent the log message by 4 spaces (i.e.  medium, which is the default, full, and fuller)."),
					new GitCommandOption("--no-filter", "--no-filter", @"Turn off any previous --filter= argument."),
					new GitCommandOption("--no-max-parents", "--no-max-parents", @"Show only commits which have at least (or at most) that many parent commits. In particular, --max-parents=1 is the same as --no-merges, --min-parents=2 is the same as --merges.  --max-parents=0 gives all root commits and --min-parents=3 all octopus merges.  --no-min-parents and --no-max-parents reset these limits (to no limit) again.  Equivalent forms are --min-parents=0 (any commit has 0 or more parents) and --max-parents=-1 (negative numbers denote no upper limit)."),
					new GitCommandOption("--no-merges", "--no-merges", @"Do not print commits with more than one parent. This is exactly the same as --max-parents=1."),
					new GitCommandOption("--no-min-parents", "--no-min-parents", @"Show only commits which have at least (or at most) that many parent commits. In particular, --max-parents=1 is the same as --no-merges, --min-parents=2 is the same as --merges.  --max-parents=0 gives all root commits and --min-parents=3 all octopus merges.  --no-min-parents and --no-max-parents reset these limits (to no limit) again.  Equivalent forms are --min-parents=0 (any commit has 0 or more parents) and --max-parents=-1 (negative numbers denote no upper limit)."),
					new GitCommandOption("--no-object-names", "--no-object-names", @"Only useful with --objects; does not print the names of the object IDs that are found. This inverts --object-names. This flag allows the output to be more easily parsed by commands such as git-cat-file."),
					new GitCommandOption("--no-walk[", "--no-walk[=(sorted|unsorted)]", @"Only show the given commits, but do not traverse their ancestors. This has no effect if a range is specified. If the argument unsorted is given, the commits are shown in the order they were given on the command line. Otherwise (if sorted or no argument was given), the commits are shown in reverse chronological order by commit time. Cannot be combined with --graph."),
					new GitCommandOption("--not", "--not", @"Reverses the meaning of the ^ prefix (or lack thereof) for all following revision specifiers, up to the next --not."),
					new GitCommandOption("--object-names", "--object-names", @"Only useful with --objects; print the names of the object IDs that are found. This is the default behavior."),
					new GitCommandOption("--objects", "--objects", @"Print the object IDs of any object referenced by the listed commits.  --objects foo ^bar thus means “send me all object IDs which I need to download if I have the commit object bar but not foo”."),
					new GitCommandOption("--objects-edge", "--objects-edge", @"Similar to --objects, but also print the IDs of excluded commits prefixed with a “-” character.  This is used by git-pack-objects to build a “thin” pack, which records objects in deltified form based on objects contained in these excluded commits to reduce network traffic."),
					new GitCommandOption("--objects-edge-aggressive", "--objects-edge-aggressive", @"Similar to --objects-edge, but it tries harder to find excluded commits at the cost of increased time.  This is used instead of --objects-edge to build “thin” packs for shallow repositories."),
					new GitCommandOption("--oneline", "--oneline", @"This is a shorthand for ""--pretty=oneline --abbrev-commit"" used together."),
					new GitCommandOption("--parents", "--parents", @"Print also the parents of the commit (in the form ""commit parent…​""). Also enables parent rewriting, see History Simplification above."),
					new GitCommandOption("--perl-regexp", "--perl-regexp", @"Consider the limiting patterns to be Perl-compatible regular expressions.  Support for these types of regular expressions is an optional compile-time dependency. If Git wasn’t compiled with support for them providing this option will cause it to die."),
					new GitCommandOption("--pretty[", "--pretty[=<format>]", @"Pretty-print the contents of the commit logs in a given format, where <format> can be one of oneline, short, medium, full, fuller, reference, email, raw, format:<string> and tformat:<string>.  When <format> is none of the above, and has %placeholder in it, it acts as if --pretty=tformat:<format> were given.  See the ""PRETTY FORMATS"" section for some additional details for each format.  When =<format> part is omitted, it defaults to medium.   Note: you can specify the default pretty format in the repository configuration (see git-config)."),
					new GitCommandOption("--progress", "--progress=<header>", @"Show progress reports on stderr as objects are considered. The <header> text will be printed with each progress update."),
					new GitCommandOption("--quiet", "--quiet", @"Don’t print anything to standard output.  This form is primarily meant to allow the caller to test the exit status to see if a range of objects is fully connected (or not).  It is faster than redirecting stdout to /dev/null as the output does not have to be formatted."),
					new GitCommandOption("--reflog", "--reflog", @"Pretend as if all objects mentioned by reflogs are listed on the command line as <commit>."),
					new GitCommandOption("--regexp-ignore-case", "--regexp-ignore-case", @"Match the regular expression limiting patterns without regard to letter case."),
					new GitCommandOption("--relative-date", "--relative-date", @"Synonym for --date=relative."),
					new GitCommandOption("--remotes[", "--remotes[=<pattern>]", @"Pretend as if all the refs in refs/remotes are listed on the command line as <commit>. If <pattern> is given, limit remote-tracking branches to ones matching given shell glob. If pattern lacks ?, *, or [, /* at the end is implied."),
					new GitCommandOption("--remove-empty", "--remove-empty", @"Stop when a given path disappears from the tree."),
					new GitCommandOption("--reverse", "--reverse", @"Output the commits chosen to be shown (see Commit Limiting section above) in reverse order. Cannot be combined with --walk-reflogs."),
					new GitCommandOption("--right-only", "--right-only", @"List only commits on the respective side of a symmetric difference, i.e. only those which would be marked < resp. > by --left-right.  For example, --cherry-pick --right-only A...B omits those commits from B which are in A or are patch-equivalent to a commit in A. In other words, this lists the + commits from git cherry A B. More precisely, --cherry-pick --right-only --no-merges gives the exact list."),
					new GitCommandOption("--show-linear-break[", "--show-linear-break[=<barrier>]", @"When --graph is not used, all history branches are flattened which can make it hard to see that the two consecutive commits do not belong to a linear branch. This option puts a barrier in between them in that case. If <barrier> is specified, it is the string that will be shown instead of the default one."),
					new GitCommandOption("--show-pulls", "--show-pulls", @"In addition to the commits shown in the default history, show each merge commit that is not TREESAME to its first parent but is TREESAME to a later parent.  When a merge commit is included by --show-pulls, the merge is treated as if it ""pulled"" the change from another branch. When using --show-pulls on this example (and no other options) the resulting graph is:            I---X---R---N    Here, the merge commits R and N are included because they pulled the commits X and R into the base branch, respectively. These merges are the reason the commits A and B do not appear in the default history.   When --show-pulls is paired with --simplify-merges, the graph includes all of the necessary information:              .-A---M--.   N          /     /    \ /         I     B      R          \   /      /           \ /      /            `---X--'    Notice that since M is reachable from R, the edge from N to M was simplified away. However, N still appears in the history as an important commit because it ""pulled"" the change R into the main branch."),
					new GitCommandOption("--show-pulls", "--show-pulls", @"Include all commits from the default mode, but also any merge commits that are not TREESAME to the first parent but are TREESAME to a later parent. This mode is helpful for showing the merge commits that ""first introduced"" a change to a branch."),
					new GitCommandOption("--show-signature", "--show-signature", @"Check the validity of a signed commit object by passing the signature to gpg --verify and show the output."),
					new GitCommandOption("--simplify-by-decoration", "--simplify-by-decoration", @"Commits that are referred by some branch or tag are selected."),
					new GitCommandOption("--simplify-merges", "--simplify-merges", @"First, build a history graph in the same way that --full-history with parent rewriting does (see above).  Then simplify each commit C to its replacement C' in the final history according to the following rules:       Set C' to C.   Replace each parent P of C' with its simplification P'.  In the process, drop parents that are ancestors of other parents or that are root commits TREESAME to an empty tree, and remove duplicates, but take care to never drop all parents that we are TREESAME to.   If after this parent rewriting, C' is a root or merge commit (has zero or >1 parents), a boundary commit, or !TREESAME, it remains. Otherwise, it is replaced with its only parent.       The effect of this is best shown by way of comparing to --full-history with parent rewriting.  The example turns into:              .-A---M---N---O          /     /       /         I     B       D          \   /       /           `---------'    Note the major differences in N, P, and Q over --full-history:       N's parent list had I removed, because it is an ancestor of the other parent M.  Still, N remained because it is !TREESAME.   P's parent list similarly had I removed.  P was then removed completely, because it had one parent and is TREESAME.   Q's parent list had Y simplified to X. X was then removed, because it was a TREESAME root. Q was then removed completely, because it had one parent and is TREESAME."),
					new GitCommandOption("--simplify-merges", "--simplify-merges", @"Additional option to --full-history to remove some needless merges from the resulting history, as there are no selected commits contributing to this merge."),
					new GitCommandOption("--since", "--since=<date>", @"Show commits more recent than a specific date."),
					new GitCommandOption("--single-worktree", "--single-worktree", @"By default, all working trees will be examined by the following options when there are more than one (see git-worktree): --all, --reflog and --indexed-objects. This option forces them to examine the current working tree only."),
					new GitCommandOption("--skip", "--skip=<number>", @"Skip number commits before starting to show the commit output."),
					new GitCommandOption("--sparse", "--sparse", @"All commits that are walked are included.  Note that without --full-history, this still simplifies merges: if one of the parents is TREESAME, we follow only that one, so the other sides of the merge are never walked."),
					new GitCommandOption("--sparse", "--sparse", @"All commits in the simplified history are shown."),
					new GitCommandOption("--stdin", "--stdin", @"In addition to the <commit> listed on the command line, read them from the standard input. If a -- separator is seen, stop reading commits and start reading paths to limit the result."),
					new GitCommandOption("--tags[", "--tags[=<pattern>]", @"Pretend as if all the refs in refs/tags are listed on the command line as <commit>. If <pattern> is given, limit tags to ones matching given shell glob. If pattern lacks ?, *, or [, /* at the end is implied."),
					new GitCommandOption("--timestamp", "--timestamp", @"Print the raw commit timestamp."),
					new GitCommandOption("--topo-order", "--topo-order", @"Show no parents before all of its children are shown, and avoid showing commits on multiple lines of history intermixed.  For example, in a commit history like this:        ---1----2----4----7         \              \          3----5----6----8---    where the numbers denote the order of commit timestamps, git rev-list and friends with --date-order show the commits in the timestamp order: 8 7 6 5 4 3 2 1.   With --topo-order, they would show 8 6 5 3 7 4 2 1 (or 8 7 4 2 6 5 3 1); some older commits are shown before newer ones in order to avoid showing the commits from two parallel development track mixed together."),
					new GitCommandOption("--unpacked", "--unpacked", @"Only useful with --objects; print the object IDs that are not in packs."),
					new GitCommandOption("--until", "--until=<date>", @"Show commits older than a specific date."),
					new GitCommandOption("--use-bitmap-index", "--use-bitmap-index", @"Try to speed up the traversal using the pack bitmap index (if one is available). Note that when traversing with --objects, trees and blobs will not have their associated path printed."),
					new GitCommandOption("--walk-reflogs", "--walk-reflogs", @"Instead of walking the commit ancestry chain, walk reflog entries from the most recent one to older ones. When this option is used you cannot specify commits to exclude (that is, ^commit, commit1..commit2, and commit1...commit2 notations cannot be used).  With --pretty format other than oneline and reference (for obvious reasons), this causes the output to have two extra lines of information taken from the reflog.  The reflog designator in the output may be shown as ref@{Nth} (where Nth is the reverse-chronological index in the reflog) or as ref@{timestamp} (with the timestamp for that entry), depending on a few rules:       If the starting point is specified as ref@{Nth}, show the index format.   If the starting point was specified as ref@{now}, show the timestamp format.   If neither was used, but --date was given on the command line, show the timestamp in the format requested by --date.   Otherwise, show the index format.       Under --pretty=oneline, the commit message is prefixed with this information on the same line. This option cannot be combined with --reverse. See also git-reflog.   Under --pretty=reference, this information will not be shown at all."),
					new GitCommandOption("-<number>", "-<number>", @"Limit the number of commits to output."),
					new GitCommandOption("-E", "-E", @"Consider the limiting patterns to be extended regular expressions instead of the default basic regular expressions."),
					new GitCommandOption("-F", "-F", @"Consider the limiting patterns to be fixed strings (don’t interpret pattern as a regular expression)."),
					new GitCommandOption("-g", "-g", @"Instead of walking the commit ancestry chain, walk reflog entries from the most recent one to older ones. When this option is used you cannot specify commits to exclude (that is, ^commit, commit1..commit2, and commit1...commit2 notations cannot be used).  With --pretty format other than oneline and reference (for obvious reasons), this causes the output to have two extra lines of information taken from the reflog.  The reflog designator in the output may be shown as ref@{Nth} (where Nth is the reverse-chronological index in the reflog) or as ref@{timestamp} (with the timestamp for that entry), depending on a few rules:       If the starting point is specified as ref@{Nth}, show the index format.   If the starting point was specified as ref@{now}, show the timestamp format.   If neither was used, but --date was given on the command line, show the timestamp in the format requested by --date.   Otherwise, show the index format.       Under --pretty=oneline, the commit message is prefixed with this information on the same line. This option cannot be combined with --reverse. See also git-reflog.   Under --pretty=reference, this information will not be shown at all."),
					new GitCommandOption("-i", "-i", @"Match the regular expression limiting patterns without regard to letter case."),
					new GitCommandOption("-n", "-n <number>", @"Limit the number of commits to output."),
					new GitCommandOption("-P", "-P", @"Consider the limiting patterns to be Perl-compatible regular expressions.  Support for these types of regular expressions is an optional compile-time dependency. If Git wasn’t compiled with support for them providing this option will cause it to die."),
					new GitCommandOption("Default", "Default mode", @"Simplifies the history to the simplest history explaining the final state of the tree. Simplest because it prunes some side branches if the end result is the same (i.e. merging branches with the same content)"),
					new GitCommandOption("Default", "Default mode", @"Commits are included if they are not TREESAME to any parent (though this can be changed, see --sparse below).  If the commit was a merge, and it was TREESAME to one parent, follow only that parent.  (Even if there are several TREESAME parents, follow only one of them.)  Otherwise, follow all parents.  This results in:              .-A---N---O          /     /   /         I---------D    Note how the rule to only follow the TREESAME parent, if one is available, removed B from consideration entirely.  C was considered via N, but is TREESAME.  Root commits are compared to an empty tree, so I is !TREESAME.   Parent/child relations are only visible with --parents, but that does not affect the commits selected in default mode, so we have shown the parent lines."),
				}, 
	"rev-parse" => new GitCommandOption[] {
					new GitCommandOption("<args>…​", "<args>…​", @"Flags and parameters to be parsed."),
					new GitCommandOption("--abbrev-ref[", "--abbrev-ref[=(strict|loose)]", @"A non-ambiguous short name of the objects name. The option core.warnAmbiguousRefs is used to select the strict abbreviation mode."),
					new GitCommandOption("--absolute-git-dir", "--absolute-git-dir", @"Like --git-dir, but its output is always the canonicalized absolute path."),
					new GitCommandOption("--after", "--after=datestring", @"Parse the date string, and output the corresponding --max-age= parameter for git rev-list."),
					new GitCommandOption("--all", "--all", @"Show all refs found in refs/."),
					new GitCommandOption("--before", "--before=datestring", @"Parse the date string, and output the corresponding --min-age= parameter for git rev-list."),
					new GitCommandOption("--branches[", "--branches[=pattern]", @"Show all branches, tags, or remote-tracking branches, respectively (i.e., refs found in refs/heads, refs/tags, or refs/remotes, respectively).  If a pattern is given, only refs matching the given shell glob are shown.  If the pattern does not contain a globbing character (?, *, or [), it is turned into a prefix match by appending /*."),
					new GitCommandOption("--default", "--default <arg>", @"If there is no parameter given by the user, use <arg> instead."),
					new GitCommandOption("--disambiguate", "--disambiguate=<prefix>", @"Show every object whose name begins with the given prefix. The <prefix> must be at least 4 hexadecimal digits long to avoid listing each and every object in the repository by mistake."),
					new GitCommandOption("--exclude", "--exclude=<glob-pattern>", @"Do not include refs matching <glob-pattern> that the next --all, --branches, --tags, --remotes, or --glob would otherwise consider. Repetitions of this option accumulate exclusion patterns up to the next --all, --branches, --tags, --remotes, or --glob option (other options or arguments do not clear accumulated patterns).  The patterns given should not begin with refs/heads, refs/tags, or refs/remotes when applied to --branches, --tags, or --remotes, respectively, and they must begin with refs/ when applied to --glob or --all. If a trailing /* is intended, it must be given explicitly."),
					new GitCommandOption("--flags", "--flags", @"Do not output non-flag parameters."),
					new GitCommandOption("--git-common-dir", "--git-common-dir", @"Show $GIT_COMMON_DIR if defined, else $GIT_DIR."),
					new GitCommandOption("--git-dir", "--git-dir", @"Show $GIT_DIR if defined. Otherwise show the path to the .git directory. The path shown, when relative, is relative to the current working directory.  If $GIT_DIR is not defined and the current directory is not detected to lie in a Git repository or work tree print a message to stderr and exit with nonzero status."),
					new GitCommandOption("--git-path", "--git-path <path>", @"Resolve ""$GIT_DIR/<path>"" and takes other path relocation variables such as $GIT_OBJECT_DIRECTORY, $GIT_INDEX_FILE…​ into account. For example, if $GIT_OBJECT_DIRECTORY is set to /foo/bar then ""git rev-parse --git-path objects/abc"" returns /foo/bar/abc."),
					new GitCommandOption("--glob", "--glob=pattern", @"Show all refs matching the shell glob pattern pattern. If the pattern does not start with refs/, this is automatically prepended.  If the pattern does not contain a globbing character (?, *, or [), it is turned into a prefix match by appending /*."),
					new GitCommandOption("--is-bare-repository", "--is-bare-repository", @"When the repository is bare print ""true"", otherwise ""false""."),
					new GitCommandOption("--is-inside-git-dir", "--is-inside-git-dir", @"When the current working directory is below the repository directory print ""true"", otherwise ""false""."),
					new GitCommandOption("--is-inside-work-tree", "--is-inside-work-tree", @"When the current working directory is inside the work tree of the repository print ""true"", otherwise ""false""."),
					new GitCommandOption("--is-shallow-repository", "--is-shallow-repository", @"When the repository is shallow print ""true"", otherwise ""false""."),
					new GitCommandOption("--keep-dashdash", "--keep-dashdash", @"Only meaningful in --parseopt mode. Tells the option parser to echo out the first -- met instead of skipping it."),
					new GitCommandOption("--local-env-vars", "--local-env-vars", @"List the GIT_* environment variables that are local to the repository (e.g. GIT_DIR or GIT_WORK_TREE, but not GIT_EDITOR). Only the names of the variables are listed, not their value, even if they are set."),
					new GitCommandOption("--no-flags", "--no-flags", @"Do not output flag parameters."),
					new GitCommandOption("--no-revs", "--no-revs", @"Do not output flags and parameters meant for git rev-list command."),
					new GitCommandOption("--not", "--not", @"When showing object names, prefix them with ^ and strip ^ prefix from the object names that already have one."),
					new GitCommandOption("--parseopt", "--parseopt", @"Use git rev-parse in option parsing mode (see PARSEOPT section below)."),
					new GitCommandOption("--path-format", "--path-format=(absolute|relative)", @"Controls the behavior of certain other options. If specified as absolute, the paths printed by those options will be absolute and canonical. If specified as relative, the paths will be relative to the current working directory if that is possible.  The default is option specific.  This option may be specified multiple times and affects only the arguments that follow it on the command line, either to the end of the command line or the next instance of this option."),
					new GitCommandOption("--prefix", "--prefix <arg>", @"Behave as if git rev-parse was invoked from the <arg> subdirectory of the working tree.  Any relative filenames are resolved as if they are prefixed by <arg> and will be printed in that form.  This can be used to convert arguments to a command run in a subdirectory so that they can still be used after moving to the top-level of the repository.  For example:    prefix=$(git rev-parse --show-prefix) cd ""$(git rev-parse --show-toplevel)"" # rev-parse provides the -- needed for 'set' eval ""set $(git rev-parse --sq --prefix ""$prefix"" -- ""$@"")"""),
					new GitCommandOption("--quiet", "--quiet", @"Only meaningful in --verify mode. Do not output an error message if the first argument is not a valid object name; instead exit with non-zero status silently. SHA-1s for valid object names are printed to stdout on success."),
					new GitCommandOption("--remotes[", "--remotes[=pattern]", @"Show all branches, tags, or remote-tracking branches, respectively (i.e., refs found in refs/heads, refs/tags, or refs/remotes, respectively).  If a pattern is given, only refs matching the given shell glob are shown.  If the pattern does not contain a globbing character (?, *, or [), it is turned into a prefix match by appending /*."),
					new GitCommandOption("--resolve-git-dir", "--resolve-git-dir <path>", @"Check if <path> is a valid repository or a gitfile that points at a valid repository, and print the location of the repository.  If <path> is a gitfile then the resolved path to the real repository is printed."),
					new GitCommandOption("--revs-only", "--revs-only", @"Do not output flags and parameters not meant for git rev-list command."),
					new GitCommandOption("--shared-index-path", "--shared-index-path", @"Show the path to the shared index file in split index mode, or empty if not in split-index mode."),
					new GitCommandOption("--short[", "--short[=length]", @"Same as --verify but shortens the object name to a unique prefix with at least length characters. The minimum length is 4, the default is the effective value of the core.abbrev configuration variable (see git-config)."),
					new GitCommandOption("--show-cdup", "--show-cdup", @"When the command is invoked from a subdirectory, show the path of the top-level directory relative to the current directory (typically a sequence of ""../"", or an empty string)."),
					new GitCommandOption("--show-object-format[", "--show-object-format[=(storage|input|output)]", @"Show the object format (hash algorithm) used for the repository for storage inside the .git directory, input, or output. For input, multiple algorithms may be printed, space-separated. If not specified, the default is ""storage""."),
					new GitCommandOption("--show-prefix", "--show-prefix", @"When the command is invoked from a subdirectory, show the path of the current directory relative to the top-level directory."),
					new GitCommandOption("--show-superproject-working-tree", "--show-superproject-working-tree", @"Show the absolute path of the root of the superproject’s working tree (if exists) that uses the current repository as its submodule.  Outputs nothing if the current repository is not used as a submodule by any project."),
					new GitCommandOption("--show-toplevel", "--show-toplevel", @"Show the (by default, absolute) path of the top-level directory of the working tree. If there is no working tree, report an error."),
					new GitCommandOption("--since", "--since=datestring", @"Parse the date string, and output the corresponding --max-age= parameter for git rev-list."),
					new GitCommandOption("--sq", "--sq", @"Usually the output is made one line per flag and parameter.  This option makes output a single line, properly quoted for consumption by shell.  Useful when you expect your parameter to contain whitespaces and newlines (e.g. when using pickaxe -S with git diff-*). In contrast to the --sq-quote option, the command input is still interpreted as usual."),
					new GitCommandOption("--sq-quote", "--sq-quote", @"Use git rev-parse in shell quoting mode (see SQ-QUOTE section below). In contrast to the --sq option below, this mode does only quoting. Nothing else is done to command input."),
					new GitCommandOption("--stop-at-non-option", "--stop-at-non-option", @"Only meaningful in --parseopt mode.  Lets the option parser stop at the first non-option argument.  This can be used to parse sub-commands that take options themselves."),
					new GitCommandOption("--stuck-long", "--stuck-long", @"Only meaningful in --parseopt mode. Output the options in their long form if available, and with their arguments stuck."),
					new GitCommandOption("--symbolic", "--symbolic", @"Usually the object names are output in SHA-1 form (with possible ^ prefix); this option makes them output in a form as close to the original input as possible."),
					new GitCommandOption("--symbolic-full-name", "--symbolic-full-name", @"This is similar to --symbolic, but it omits input that are not refs (i.e. branch or tag names; or more explicitly disambiguating ""heads/master"" form, when you want to name the ""master"" branch when there is an unfortunately named tag ""master""), and show them as full refnames (e.g. ""refs/heads/master"")."),
					new GitCommandOption("--tags[", "--tags[=pattern]", @"Show all branches, tags, or remote-tracking branches, respectively (i.e., refs found in refs/heads, refs/tags, or refs/remotes, respectively).  If a pattern is given, only refs matching the given shell glob are shown.  If the pattern does not contain a globbing character (?, *, or [), it is turned into a prefix match by appending /*."),
					new GitCommandOption("--until", "--until=datestring", @"Parse the date string, and output the corresponding --min-age= parameter for git rev-list."),
					new GitCommandOption("--verify", "--verify", @"Verify that exactly one parameter is provided, and that it can be turned into a raw 20-byte SHA-1 that can be used to access the object database. If so, emit it to the standard output; otherwise, error out.  If you want to make sure that the output actually names an object in your object database and/or can be used as a specific type of object you require, you can add the ^{type} peeling operator to the parameter. For example, git rev-parse ""$VAR^{commit}"" will make sure $VAR names an existing object that is a commit-ish (i.e. a commit, or an annotated tag that points at a commit).  To make sure that $VAR names an existing object of any type, git rev-parse ""$VAR^{object}"" can be used.   Note that if you are verifying a name from an untrusted source, it is wise to use --end-of-options so that the name argument is not mistaken for another option."),
					new GitCommandOption("-q", "-q", @"Only meaningful in --verify mode. Do not output an error message if the first argument is not a valid object name; instead exit with non-zero status silently. SHA-1s for valid object names are printed to stdout on success."),
				}, 
	"revert" => new GitCommandOption[] {
					new GitCommandOption("<commit>…​", "<commit>…​", @"Commits to revert. For a more complete list of ways to spell commit names, see gitrevisions. Sets of commits can also be given but no traversal is done by default, see git-rev-list and its --no-walk option."),
					new GitCommandOption("--cleanup", "--cleanup=<mode>", @"This option determines how the commit message will be cleaned up before being passed on to the commit machinery. See git-commit for more details. In particular, if the <mode> is given a value of scissors, scissors will be appended to MERGE_MSG before being passed on in the case of a conflict."),
					new GitCommandOption("--edit", "--edit", @"With this option, git revert will let you edit the commit message prior to committing the revert. This is the default if you run the command from a terminal."),
					new GitCommandOption("--gpg-sign[", "--gpg-sign[=<keyid>]", @"GPG-sign commits. The keyid argument is optional and defaults to the committer identity; if specified, it must be stuck to the option without a space. --no-gpg-sign is useful to countermand both commit.gpgSign configuration variable, and earlier --gpg-sign."),
					new GitCommandOption("--mainline", "--mainline parent-number", @"Usually you cannot revert a merge because you do not know which side of the merge should be considered the mainline.  This option specifies the parent number (starting from 1) of the mainline and allows revert to reverse the change relative to the specified parent.  Reverting a merge commit declares that you will never want the tree changes brought in by the merge.  As a result, later merges will only bring in tree changes introduced by commits that are not ancestors of the previously reverted merge.  This may or may not be what you want.   See the revert-a-faulty-merge How-To for more details."),
					new GitCommandOption("--no-commit", "--no-commit", @"Usually the command automatically creates some commits with commit log messages stating which commits were reverted.  This flag applies the changes necessary to revert the named commits to your working tree and the index, but does not make the commits.  In addition, when this option is used, your index does not have to match the HEAD commit.  The revert is done against the beginning state of your index.  This is useful when reverting more than one commits' effect to your index in a row."),
					new GitCommandOption("--no-edit", "--no-edit", @"With this option, git revert will not start the commit message editor."),
					new GitCommandOption("--no-gpg-sign", "--no-gpg-sign", @"GPG-sign commits. The keyid argument is optional and defaults to the committer identity; if specified, it must be stuck to the option without a space. --no-gpg-sign is useful to countermand both commit.gpgSign configuration variable, and earlier --gpg-sign."),
					new GitCommandOption("--no-rerere-autoupdate", "--no-rerere-autoupdate", @"Allow the rerere mechanism to update the index with the result of auto-conflict resolution if possible."),
					new GitCommandOption("--rerere-autoupdate", "--rerere-autoupdate", @"Allow the rerere mechanism to update the index with the result of auto-conflict resolution if possible."),
					new GitCommandOption("--signoff", "--signoff", @"Add a Signed-off-by trailer at the end of the commit message. See the signoff option in git-commit for more information."),
					new GitCommandOption("--strategy", "--strategy=<strategy>", @"Use the given merge strategy.  Should only be used once. See the MERGE STRATEGIES section in git-merge for details."),
					new GitCommandOption("--strategy-option", "--strategy-option=<option>", @"Pass the merge strategy-specific option through to the merge strategy.  See git-merge for details."),
					new GitCommandOption("-e", "-e", @"With this option, git revert will let you edit the commit message prior to committing the revert. This is the default if you run the command from a terminal."),
					new GitCommandOption("-m", "-m parent-number", @"Usually you cannot revert a merge because you do not know which side of the merge should be considered the mainline.  This option specifies the parent number (starting from 1) of the mainline and allows revert to reverse the change relative to the specified parent.  Reverting a merge commit declares that you will never want the tree changes brought in by the merge.  As a result, later merges will only bring in tree changes introduced by commits that are not ancestors of the previously reverted merge.  This may or may not be what you want.   See the revert-a-faulty-merge How-To for more details."),
					new GitCommandOption("-n", "-n", @"Usually the command automatically creates some commits with commit log messages stating which commits were reverted.  This flag applies the changes necessary to revert the named commits to your working tree and the index, but does not make the commits.  In addition, when this option is used, your index does not have to match the HEAD commit.  The revert is done against the beginning state of your index.  This is useful when reverting more than one commits' effect to your index in a row."),
					new GitCommandOption("-s", "-s", @"Add a Signed-off-by trailer at the end of the commit message. See the signoff option in git-commit for more information."),
					new GitCommandOption("-S[<keyid>]", "-S[<keyid>]", @"GPG-sign commits. The keyid argument is optional and defaults to the committer identity; if specified, it must be stuck to the option without a space. --no-gpg-sign is useful to countermand both commit.gpgSign configuration variable, and earlier --gpg-sign."),
					new GitCommandOption("-X<option>", "-X<option>", @"Pass the merge strategy-specific option through to the merge strategy.  See git-merge for details."),
				}, 
	"rm" => new GitCommandOption[] {
					new GitCommandOption("<pathspec>…​", "<pathspec>…​", @"Files to remove.  A leading directory name (e.g. dir to remove dir/file1 and dir/file2) can be given to remove all files in the directory, and recursively all sub-directories, but this requires the -r option to be explicitly given.  The command removes only the paths that are known to Git.   File globbing matches across directory boundaries.  Thus, given two directories d and d2, there is a difference between using git rm 'd*' and git rm 'd/*', as the former will also remove all of directory d2.   For more details, see the pathspec entry in gitglossary."),
					new GitCommandOption("--", "--", @"This option can be used to separate command-line options from the list of files, (useful when filenames might be mistaken for command-line options)."),
					new GitCommandOption("--cached", "--cached", @"Use this option to unstage and remove paths only from the index. Working tree files, whether modified or not, will be left alone."),
					new GitCommandOption("--dry-run", "--dry-run", @"Don’t actually remove any file(s).  Instead, just show if they exist in the index and would otherwise be removed by the command."),
					new GitCommandOption("--force", "--force", @"Override the up-to-date check."),
					new GitCommandOption("--ignore-unmatch", "--ignore-unmatch", @"Exit with a zero status even if no files matched."),
					new GitCommandOption("--pathspec-file-nul", "--pathspec-file-nul", @"Only meaningful with --pathspec-from-file. Pathspec elements are separated with NUL character and all other characters are taken literally (including newlines and quotes)."),
					new GitCommandOption("--pathspec-from-file", "--pathspec-from-file=<file>", @"Pathspec is passed in <file> instead of commandline args. If <file> is exactly - then standard input is used. Pathspec elements are separated by LF or CR/LF. Pathspec elements can be quoted as explained for the configuration variable core.quotePath (see git-config). See also --pathspec-file-nul and global --literal-pathspecs."),
					new GitCommandOption("--quiet", "--quiet", @"git rm normally outputs one line (in the form of an rm command) for each file removed. This option suppresses that output."),
					new GitCommandOption("--sparse", "--sparse", @"Allow updating index entries outside of the sparse-checkout cone. Normally, git rm refuses to update index entries whose paths do not fit within the sparse-checkout cone. See git-sparse-checkout for more."),
					new GitCommandOption("-f", "-f", @"Override the up-to-date check."),
					new GitCommandOption("-n", "-n", @"Don’t actually remove any file(s).  Instead, just show if they exist in the index and would otherwise be removed by the command."),
					new GitCommandOption("-q", "-q", @"git rm normally outputs one line (in the form of an rm command) for each file removed. This option suppresses that output."),
					new GitCommandOption("-r", "-r", @"Allow recursive removal when a leading directory name is given."),
				}, 
	"send-email" => new GitCommandOption[] {
					new GitCommandOption("--[no-]cc-cover", "--[no-]cc-cover", @"If this is set, emails found in Cc: headers in the first patch of the series (typically the cover letter) are added to the cc list for each email set. Default is the value of sendemail.cccover configuration value; if that is unspecified, default to --no-cc-cover."),
					new GitCommandOption("--[no-]chain-reply-to", "--[no-]chain-reply-to", @"If this is set, each email will be sent as a reply to the previous email sent.  If disabled with ""--no-chain-reply-to"", all emails after the first will be sent as replies to the first email sent.  When using this, it is recommended that the first file given be an overview of the entire patch series. Disabled by default, but the sendemail.chainReplyTo configuration variable can be used to enable it."),
					new GitCommandOption("--[no-]format-patch", "--[no-]format-patch", @"When an argument may be understood either as a reference or as a file name, choose to understand it as a format-patch argument (--format-patch) or as a file name (--no-format-patch). By default, when such a conflict occurs, git send-email will fail."),
					new GitCommandOption("--[no-]signed-off-by-cc", "--[no-]signed-off-by-cc", @"If this is set, add emails found in the Signed-off-by trailer or Cc: lines to the cc list. Default is the value of sendemail.signedoffbycc configuration value; if that is unspecified, default to --signed-off-by-cc."),
					new GitCommandOption("--[no-]suppress-from", "--[no-]suppress-from", @"If this is set, do not add the From: address to the cc: list. Default is the value of sendemail.suppressFrom configuration value; if that is unspecified, default to --no-suppress-from."),
					new GitCommandOption("--[no-]thread", "--[no-]thread", @"If this is set, the In-Reply-To and References headers will be added to each email sent.  Whether each mail refers to the previous email (deep threading per git format-patch wording) or to the first email (shallow threading) is governed by ""--[no-]chain-reply-to"".  If disabled with ""--no-thread"", those headers will not be added (unless specified with --in-reply-to).  Default is the value of the sendemail.thread configuration value; if that is unspecified, default to --thread.   It is up to the user to ensure that no In-Reply-To header already exists when git send-email is asked to add it (especially note that git format-patch can be configured to do the threading itself). Failure to do so may not produce the expected result in the recipient’s MUA."),
					new GitCommandOption("--[no-]to-cover", "--[no-]to-cover", @"If this is set, emails found in To: headers in the first patch of the series (typically the cover letter) are added to the to list for each email set. Default is the value of sendemail.tocover configuration value; if that is unspecified, default to --no-to-cover."),
					new GitCommandOption("--[no-]validate", "--[no-]validate", @"Perform sanity checks on patches. Currently, validation means the following:      Invoke the sendemail-validate hook if present (see githooks).   Warn of patches that contain lines longer than 998 characters unless a suitable transfer encoding (auto, base64, or quoted-printable) is used; this is due to SMTP limits as described by http://www.ietf.org/rfc/rfc5322.txt.       Default is the value of sendemail.validate; if this is not set, default to --validate."),
					new GitCommandOption("--8bit-encoding", "--8bit-encoding=<encoding>", @"When encountering a non-ASCII message or subject that does not declare its encoding, add headers/quoting to indicate it is encoded in <encoding>.  Default is the value of the sendemail.assume8bitEncoding; if that is unspecified, this will be prompted for if any non-ASCII files are encountered.  Note that no attempts whatsoever are made to validate the encoding."),
					new GitCommandOption("--annotate", "--annotate", @"Review and edit each patch you’re about to send. Default is the value of sendemail.annotate. See the CONFIGURATION section for sendemail.multiEdit."),
					new GitCommandOption("--batch-size", "--batch-size=<num>", @"Some email servers (e.g. smtp.163.com) limit the number emails to be sent per session (connection) and this will lead to a failure when sending many messages.  With this option, send-email will disconnect after sending $<num> messages and wait for a few seconds (see --relogin-delay) and reconnect, to work around such a limit.  You may want to use some form of credential helper to avoid having to retype your password every time this happens.  Defaults to the sendemail.smtpBatchSize configuration variable."),
					new GitCommandOption("--bcc", "--bcc=<address>,…​", @"Specify a ""Bcc:"" value for each email. Default is the value of sendemail.bcc.  This option may be specified multiple times."),
					new GitCommandOption("--cc", "--cc=<address>,…​", @"Specify a starting ""Cc:"" value for each email. Default is the value of sendemail.cc.  This option may be specified multiple times."),
					new GitCommandOption("--cc-cmd", "--cc-cmd=<command>", @"Specify a command to execute once per patch file which should generate patch file specific ""Cc:"" entries. Output of this command must be single email address per line. Default is the value of sendemail.ccCmd configuration value."),
					new GitCommandOption("--compose", "--compose", @"Invoke a text editor (see GIT_EDITOR in git-var) to edit an introductory message for the patch series.  When --compose is used, git send-email will use the From, Subject, and In-Reply-To headers specified in the message. If the body of the message (what you type after the headers and a blank line) only contains blank (or Git: prefixed) lines, the summary won’t be sent, but From, Subject, and In-Reply-To headers will be used unless they are removed.   Missing From or In-Reply-To headers will be prompted for.   See the CONFIGURATION section for sendemail.multiEdit."),
					new GitCommandOption("--compose-encoding", "--compose-encoding=<encoding>", @"Specify encoding of compose message. Default is the value of the sendemail.composeencoding; if that is unspecified, UTF-8 is assumed."),
					new GitCommandOption("--confirm", "--confirm=<mode>", @"Confirm just before sending:      always will always confirm before sending   never will never confirm before sending   cc will confirm before sending when send-email has automatically added addresses from the patch to the Cc list   compose will confirm before sending the first message when using --compose.   auto is equivalent to cc + compose       Default is the value of sendemail.confirm configuration value; if that is unspecified, default to auto unless any of the suppress options have been specified, in which case default to compose."),
					new GitCommandOption("--dry-run", "--dry-run", @"Do everything except actually send the emails."),
					new GitCommandOption("--dump-aliases", "--dump-aliases", @"Instead of the normal operation, dump the shorthand alias names from the configured alias file(s), one per line in alphabetical order. Note, this only includes the alias name and not its expanded email addresses. See sendemail.aliasesfile for more information about aliases."),
					new GitCommandOption("--envelope-sender", "--envelope-sender=<address>", @"Specify the envelope sender used to send the emails. This is useful if your default address is not the address that is subscribed to a list. In order to use the From address, set the value to ""auto"". If you use the sendmail binary, you must have suitable privileges for the -f parameter.  Default is the value of the sendemail.envelopeSender configuration variable; if that is unspecified, choosing the envelope sender is left to your MTA."),
					new GitCommandOption("--force", "--force", @"Send emails even if safety checks would prevent it."),
					new GitCommandOption("--from", "--from=<address>", @"Specify the sender of the emails.  If not specified on the command line, the value of the sendemail.from configuration option is used.  If neither the command-line option nor sendemail.from are set, then the user will be prompted for the value.  The default for the prompt will be the value of GIT_AUTHOR_IDENT, or GIT_COMMITTER_IDENT if that is not set, as returned by ""git var -l""."),
					new GitCommandOption("--identity", "--identity=<identity>", @"A configuration identity. When given, causes values in the sendemail.<identity> subsection to take precedence over values in the sendemail section. The default identity is the value of sendemail.identity."),
					new GitCommandOption("--in-reply-to", "--in-reply-to=<identifier>", @"Make the first mail (or all the mails with --no-thread) appear as a reply to the given Message-Id, which avoids breaking threads to provide a new patch series. The second and subsequent emails will be sent as replies according to the --[no-]chain-reply-to setting.  So for example when --thread and --no-chain-reply-to are specified, the second and subsequent patches will be replies to the first one like in the illustration below where [PATCH v2 0/3] is in reply to [PATCH 0/2]:    [PATCH 0/2] Here is what I did...   [PATCH 1/2] Clean up and tests   [PATCH 2/2] Implementation   [PATCH v2 0/3] Here is a reroll     [PATCH v2 1/3] Clean up     [PATCH v2 2/3] New tests     [PATCH v2 3/3] Implementation    Only necessary if --compose is also set.  If --compose is not set, this will be prompted for."),
					new GitCommandOption("--no-[to|cc|bcc]", "--no-[to|cc|bcc]", @"Clears any list of ""To:"", ""Cc:"", ""Bcc:"" addresses previously set via config."),
					new GitCommandOption("--no-identity", "--no-identity", @"Clears the previously read value of sendemail.identity set via config, if any."),
					new GitCommandOption("--no-smtp-auth", "--no-smtp-auth", @"Disable SMTP authentication. Short hand for --smtp-auth=none"),
					new GitCommandOption("--no-xmailer", "--no-xmailer", @"Add (or prevent adding) the ""X-Mailer:"" header.  By default, the header is added, but it can be turned off by setting the sendemail.xmailer configuration variable to false."),
					new GitCommandOption("--quiet", "--quiet", @"Make git-send-email less verbose.  One line per email should be all that is output."),
					new GitCommandOption("--relogin-delay", "--relogin-delay=<int>", @"Waiting $<int> seconds before reconnecting to SMTP server. Used together with --batch-size option.  Defaults to the sendemail.smtpReloginDelay configuration variable."),
					new GitCommandOption("--reply-to", "--reply-to=<address>", @"Specify the address where replies from recipients should go to. Use this if replies to messages should go to another address than what is specified with the --from parameter."),
					new GitCommandOption("--sendmail-cmd", "--sendmail-cmd=<command>", @"Specify a command to run to send the email. The command should be sendmail-like; specifically, it must support the -i option. The command will be executed in the shell if necessary.  Default is the value of sendemail.sendmailcmd.  If unspecified, and if --smtp-server is also unspecified, git-send-email will search for sendmail in /usr/sbin, /usr/lib and $PATH."),
					new GitCommandOption("--smtp-auth", "--smtp-auth=<mechanisms>", @"Whitespace-separated list of allowed SMTP-AUTH mechanisms. This setting forces using only the listed mechanisms. Example:   $ git send-email --smtp-auth=""PLAIN LOGIN GSSAPI"" ...    If at least one of the specified mechanisms matches the ones advertised by the SMTP server and if it is supported by the utilized SASL library, the mechanism is used for authentication. If neither sendemail.smtpAuth nor --smtp-auth is specified, all mechanisms supported by the SASL library can be used. The special value none maybe specified to completely disable authentication independently of --smtp-user"),
					new GitCommandOption("--smtp-debug", "--smtp-debug=0|1", @"Enable  or disable  debug output. If enabled, SMTP commands and replies will be printed. Useful to debug TLS connection and authentication problems."),
					new GitCommandOption("--smtp-domain", "--smtp-domain=<FQDN>", @"Specifies the Fully Qualified Domain Name (FQDN) used in the HELO/EHLO command to the SMTP server.  Some servers require the FQDN to match your IP address.  If not set, git send-email attempts to determine your FQDN automatically.  Default is the value of sendemail.smtpDomain."),
					new GitCommandOption("--smtp-encryption", "--smtp-encryption=<encryption>", @"Specify the encryption to use, either ssl or tls.  Any other value reverts to plain SMTP.  Default is the value of sendemail.smtpEncryption."),
					new GitCommandOption("--smtp-pass[", "--smtp-pass[=<password>]", @"Password for SMTP-AUTH. The argument is optional: If no argument is specified, then the empty string is used as the password. Default is the value of sendemail.smtpPass, however --smtp-pass always overrides this value.  Furthermore, passwords need not be specified in configuration files or on the command line. If a username has been specified (with --smtp-user or a sendemail.smtpUser), but no password has been specified (with --smtp-pass or sendemail.smtpPass), then a password is obtained using git-credential."),
					new GitCommandOption("--smtp-server", "--smtp-server=<host>", @"If set, specifies the outgoing SMTP server to use (e.g. smtp.example.com or a raw IP address).  If unspecified, and if --sendmail-cmd is also unspecified, the default is to search for sendmail in /usr/sbin, /usr/lib and $PATH if such a program is available, falling back to localhost otherwise.  For backward compatibility, this option can also specify a full pathname of a sendmail-like program instead; the program must support the -i option.  This method does not support passing arguments or using plain command names.  For those use cases, consider using --sendmail-cmd instead."),
					new GitCommandOption("--smtp-server-option", "--smtp-server-option=<option>", @"If set, specifies the outgoing SMTP server option to use. Default value can be specified by the sendemail.smtpServerOption configuration option.  The --smtp-server-option option must be repeated for each option you want to pass to the server. Likewise, different lines in the configuration files must be used for each option."),
					new GitCommandOption("--smtp-server-port", "--smtp-server-port=<port>", @"Specifies a port different from the default port (SMTP servers typically listen to smtp port 25, but may also listen to submission port 587, or the common SSL smtp port 465); symbolic port names (e.g. ""submission"" instead of 587) are also accepted. The port can also be set with the sendemail.smtpServerPort configuration variable."),
					new GitCommandOption("--smtp-ssl", "--smtp-ssl", @"Legacy alias for --smtp-encryption ssl."),
					new GitCommandOption("--smtp-ssl-cert-path", "--smtp-ssl-cert-path", @"Path to a store of trusted CA certificates for SMTP SSL/TLS certificate validation (either a directory that has been processed by c_rehash, or a single file containing one or more PEM format certificates concatenated together: see verify -CAfile and -CApath for more information on these). Set it to an empty string to disable certificate verification. Defaults to the value of the sendemail.smtpsslcertpath configuration variable, if set, or the backing SSL library’s compiled-in default otherwise (which should be the best choice on most platforms)."),
					new GitCommandOption("--smtp-user", "--smtp-user=<user>", @"Username for SMTP-AUTH. Default is the value of sendemail.smtpUser; if a username is not specified (with --smtp-user or sendemail.smtpUser), then authentication is not attempted."),
					new GitCommandOption("--subject", "--subject=<string>", @"Specify the initial subject of the email thread. Only necessary if --compose is also set.  If --compose is not set, this will be prompted for."),
					new GitCommandOption("--suppress-cc", "--suppress-cc=<category>", @"Specify an additional category of recipients to suppress the auto-cc of:      author will avoid including the patch author.   self will avoid including the sender.   cc will avoid including anyone mentioned in Cc lines in the patch header except for self (use self for that).   bodycc will avoid including anyone mentioned in Cc lines in the patch body (commit message) except for self (use self for that).   sob will avoid including anyone mentioned in the Signed-off-by trailers except for self (use self for that).   misc-by will avoid including anyone mentioned in Acked-by, Reviewed-by, Tested-by and other ""-by"" lines in the patch body, except Signed-off-by (use sob for that).   cccmd will avoid running the --cc-cmd.   body is equivalent to sob + bodycc + misc-by.   all will suppress all auto cc values.       Default is the value of sendemail.suppresscc configuration value; if that is unspecified, default to self if --suppress-from is specified, as well as body if --no-signed-off-cc is specified."),
					new GitCommandOption("--to", "--to=<address>,…​", @"Specify the primary recipient of the emails generated. Generally, this will be the upstream maintainer of the project involved. Default is the value of the sendemail.to configuration value; if that is unspecified, and --to-cmd is not specified, this will be prompted for.  This option may be specified multiple times."),
					new GitCommandOption("--to-cmd", "--to-cmd=<command>", @"Specify a command to execute once per patch file which should generate patch file specific ""To:"" entries. Output of this command must be single email address per line. Default is the value of sendemail.tocmd configuration value."),
					new GitCommandOption("--transfer-encoding", "--transfer-encoding=(7bit|8bit|quoted-printable|base64|auto)", @"Specify the transfer encoding to be used to send the message over SMTP. 7bit will fail upon encountering a non-ASCII message.  quoted-printable can be useful when the repository contains files that contain carriage returns, but makes the raw patch email file (as saved from a MUA) much harder to inspect manually.  base64 is even more fool proof, but also even more opaque.  auto will use 8bit when possible, and quoted-printable otherwise.  Default is the value of the sendemail.transferEncoding configuration value; if that is unspecified, default to auto."),
					new GitCommandOption("--xmailer", "--xmailer", @"Add (or prevent adding) the ""X-Mailer:"" header.  By default, the header is added, but it can be turned off by setting the sendemail.xmailer configuration variable to false."),
				}, 
	"send-pack" => new GitCommandOption[] {
					new GitCommandOption("<directory>", "<directory>", @"The repository to update."),
					new GitCommandOption("<host>", "<host>", @"A remote host to house the repository.  When this part is specified, git-receive-pack is invoked via ssh."),
					new GitCommandOption("<ref>…​", "<ref>…​", @"The remote refs to update."),
					new GitCommandOption("--[no-]signed", "--[no-]signed", @"GPG-sign the push request to update refs on the receiving side, to allow it to be checked by the hooks and/or be logged.  If false or --no-signed, no signing will be attempted.  If true or --signed, the push will fail if the server does not support signed pushes.  If set to if-asked, sign if and only if the server supports signed pushes.  The push will also fail if the actual call to gpg --sign fails.  See git-receive-pack for the details on the receiving end."),
					new GitCommandOption("--all", "--all", @"Instead of explicitly specifying which refs to update, update all heads that locally exist."),
					new GitCommandOption("--atomic", "--atomic", @"Use an atomic transaction for updating the refs. If any of the refs fails to update then the entire push will fail without changing any refs."),
					new GitCommandOption("--dry-run", "--dry-run", @"Do everything except actually send the updates."),
					new GitCommandOption("--exec", "--exec=<git-receive-pack>", @"Same as --receive-pack=<git-receive-pack>."),
					new GitCommandOption("--force", "--force", @"Usually, the command refuses to update a remote ref that is not an ancestor of the local ref used to overwrite it. This flag disables the check.  What this means is that the remote repository can lose commits; use it with care."),
					new GitCommandOption("--push-option", "--push-option=<string>", @"Pass the specified string as a push option for consumption by hooks on the server side.  If the server doesn’t support push options, error out.  See git-push and githooks for details."),
					new GitCommandOption("--receive-pack", "--receive-pack=<git-receive-pack>", @"Path to the git-receive-pack program on the remote end.  Sometimes useful when pushing to a remote repository over ssh, and you do not have the program in a directory on the default $PATH."),
					new GitCommandOption("--signed", "--signed=(true|false|if-asked)", @"GPG-sign the push request to update refs on the receiving side, to allow it to be checked by the hooks and/or be logged.  If false or --no-signed, no signing will be attempted.  If true or --signed, the push will fail if the server does not support signed pushes.  If set to if-asked, sign if and only if the server supports signed pushes.  The push will also fail if the actual call to gpg --sign fails.  See git-receive-pack for the details on the receiving end."),
					new GitCommandOption("--stdin", "--stdin", @"Take the list of refs from stdin, one per line. If there are refs specified on the command line in addition to this option, then the refs from stdin are processed after those on the command line.  If --stateless-rpc is specified together with this option then the list of refs must be in packet format (pkt-line). Each ref must be in a separate packet, and the list must end with a flush packet."),
					new GitCommandOption("--thin", "--thin", @"Send a ""thin"" pack, which records objects in deltified form based on objects not included in the pack to reduce network traffic."),
					new GitCommandOption("--verbose", "--verbose", @"Run verbosely."),
				}, 
	"sh-i18n--envsubst" => new GitCommandOption[] {
				}, 
	"sh-i18n" => new GitCommandOption[] {
				}, 
	"sh-setup" => new GitCommandOption[] {
				}, 
	"shell" => new GitCommandOption[] {
				}, 
	"shortlog" => new GitCommandOption[] {
					new GitCommandOption("<paths>", "<paths>", @"Commits modifying the given <paths> are selected."),
					new GitCommandOption("<revision-range>", "<revision-range>", @"Show only commits in the specified revision range.  When no <revision-range> is specified, it defaults to HEAD (i.e. the whole history leading to the current commit).  origin..HEAD specifies all the commits reachable from the current commit (i.e. HEAD), but not from origin. For a complete list of ways to spell <revision-range>, see the ""Specifying Ranges"" section of gitrevisions."),
					new GitCommandOption("--after", "--after=<date>", @"Show commits more recent than a specific date."),
					new GitCommandOption("--all", "--all", @"Pretend as if all the refs in refs/, along with HEAD, are listed on the command line as <commit>."),
					new GitCommandOption("--all-match", "--all-match", @"Limit the commits output to ones that match all given --grep, instead of ones that match at least one."),
					new GitCommandOption("--alternate-refs", "--alternate-refs", @"Pretend as if all objects mentioned as ref tips of alternate repositories were listed on the command line. An alternate repository is any repository whose object directory is specified in objects/info/alternates.  The set of included objects may be modified by core.alternateRefsCommand, etc. See git-config."),
					new GitCommandOption("--ancestry-path", "--ancestry-path", @"When given a range of commits to display (e.g. commit1..commit2 or commit2 ^commit1), only display commits that exist directly on the ancestry chain between the commit1 and commit2, i.e. commits that are both descendants of commit1, and ancestors of commit2."),
					new GitCommandOption("--ancestry-path", "--ancestry-path", @"Limit the displayed commits to those directly on the ancestry chain between the “from” and “to” commits in the given commit range. I.e. only display commits that are ancestor of the “to” commit and descendants of the “from” commit.  As an example use case, consider the following commit history:                D---E-------F            /     \       \           B---C---G---H---I---J          /                     \         A-------K---------------L--M    A regular D..M computes the set of commits that are ancestors of M, but excludes the ones that are ancestors of D. This is useful to see what happened to the history leading to M since D, in the sense that “what does M have that did not exist in D”. The result in this example would be all the commits, except A and B (and D itself, of course).   When we want to find out what commits in M are contaminated with the bug introduced by D and need fixing, however, we might want to view only the subset of D..M that are actually descendants of D, i.e. excluding C and K. This is exactly what the --ancestry-path option does. Applied to the D..M range, it results in:                    E-------F                  \       \                   G---H---I---J                                \                                 L--M"),
					new GitCommandOption("--author", "--author=<pattern>", @"Limit the commits output to ones with author/committer header lines that match the specified pattern (regular expression).  With more than one --author=<pattern>, commits whose author matches any of the given patterns are chosen (similarly for multiple --committer=<pattern>)."),
					new GitCommandOption("--basic-regexp", "--basic-regexp", @"Consider the limiting patterns to be basic regular expressions; this is the default."),
					new GitCommandOption("--before", "--before=<date>", @"Show commits older than a specific date."),
					new GitCommandOption("--bisect", "--bisect", @"Pretend as if the bad bisection ref refs/bisect/bad was listed and as if it was followed by --not and the good bisection refs refs/bisect/good-* on the command line."),
					new GitCommandOption("--boundary", "--boundary", @"Output excluded boundary commits. Boundary commits are prefixed with -."),
					new GitCommandOption("--branches[", "--branches[=<pattern>]", @"Pretend as if all the refs in refs/heads are listed on the command line as <commit>. If <pattern> is given, limit branches to ones matching given shell glob. If pattern lacks ?, *, or [, /* at the end is implied."),
					new GitCommandOption("--cherry", "--cherry", @"A synonym for --right-only --cherry-mark --no-merges; useful to limit the output to the commits on our side and mark those that have been applied to the other side of a forked history with git log --cherry upstream...mybranch, similar to git cherry upstream mybranch."),
					new GitCommandOption("--cherry-mark", "--cherry-mark", @"Like --cherry-pick (see below) but mark equivalent commits with = rather than omitting them, and inequivalent ones with +."),
					new GitCommandOption("--cherry-pick", "--cherry-pick", @"Omit any commit that introduces the same change as another commit on the “other side” when the set of commits are limited with symmetric difference.  For example, if you have two branches, A and B, a usual way to list all commits on only one side of them is with --left-right (see the example below in the description of the --left-right option). However, it shows the commits that were cherry-picked from the other branch (for example, “3rd on b” may be cherry-picked from branch A). With this option, such pairs of commits are excluded from the output."),
					new GitCommandOption("--committer", "--committer=<pattern>", @"Limit the commits output to ones with author/committer header lines that match the specified pattern (regular expression).  With more than one --author=<pattern>, commits whose author matches any of the given patterns are chosen (similarly for multiple --committer=<pattern>)."),
					new GitCommandOption("--committer", "--committer", @"This is an alias for --group=committer."),
					new GitCommandOption("--dense", "--dense", @"Only the selected commits are shown, plus some to have a meaningful history."),
					new GitCommandOption("--dense", "--dense", @"Commits that are walked are included if they are not TREESAME to any parent."),
					new GitCommandOption("--email", "--email", @"Show the email address of each author."),
					new GitCommandOption("--exclude", "--exclude=<glob-pattern>", @"Do not include refs matching <glob-pattern> that the next --all, --branches, --tags, --remotes, or --glob would otherwise consider. Repetitions of this option accumulate exclusion patterns up to the next --all, --branches, --tags, --remotes, or --glob option (other options or arguments do not clear accumulated patterns).  The patterns given should not begin with refs/heads, refs/tags, or refs/remotes when applied to --branches, --tags, or --remotes, respectively, and they must begin with refs/ when applied to --glob or --all. If a trailing /* is intended, it must be given explicitly."),
					new GitCommandOption("--exclude-first-parent-only", "--exclude-first-parent-only", @"When finding commits to exclude (with a ^), follow only the first parent commit upon seeing a merge commit. This can be used to find the set of changes in a topic branch from the point where it diverged from the remote branch, given that arbitrary merges can be valid topic branch changes."),
					new GitCommandOption("--extended-regexp", "--extended-regexp", @"Consider the limiting patterns to be extended regular expressions instead of the default basic regular expressions."),
					new GitCommandOption("--first-parent", "--first-parent", @"When finding commits to include, follow only the first parent commit upon seeing a merge commit.  This option can give a better overview when viewing the evolution of a particular topic branch, because merges into a topic branch tend to be only about adjusting to updated upstream from time to time, and this option allows you to ignore the individual commits brought in to your history by such a merge."),
					new GitCommandOption("--fixed-strings", "--fixed-strings", @"Consider the limiting patterns to be fixed strings (don’t interpret pattern as a regular expression)."),
					new GitCommandOption("--format[", "--format[=<format>]", @"Instead of the commit subject, use some other information to describe each commit.  <format> can be any string accepted by the --format option of git log, such as * [%h] %s. (See the ""PRETTY FORMATS"" section of git-log.)   Each pretty-printed commit will be rewrapped before it is shown."),
					new GitCommandOption("--full-history", "--full-history with parent rewriting", @"Ordinary commits are only included if they are !TREESAME (though this can be changed, see --sparse below).  Merges are always included.  However, their parent list is rewritten: Along each parent, prune away commits that are not included themselves.  This results in              .-A---M---N---O---P---Q          /     /   /   /   /         I     B   /   D   /          \   /   /   /   /           `-------------'    Compare to --full-history without rewriting above.  Note that E was pruned away because it is TREESAME, but the parent list of P was rewritten to contain E's parent I.  The same happened for C and N, and X, Y and Q."),
					new GitCommandOption("--full-history", "--full-history without parent rewriting", @"This mode differs from the default in one point: always follow all parents of a merge, even if it is TREESAME to one of them. Even if more than one side of the merge has commits that are included, this does not imply that the merge itself is!  In the example, we get           I  A  B  N  D  O  P  Q    M was excluded because it is TREESAME to both parents.  E, C and B were all walked, but only B was !TREESAME, so the others do not appear.   Note that without parent rewriting, it is not really possible to talk about the parent/child relationships between the commits, so we show them disconnected."),
					new GitCommandOption("--full-history", "--full-history", @"Same as the default mode, but does not prune some history."),
					new GitCommandOption("--glob", "--glob=<glob-pattern>", @"Pretend as if all the refs matching shell glob <glob-pattern> are listed on the command line as <commit>. Leading refs/, is automatically prepended if missing. If pattern lacks ?, *, or [, /* at the end is implied."),
					new GitCommandOption("--grep", "--grep=<pattern>", @"Limit the commits output to ones with log message that matches the specified pattern (regular expression).  With more than one --grep=<pattern>, commits whose message matches any of the given patterns are chosen (but see --all-match).  When --notes is in effect, the message from the notes is matched as if it were part of the log message."),
					new GitCommandOption("--grep-reflog", "--grep-reflog=<pattern>", @"Limit the commits output to ones with reflog entries that match the specified pattern (regular expression). With more than one --grep-reflog, commits whose reflog message matches any of the given patterns are chosen.  It is an error to use this option unless --walk-reflogs is in use."),
					new GitCommandOption("--group", "--group=<type>", @"Group commits based on <type>. If no --group option is specified, the default is author. <type> is one of:      author, commits are grouped by author   committer, commits are grouped by committer (the same as -c)   trailer:<field>, the <field> is interpreted as a case-insensitive commit message trailer (see git-interpret-trailers). For example, if your project uses Reviewed-by trailers, you might want to see who has been reviewing with git shortlog -ns --group=trailer:reviewed-by.  Note that commits that do not include the trailer will not be counted. Likewise, commits with multiple trailers (e.g., multiple signoffs) may be counted more than once (but only once per unique trailer value in that commit).   Shortlog will attempt to parse each trailer value as a name <email> identity. If successful, the mailmap is applied and the email is omitted unless the --email option is specified. If the value cannot be parsed as an identity, it will be taken literally and completely.        If --group is specified multiple times, commits are counted under each value (but again, only once per unique value in that commit). For example, git shortlog --group=author --group=trailer:co-authored-by counts both authors and co-authors."),
					new GitCommandOption("--ignore-missing", "--ignore-missing", @"Upon seeing an invalid object name in the input, pretend as if the bad input was not given."),
					new GitCommandOption("--invert-grep", "--invert-grep", @"Limit the commits output to ones with log message that do not match the pattern specified with --grep=<pattern>."),
					new GitCommandOption("--left-only", "--left-only", @"List only commits on the respective side of a symmetric difference, i.e. only those which would be marked < resp. > by --left-right.  For example, --cherry-pick --right-only A...B omits those commits from B which are in A or are patch-equivalent to a commit in A. In other words, this lists the + commits from git cherry A B. More precisely, --cherry-pick --right-only --no-merges gives the exact list."),
					new GitCommandOption("--max-count", "--max-count=<number>", @"Limit the number of commits to output."),
					new GitCommandOption("--max-parents", "--max-parents=<number>", @"Show only commits which have at least (or at most) that many parent commits. In particular, --max-parents=1 is the same as --no-merges, --min-parents=2 is the same as --merges.  --max-parents=0 gives all root commits and --min-parents=3 all octopus merges.  --no-min-parents and --no-max-parents reset these limits (to no limit) again.  Equivalent forms are --min-parents=0 (any commit has 0 or more parents) and --max-parents=-1 (negative numbers denote no upper limit)."),
					new GitCommandOption("--merge", "--merge", @"After a failed merge, show refs that touch files having a conflict and don’t exist on all heads to merge."),
					new GitCommandOption("--merges", "--merges", @"Print only merge commits. This is exactly the same as --min-parents=2."),
					new GitCommandOption("--min-parents", "--min-parents=<number>", @"Show only commits which have at least (or at most) that many parent commits. In particular, --max-parents=1 is the same as --no-merges, --min-parents=2 is the same as --merges.  --max-parents=0 gives all root commits and --min-parents=3 all octopus merges.  --no-min-parents and --no-max-parents reset these limits (to no limit) again.  Equivalent forms are --min-parents=0 (any commit has 0 or more parents) and --max-parents=-1 (negative numbers denote no upper limit)."),
					new GitCommandOption("--no-max-parents", "--no-max-parents", @"Show only commits which have at least (or at most) that many parent commits. In particular, --max-parents=1 is the same as --no-merges, --min-parents=2 is the same as --merges.  --max-parents=0 gives all root commits and --min-parents=3 all octopus merges.  --no-min-parents and --no-max-parents reset these limits (to no limit) again.  Equivalent forms are --min-parents=0 (any commit has 0 or more parents) and --max-parents=-1 (negative numbers denote no upper limit)."),
					new GitCommandOption("--no-merges", "--no-merges", @"Do not print commits with more than one parent. This is exactly the same as --max-parents=1."),
					new GitCommandOption("--no-min-parents", "--no-min-parents", @"Show only commits which have at least (or at most) that many parent commits. In particular, --max-parents=1 is the same as --no-merges, --min-parents=2 is the same as --merges.  --max-parents=0 gives all root commits and --min-parents=3 all octopus merges.  --no-min-parents and --no-max-parents reset these limits (to no limit) again.  Equivalent forms are --min-parents=0 (any commit has 0 or more parents) and --max-parents=-1 (negative numbers denote no upper limit)."),
					new GitCommandOption("--not", "--not", @"Reverses the meaning of the ^ prefix (or lack thereof) for all following revision specifiers, up to the next --not."),
					new GitCommandOption("--numbered", "--numbered", @"Sort output according to the number of commits per author instead of author alphabetic order."),
					new GitCommandOption("--perl-regexp", "--perl-regexp", @"Consider the limiting patterns to be Perl-compatible regular expressions.  Support for these types of regular expressions is an optional compile-time dependency. If Git wasn’t compiled with support for them providing this option will cause it to die."),
					new GitCommandOption("--reflog", "--reflog", @"Pretend as if all objects mentioned by reflogs are listed on the command line as <commit>."),
					new GitCommandOption("--regexp-ignore-case", "--regexp-ignore-case", @"Match the regular expression limiting patterns without regard to letter case."),
					new GitCommandOption("--remotes[", "--remotes[=<pattern>]", @"Pretend as if all the refs in refs/remotes are listed on the command line as <commit>. If <pattern> is given, limit remote-tracking branches to ones matching given shell glob. If pattern lacks ?, *, or [, /* at the end is implied."),
					new GitCommandOption("--remove-empty", "--remove-empty", @"Stop when a given path disappears from the tree."),
					new GitCommandOption("--right-only", "--right-only", @"List only commits on the respective side of a symmetric difference, i.e. only those which would be marked < resp. > by --left-right.  For example, --cherry-pick --right-only A...B omits those commits from B which are in A or are patch-equivalent to a commit in A. In other words, this lists the + commits from git cherry A B. More precisely, --cherry-pick --right-only --no-merges gives the exact list."),
					new GitCommandOption("--show-pulls", "--show-pulls", @"Include all commits from the default mode, but also any merge commits that are not TREESAME to the first parent but are TREESAME to a later parent. This mode is helpful for showing the merge commits that ""first introduced"" a change to a branch."),
					new GitCommandOption("--show-pulls", "--show-pulls", @"In addition to the commits shown in the default history, show each merge commit that is not TREESAME to its first parent but is TREESAME to a later parent.  When a merge commit is included by --show-pulls, the merge is treated as if it ""pulled"" the change from another branch. When using --show-pulls on this example (and no other options) the resulting graph is:            I---X---R---N    Here, the merge commits R and N are included because they pulled the commits X and R into the base branch, respectively. These merges are the reason the commits A and B do not appear in the default history.   When --show-pulls is paired with --simplify-merges, the graph includes all of the necessary information:              .-A---M--.   N          /     /    \ /         I     B      R          \   /      /           \ /      /            `---X--'    Notice that since M is reachable from R, the edge from N to M was simplified away. However, N still appears in the history as an important commit because it ""pulled"" the change R into the main branch."),
					new GitCommandOption("--simplify-by-decoration", "--simplify-by-decoration", @"Commits that are referred by some branch or tag are selected."),
					new GitCommandOption("--simplify-merges", "--simplify-merges", @"First, build a history graph in the same way that --full-history with parent rewriting does (see above).  Then simplify each commit C to its replacement C' in the final history according to the following rules:       Set C' to C.   Replace each parent P of C' with its simplification P'.  In the process, drop parents that are ancestors of other parents or that are root commits TREESAME to an empty tree, and remove duplicates, but take care to never drop all parents that we are TREESAME to.   If after this parent rewriting, C' is a root or merge commit (has zero or >1 parents), a boundary commit, or !TREESAME, it remains. Otherwise, it is replaced with its only parent.       The effect of this is best shown by way of comparing to --full-history with parent rewriting.  The example turns into:              .-A---M---N---O          /     /       /         I     B       D          \   /       /           `---------'    Note the major differences in N, P, and Q over --full-history:       N's parent list had I removed, because it is an ancestor of the other parent M.  Still, N remained because it is !TREESAME.   P's parent list similarly had I removed.  P was then removed completely, because it had one parent and is TREESAME.   Q's parent list had Y simplified to X. X was then removed, because it was a TREESAME root. Q was then removed completely, because it had one parent and is TREESAME."),
					new GitCommandOption("--simplify-merges", "--simplify-merges", @"Additional option to --full-history to remove some needless merges from the resulting history, as there are no selected commits contributing to this merge."),
					new GitCommandOption("--since", "--since=<date>", @"Show commits more recent than a specific date."),
					new GitCommandOption("--single-worktree", "--single-worktree", @"By default, all working trees will be examined by the following options when there are more than one (see git-worktree): --all, --reflog and --indexed-objects. This option forces them to examine the current working tree only."),
					new GitCommandOption("--skip", "--skip=<number>", @"Skip number commits before starting to show the commit output."),
					new GitCommandOption("--sparse", "--sparse", @"All commits in the simplified history are shown."),
					new GitCommandOption("--sparse", "--sparse", @"All commits that are walked are included.  Note that without --full-history, this still simplifies merges: if one of the parents is TREESAME, we follow only that one, so the other sides of the merge are never walked."),
					new GitCommandOption("--stdin", "--stdin", @"In addition to the <commit> listed on the command line, read them from the standard input. If a -- separator is seen, stop reading commits and start reading paths to limit the result."),
					new GitCommandOption("--summary", "--summary", @"Suppress commit description and provide a commit count summary only."),
					new GitCommandOption("--tags[", "--tags[=<pattern>]", @"Pretend as if all the refs in refs/tags are listed on the command line as <commit>. If <pattern> is given, limit tags to ones matching given shell glob. If pattern lacks ?, *, or [, /* at the end is implied."),
					new GitCommandOption("--until", "--until=<date>", @"Show commits older than a specific date."),
					new GitCommandOption("--walk-reflogs", "--walk-reflogs", @"Instead of walking the commit ancestry chain, walk reflog entries from the most recent one to older ones. When this option is used you cannot specify commits to exclude (that is, ^commit, commit1..commit2, and commit1...commit2 notations cannot be used).  With --pretty format other than oneline and reference (for obvious reasons), this causes the output to have two extra lines of information taken from the reflog.  The reflog designator in the output may be shown as ref@{Nth} (where Nth is the reverse-chronological index in the reflog) or as ref@{timestamp} (with the timestamp for that entry), depending on a few rules:       If the starting point is specified as ref@{Nth}, show the index format.   If the starting point was specified as ref@{now}, show the timestamp format.   If neither was used, but --date was given on the command line, show the timestamp in the format requested by --date.   Otherwise, show the index format.       Under --pretty=oneline, the commit message is prefixed with this information on the same line. This option cannot be combined with --reverse. See also git-reflog.   Under --pretty=reference, this information will not be shown at all."),
					new GitCommandOption("-<number>", "-<number>", @"Limit the number of commits to output."),
					new GitCommandOption("-c", "-c", @"This is an alias for --group=committer."),
					new GitCommandOption("-E", "-E", @"Consider the limiting patterns to be extended regular expressions instead of the default basic regular expressions."),
					new GitCommandOption("-e", "-e", @"Show the email address of each author."),
					new GitCommandOption("-F", "-F", @"Consider the limiting patterns to be fixed strings (don’t interpret pattern as a regular expression)."),
					new GitCommandOption("-g", "-g", @"Instead of walking the commit ancestry chain, walk reflog entries from the most recent one to older ones. When this option is used you cannot specify commits to exclude (that is, ^commit, commit1..commit2, and commit1...commit2 notations cannot be used).  With --pretty format other than oneline and reference (for obvious reasons), this causes the output to have two extra lines of information taken from the reflog.  The reflog designator in the output may be shown as ref@{Nth} (where Nth is the reverse-chronological index in the reflog) or as ref@{timestamp} (with the timestamp for that entry), depending on a few rules:       If the starting point is specified as ref@{Nth}, show the index format.   If the starting point was specified as ref@{now}, show the timestamp format.   If neither was used, but --date was given on the command line, show the timestamp in the format requested by --date.   Otherwise, show the index format.       Under --pretty=oneline, the commit message is prefixed with this information on the same line. This option cannot be combined with --reverse. See also git-reflog.   Under --pretty=reference, this information will not be shown at all."),
					new GitCommandOption("-i", "-i", @"Match the regular expression limiting patterns without regard to letter case."),
					new GitCommandOption("-n", "-n", @"Sort output according to the number of commits per author instead of author alphabetic order."),
					new GitCommandOption("-n", "-n <number>", @"Limit the number of commits to output."),
					new GitCommandOption("-P", "-P", @"Consider the limiting patterns to be Perl-compatible regular expressions.  Support for these types of regular expressions is an optional compile-time dependency. If Git wasn’t compiled with support for them providing this option will cause it to die."),
					new GitCommandOption("-s", "-s", @"Suppress commit description and provide a commit count summary only."),
					new GitCommandOption("-w[<width>[,<indent1>[,<indent2>]]]", "-w[<width>[,<indent1>[,<indent2>]]]", @"Linewrap the output by wrapping each line at width.  The first line of each entry is indented by indent1 spaces, and the second and subsequent lines are indented by indent2 spaces. width, indent1, and indent2 default to 76, 6 and 9 respectively.  If width is 0 (zero) then indent the lines of the output without wrapping them."),
					new GitCommandOption("[--]", "[--] <path>…​", @"Consider only commits that are enough to explain how the files that match the specified paths came to be.  Paths may need to be prefixed with -- to separate them from options or the revision range, when confusion arises."),
					new GitCommandOption("Default", "Default mode", @"Commits are included if they are not TREESAME to any parent (though this can be changed, see --sparse below).  If the commit was a merge, and it was TREESAME to one parent, follow only that parent.  (Even if there are several TREESAME parents, follow only one of them.)  Otherwise, follow all parents.  This results in:              .-A---N---O          /     /   /         I---------D    Note how the rule to only follow the TREESAME parent, if one is available, removed B from consideration entirely.  C was considered via N, but is TREESAME.  Root commits are compared to an empty tree, so I is !TREESAME.   Parent/child relations are only visible with --parents, but that does not affect the commits selected in default mode, so we have shown the parent lines."),
					new GitCommandOption("Default", "Default mode", @"Simplifies the history to the simplest history explaining the final state of the tree. Simplest because it prunes some side branches if the end result is the same (i.e. merging branches with the same content)"),
				}, 
	"show-branch" => new GitCommandOption[] {
					new GitCommandOption("<glob>", "<glob>", @"A glob pattern that matches branch or tag names under refs/.  For example, if you have many topic branches under refs/heads/topic, giving topic/* would show all of them."),
					new GitCommandOption("<rev>", "<rev>", @"Arbitrary extended SHA-1 expression (see gitrevisions) that typically names a branch head or a tag."),
					new GitCommandOption("--all", "--all", @"Show both remote-tracking branches and local branches."),
					new GitCommandOption("--color[", "--color[=<when>]", @"Color the status sign (one of these: * ! + -) of each commit corresponding to the branch it’s in. The value must be always (the default), never, or auto."),
					new GitCommandOption("--current", "--current", @"With this option, the command includes the current branch to the list of revs to be shown when it is not given on the command line."),
					new GitCommandOption("--date-order", "--date-order", @"This option is similar to --topo-order in the sense that no parent comes before all of its children, but otherwise commits are ordered according to their commit date."),
					new GitCommandOption("--independent", "--independent", @"Among the <reference>s given, display only the ones that cannot be reached from any other <reference>."),
					new GitCommandOption("--list", "--list", @"Synonym to --more=-1"),
					new GitCommandOption("--merge-base", "--merge-base", @"Instead of showing the commit list, determine possible merge bases for the specified commits. All merge bases will be contained in all specified commits. This is different from how git-merge-base handles the case of three or more commits."),
					new GitCommandOption("--more", "--more=<n>", @"Usually the command stops output upon showing the commit that is the common ancestor of all the branches.  This flag tells the command to go <n> more common commits beyond that.  When <n> is negative, display only the <reference>s given, without showing the commit ancestry tree."),
					new GitCommandOption("--no-color", "--no-color", @"Turn off colored output, even when the configuration file gives the default to color output. Same as --color=never."),
					new GitCommandOption("--no-name", "--no-name", @"Do not show naming strings for each commit."),
					new GitCommandOption("--reflog[", "--reflog[=<n>[,<base>]] [<ref>]", @"Shows <n> most recent ref-log entries for the given ref.  If <base> is given, <n> entries going back from that entry.  <base> can be specified as count or date. When no explicit <ref> parameter is given, it defaults to the current branch (or HEAD if it is detached)."),
					new GitCommandOption("--remotes", "--remotes", @"Show the remote-tracking branches."),
					new GitCommandOption("--sha1-name", "--sha1-name", @"Instead of naming the commits using the path to reach them from heads (e.g. ""master~2"" to mean the grandparent of ""master""), name them with the unique prefix of their object names."),
					new GitCommandOption("--sparse", "--sparse", @"By default, the output omits merges that are reachable from only one tip being shown.  This option makes them visible."),
					new GitCommandOption("--topics", "--topics", @"Shows only commits that are NOT on the first branch given. This helps track topic branches by hiding any commit that is already in the main line of development.  When given ""git show-branch --topics master topic1 topic2"", this will show the revisions given by ""git rev-list ^master topic1 topic2"""),
					new GitCommandOption("--topo-order", "--topo-order", @"By default, the branches and their commits are shown in reverse chronological order.  This option makes them appear in topological order (i.e., descendant commits are shown before their parents)."),
					new GitCommandOption("-a", "-a", @"Show both remote-tracking branches and local branches."),
					new GitCommandOption("-g", "-g", @"Shows <n> most recent ref-log entries for the given ref.  If <base> is given, <n> entries going back from that entry.  <base> can be specified as count or date. When no explicit <ref> parameter is given, it defaults to the current branch (or HEAD if it is detached)."),
					new GitCommandOption("-r", "-r", @"Show the remote-tracking branches."),
				}, 
	"show-index" => new GitCommandOption[] {
					new GitCommandOption("--object-format", "--object-format=<hash-algorithm>", @"Specify the given object format (hash algorithm) for the index file.  The valid values are sha1 and (if enabled) sha256.  The default is the algorithm for the current repository (set by extensions.objectFormat), or sha1 if no value is set or outside a repository..  THIS OPTION IS EXPERIMENTAL! SHA-256 support is experimental and still in an early stage.  A SHA-256 repository will in general not be able to share work with ""regular"" SHA-1 repositories.  It should be assumed that, e.g., Git internal file formats in relation to SHA-256 repositories may change in backwards-incompatible ways.  Only use --object-format=sha256 for testing purposes."),
				}, 
	"show-ref" => new GitCommandOption[] {
					new GitCommandOption("<pattern>…​", "<pattern>…​", @"Show references matching one or more patterns. Patterns are matched from the end of the full name, and only complete parts are matched, e.g. master matches refs/heads/master, refs/remotes/origin/master, refs/tags/jedi/master but not refs/heads/mymaster or refs/remotes/master/jedi."),
					new GitCommandOption("--abbrev[", "--abbrev[=<n>]", @"Abbreviate the object name.  When using --hash, you do not have to say --hash --abbrev; --hash=n would do."),
					new GitCommandOption("--dereference", "--dereference", @"Dereference tags into object IDs as well. They will be shown with ""^{}"" appended."),
					new GitCommandOption("--exclude-existing[", "--exclude-existing[=<pattern>]", @"Make git show-ref act as a filter that reads refs from stdin of the form ""^(?:<anything>\s)?<refname>(?:\^{})?$"" and performs the following actions on each:  strip ""^{}"" at the end of line if any;  ignore if pattern is provided and does not head-match refname;  warn if refname is not a well-formed refname and skip;  ignore if refname is a ref that exists in the local repository;  otherwise output the line."),
					new GitCommandOption("--hash[", "--hash[=<n>]", @"Only show the SHA-1 hash, not the reference name. When combined with --dereference the dereferenced tag will still be shown after the SHA-1."),
					new GitCommandOption("--head", "--head", @"Show the HEAD reference, even if it would normally be filtered out."),
					new GitCommandOption("--heads", "--heads", @"Limit to ""refs/heads"" and ""refs/tags"", respectively.  These options are not mutually exclusive; when given both, references stored in ""refs/heads"" and ""refs/tags"" are displayed."),
					new GitCommandOption("--quiet", "--quiet", @"Do not print any results to stdout. When combined with --verify this can be used to silently check if a reference exists."),
					new GitCommandOption("--tags", "--tags", @"Limit to ""refs/heads"" and ""refs/tags"", respectively.  These options are not mutually exclusive; when given both, references stored in ""refs/heads"" and ""refs/tags"" are displayed."),
					new GitCommandOption("--verify", "--verify", @"Enable stricter reference checking by requiring an exact ref path. Aside from returning an error code of 1, it will also print an error message if --quiet was not specified."),
					new GitCommandOption("-d", "-d", @"Dereference tags into object IDs as well. They will be shown with ""^{}"" appended."),
					new GitCommandOption("-q", "-q", @"Do not print any results to stdout. When combined with --verify this can be used to silently check if a reference exists."),
					new GitCommandOption("-s", "-s", @"Only show the SHA-1 hash, not the reference name. When combined with --dereference the dereferenced tag will still be shown after the SHA-1."),
				}, 
	"show" => new GitCommandOption[] {
					new GitCommandOption("<object>…​", "<object>…​", @"The names of objects to show (defaults to HEAD). For a more complete list of ways to spell object names, see ""SPECIFYING REVISIONS"" section in gitrevisions."),
					new GitCommandOption("--[no-]standard-notes", "--[no-]standard-notes", @"These options are deprecated. Use the above --notes/--no-notes options instead."),
					new GitCommandOption("--abbrev-commit", "--abbrev-commit", @"Instead of showing the full 40-byte hexadecimal commit object name, show a prefix that names the object uniquely. ""--abbrev=<n>"" (which also modifies diff output, if it is displayed) option can be used to specify the minimum length of the prefix.  This should make ""--pretty=oneline"" a whole lot more readable for people using 80-column terminals."),
					new GitCommandOption("--encoding", "--encoding=<encoding>", @"Commit objects record the character encoding used for the log message in their encoding header; this option can be used to tell the command to re-code the commit log message in the encoding preferred by the user.  For non plumbing commands this defaults to UTF-8. Note that if an object claims to be encoded in X and we are outputting in X, we will output the object verbatim; this means that invalid sequences in the original commit may be copied to the output. Likewise, if iconv fails to convert the commit, we will quietly output the original object verbatim."),
					new GitCommandOption("--expand-tabs", "--expand-tabs=<n>", @"Perform a tab expansion (replace each tab with enough spaces to fill to the next display column that is multiple of <n>) in the log message before showing it in the output. --expand-tabs is a short-hand for --expand-tabs=8, and --no-expand-tabs is a short-hand for --expand-tabs=0, which disables tab expansion.  By default, tabs are expanded in pretty formats that indent the log message by 4 spaces (i.e.  medium, which is the default, full, and fuller)."),
					new GitCommandOption("--expand-tabs", "--expand-tabs", @"Perform a tab expansion (replace each tab with enough spaces to fill to the next display column that is multiple of <n>) in the log message before showing it in the output. --expand-tabs is a short-hand for --expand-tabs=8, and --no-expand-tabs is a short-hand for --expand-tabs=0, which disables tab expansion.  By default, tabs are expanded in pretty formats that indent the log message by 4 spaces (i.e.  medium, which is the default, full, and fuller)."),
					new GitCommandOption("--format", "--format=<format>", @"Pretty-print the contents of the commit logs in a given format, where <format> can be one of oneline, short, medium, full, fuller, reference, email, raw, format:<string> and tformat:<string>.  When <format> is none of the above, and has %placeholder in it, it acts as if --pretty=tformat:<format> were given.  See the ""PRETTY FORMATS"" section for some additional details for each format.  When =<format> part is omitted, it defaults to medium.   Note: you can specify the default pretty format in the repository configuration (see git-config)."),
					new GitCommandOption("--no-abbrev-commit", "--no-abbrev-commit", @"Show the full 40-byte hexadecimal commit object name. This negates --abbrev-commit, either explicit or implied by other options such as ""--oneline"". It also overrides the log.abbrevCommit variable."),
					new GitCommandOption("--no-expand-tabs", "--no-expand-tabs", @"Perform a tab expansion (replace each tab with enough spaces to fill to the next display column that is multiple of <n>) in the log message before showing it in the output. --expand-tabs is a short-hand for --expand-tabs=8, and --no-expand-tabs is a short-hand for --expand-tabs=0, which disables tab expansion.  By default, tabs are expanded in pretty formats that indent the log message by 4 spaces (i.e.  medium, which is the default, full, and fuller)."),
					new GitCommandOption("--no-notes", "--no-notes", @"Do not show notes. This negates the above --notes option, by resetting the list of notes refs from which notes are shown. Options are parsed in the order given on the command line, so e.g. ""--notes --notes=foo --no-notes --notes=bar"" will only show notes from ""refs/notes/bar""."),
					new GitCommandOption("--notes[", "--notes[=<ref>]", @"Show the notes (see git-notes) that annotate the commit, when showing the commit log message.  This is the default for git log, git show and git whatchanged commands when there is no --pretty, --format, or --oneline option given on the command line.  By default, the notes shown are from the notes refs listed in the core.notesRef and notes.displayRef variables (or corresponding environment overrides). See git-config for more details.   With an optional <ref> argument, use the ref to find the notes to display.  The ref can specify the full refname when it begins with refs/notes/; when it begins with notes/, refs/ and otherwise refs/notes/ is prefixed to form a full name of the ref.   Multiple --notes options can be combined to control which notes are being displayed. Examples: ""--notes=foo"" will show only notes from ""refs/notes/foo""; ""--notes=foo --notes"" will show both notes from ""refs/notes/foo"" and from the default notes ref(s)."),
					new GitCommandOption("--oneline", "--oneline", @"This is a shorthand for ""--pretty=oneline --abbrev-commit"" used together."),
					new GitCommandOption("--pretty[", "--pretty[=<format>]", @"Pretty-print the contents of the commit logs in a given format, where <format> can be one of oneline, short, medium, full, fuller, reference, email, raw, format:<string> and tformat:<string>.  When <format> is none of the above, and has %placeholder in it, it acts as if --pretty=tformat:<format> were given.  See the ""PRETTY FORMATS"" section for some additional details for each format.  When =<format> part is omitted, it defaults to medium.   Note: you can specify the default pretty format in the repository configuration (see git-config)."),
					new GitCommandOption("--show-notes[", "--show-notes[=<ref>]", @"These options are deprecated. Use the above --notes/--no-notes options instead."),
					new GitCommandOption("--show-signature", "--show-signature", @"Check the validity of a signed commit object by passing the signature to gpg --verify and show the output."),
				}, 
	"sparse-checkout" => new GitCommandOption[] {
				}, 
	"stage" => new GitCommandOption[] {
				}, 
	"stash" => new GitCommandOption[] {
					new GitCommandOption("<pathspec>…​", "<pathspec>…​", @"This option is only valid for push command.  The new stash entry records the modified states only for the files that match the pathspec.  The index entries and working tree files are then rolled back to the state in HEAD only for these files, too, leaving files that do not match the pathspec intact.   For more details, see the pathspec entry in gitglossary."),
					new GitCommandOption("<stash>", "<stash>", @"This option is only valid for apply, branch, drop, pop, show commands.  A reference of the form stash@{<revision>}. When no <stash> is given, the latest stash is assumed (that is, stash@{0})."),
					new GitCommandOption("--", "--", @"This option is only valid for push command.  Separates pathspec from options for disambiguation purposes."),
					new GitCommandOption("--all", "--all", @"This option is only valid for push and save commands.  All ignored and untracked files are also stashed and then cleaned up with git clean."),
					new GitCommandOption("--include-untracked", "--include-untracked", @"When used with the push and save commands, all untracked files are also stashed and then cleaned up with git clean.  When used with the show command, show the untracked files in the stash entry as part of the diff."),
					new GitCommandOption("--index", "--index", @"This option is only valid for pop and apply commands.  Tries to reinstate not only the working tree’s changes, but also the index’s ones. However, this can fail, when you have conflicts (which are stored in the index, where you therefore can no longer apply the changes as they were originally)."),
					new GitCommandOption("--keep-index", "--keep-index", @"This option is only valid for push and save commands.  All changes already added to the index are left intact."),
					new GitCommandOption("--no-include-untracked", "--no-include-untracked", @"When used with the push and save commands, all untracked files are also stashed and then cleaned up with git clean.  When used with the show command, show the untracked files in the stash entry as part of the diff."),
					new GitCommandOption("--no-keep-index", "--no-keep-index", @"This option is only valid for push and save commands.  All changes already added to the index are left intact."),
					new GitCommandOption("--only-untracked", "--only-untracked", @"This option is only valid for the show command.  Show only the untracked files in the stash entry as part of the diff."),
					new GitCommandOption("--patch", "--patch", @"This option is only valid for push and save commands.  Interactively select hunks from the diff between HEAD and the working tree to be stashed.  The stash entry is constructed such that its index state is the same as the index state of your repository, and its worktree contains only the changes you selected interactively.  The selected changes are then rolled back from your worktree. See the “Interactive Mode” section of git-add to learn how to operate the --patch mode.   The --patch option implies --keep-index.  You can use --no-keep-index to override this."),
					new GitCommandOption("--pathspec-file-nul", "--pathspec-file-nul", @"This option is only valid for push command.  Only meaningful with --pathspec-from-file. Pathspec elements are separated with NUL character and all other characters are taken literally (including newlines and quotes)."),
					new GitCommandOption("--pathspec-from-file", "--pathspec-from-file=<file>", @"This option is only valid for push command.  Pathspec is passed in <file> instead of commandline args. If <file> is exactly - then standard input is used. Pathspec elements are separated by LF or CR/LF. Pathspec elements can be quoted as explained for the configuration variable core.quotePath (see git-config). See also --pathspec-file-nul and global --literal-pathspecs."),
					new GitCommandOption("--quiet", "--quiet", @"This option is only valid for apply, drop, pop, push, save, store commands.  Quiet, suppress feedback messages."),
					new GitCommandOption("--staged", "--staged", @"This option is only valid for push and save commands.  Stash only the changes that are currently staged. This is similar to basic git commit except the state is committed to the stash instead of current branch.   The --patch option has priority over this one."),
					new GitCommandOption("-a", "-a", @"This option is only valid for push and save commands.  All ignored and untracked files are also stashed and then cleaned up with git clean."),
					new GitCommandOption("-k", "-k", @"This option is only valid for push and save commands.  All changes already added to the index are left intact."),
					new GitCommandOption("-p", "-p", @"This option is only valid for push and save commands.  Interactively select hunks from the diff between HEAD and the working tree to be stashed.  The stash entry is constructed such that its index state is the same as the index state of your repository, and its worktree contains only the changes you selected interactively.  The selected changes are then rolled back from your worktree. See the “Interactive Mode” section of git-add to learn how to operate the --patch mode.   The --patch option implies --keep-index.  You can use --no-keep-index to override this."),
					new GitCommandOption("-q", "-q", @"This option is only valid for apply, drop, pop, push, save, store commands.  Quiet, suppress feedback messages."),
					new GitCommandOption("-S", "-S", @"This option is only valid for push and save commands.  Stash only the changes that are currently staged. This is similar to basic git commit except the state is committed to the stash instead of current branch.   The --patch option has priority over this one."),
					new GitCommandOption("-u", "-u", @"When used with the push and save commands, all untracked files are also stashed and then cleaned up with git clean.  When used with the show command, show the untracked files in the stash entry as part of the diff."),
				}, 
	"status" => new GitCommandOption[] {
					new GitCommandOption("<pathspec>…​", "<pathspec>…​", @"See the pathspec entry in gitglossary."),
					new GitCommandOption("--ahead-behind", "--ahead-behind", @"Display or do not display detailed ahead/behind counts for the branch relative to its upstream branch.  Defaults to true."),
					new GitCommandOption("--branch", "--branch", @"Show the branch and tracking info even in short-format."),
					new GitCommandOption("--column[", "--column[=<options>]", @"Display untracked files in columns. See configuration variable column.status for option syntax. --column and --no-column without options are equivalent to always and never respectively."),
					new GitCommandOption("--find-renames[", "--find-renames[=<n>]", @"Turn on rename detection, optionally setting the similarity threshold. See also git-diff --find-renames."),
					new GitCommandOption("--ignore-submodules[", "--ignore-submodules[=<when>]", @"Ignore changes to submodules when looking for changes. <when> can be either ""none"", ""untracked"", ""dirty"" or ""all"", which is the default. Using ""none"" will consider the submodule modified when it either contains untracked or modified files or its HEAD differs from the commit recorded in the superproject and can be used to override any settings of the ignore option in git-config or gitmodules. When ""untracked"" is used submodules are not considered dirty when they only contain untracked content (but they are still scanned for modified content). Using ""dirty"" ignores all changes to the work tree of submodules, only changes to the commits stored in the superproject are shown (this was the behavior before 1.7.0). Using ""all"" hides all changes to submodules (and suppresses the output of submodule summaries when the config option status.submoduleSummary is set)."),
					new GitCommandOption("--ignored[", "--ignored[=<mode>]", @"Show ignored files as well.    The mode parameter is used to specify the handling of ignored files. It is optional: it defaults to traditional.   The possible options are:     traditional - Shows ignored files and directories, unless --untracked-files=all is specified, in which case individual files in ignored directories are displayed.   no	        - Show no ignored files.   matching    - Shows ignored files and directories matching an ignore pattern.     When matching mode is specified, paths that explicitly match an ignored pattern are shown. If a directory matches an ignore pattern, then it is shown, but not paths contained in the ignored directory. If a directory does not match an ignore pattern, but all contents are ignored, then the directory is not shown, but all contents are shown."),
					new GitCommandOption("--lock-index", "--lock-index", @"(DEPRECATED: use --no-optional-locks instead) Specifies whether git status should try to lock the index and update it afterwards if any changes were detected. Defaults to --lock-index."),
					new GitCommandOption("--long", "--long", @"Give the output in the long-format. This is the default."),
					new GitCommandOption("--no-ahead-behind", "--no-ahead-behind", @"Display or do not display detailed ahead/behind counts for the branch relative to its upstream branch.  Defaults to true."),
					new GitCommandOption("--no-column", "--no-column", @"Display untracked files in columns. See configuration variable column.status for option syntax. --column and --no-column without options are equivalent to always and never respectively."),
					new GitCommandOption("--no-lock-index", "--no-lock-index", @"(DEPRECATED: use --no-optional-locks instead) Specifies whether git status should try to lock the index and update it afterwards if any changes were detected. Defaults to --lock-index."),
					new GitCommandOption("--no-renames", "--no-renames", @"Turn on/off rename detection regardless of user configuration. See also git-diff --no-renames."),
					new GitCommandOption("--porcelain[", "--porcelain[=<version>]", @"Give the output in an easy-to-parse format for scripts. This is similar to the short output, but will remain stable across Git versions and regardless of user configuration. See below for details.  The version parameter is used to specify the format version. This is optional and defaults to the original version v1 format."),
					new GitCommandOption("--renames", "--renames", @"Turn on/off rename detection regardless of user configuration. See also git-diff --no-renames."),
					new GitCommandOption("--short", "--short", @"Give the output in the short-format."),
					new GitCommandOption("--show-stash", "--show-stash", @"Show the number of entries currently stashed away."),
					new GitCommandOption("--untracked-files[", "--untracked-files[=<mode>]", @"Show untracked files.    The mode parameter is used to specify the handling of untracked files. It is optional: it defaults to all, and if specified, it must be stuck to the option (e.g. -uno, but not -u no).   The possible options are:     no     - Show no untracked files.   normal - Shows untracked files and directories.   all    - Also shows individual files in untracked directories.     When -u option is not used, untracked files and directories are shown (i.e. the same as specifying normal), to help you avoid forgetting to add newly created files.  Because it takes extra work to find untracked files in the filesystem, this mode may take some time in a large working tree. Consider enabling untracked cache and split index if supported (see git update-index --untracked-cache and git update-index --split-index), Otherwise you can use no to have git status return more quickly without showing untracked files.   The default can be changed using the status.showUntrackedFiles configuration variable documented in git-config."),
					new GitCommandOption("--verbose", "--verbose", @"In addition to the names of files that have been changed, also show the textual changes that are staged to be committed (i.e., like the output of git diff --cached). If -v is specified twice, then also show the changes in the working tree that have not yet been staged (i.e., like the output of git diff)."),
					new GitCommandOption("-b", "-b", @"Show the branch and tracking info even in short-format."),
					new GitCommandOption("-s", "-s", @"Give the output in the short-format."),
					new GitCommandOption("-u[<mode>]", "-u[<mode>]", @"Show untracked files.    The mode parameter is used to specify the handling of untracked files. It is optional: it defaults to all, and if specified, it must be stuck to the option (e.g. -uno, but not -u no).   The possible options are:     no     - Show no untracked files.   normal - Shows untracked files and directories.   all    - Also shows individual files in untracked directories.     When -u option is not used, untracked files and directories are shown (i.e. the same as specifying normal), to help you avoid forgetting to add newly created files.  Because it takes extra work to find untracked files in the filesystem, this mode may take some time in a large working tree. Consider enabling untracked cache and split index if supported (see git update-index --untracked-cache and git update-index --split-index), Otherwise you can use no to have git status return more quickly without showing untracked files.   The default can be changed using the status.showUntrackedFiles configuration variable documented in git-config."),
					new GitCommandOption("-v", "-v", @"In addition to the names of files that have been changed, also show the textual changes that are staged to be committed (i.e., like the output of git diff --cached). If -v is specified twice, then also show the changes in the working tree that have not yet been staged (i.e., like the output of git diff)."),
					new GitCommandOption("-z", "-z", @"Terminate entries with NUL, instead of LF.  This implies the --porcelain=v1 output format if no other format is given."),
				}, 
	"stripspace" => new GitCommandOption[] {
					new GitCommandOption("--comment-lines", "--comment-lines", @"Prepend comment character and blank to each line. Lines will automatically be terminated with a newline. On empty lines, only the comment character will be prepended."),
					new GitCommandOption("--strip-comments", "--strip-comments", @"Skip and remove all lines starting with comment character (default #)."),
					new GitCommandOption("-c", "-c", @"Prepend comment character and blank to each line. Lines will automatically be terminated with a newline. On empty lines, only the comment character will be prepended."),
					new GitCommandOption("-s", "-s", @"Skip and remove all lines starting with comment character (default #)."),
				}, 
	"submodule" => new GitCommandOption[] {
					new GitCommandOption("<path>…​", "<path>…​", @"Paths to submodule(s). When specified this will restrict the command to only operate on the submodules found at the specified paths. (This argument is required with add)."),
					new GitCommandOption("--[no-]recommend-shallow", "--[no-]recommend-shallow", @"This option is only valid for the update command. The initial clone of a submodule will use the recommended submodule.<name>.shallow as provided by the .gitmodules file by default. To ignore the suggestions use --no-recommend-shallow."),
					new GitCommandOption("--[no-]single-branch", "--[no-]single-branch", @"This option is only valid for the update command. Clone only one branch during update: HEAD or one specified by --branch."),
					new GitCommandOption("--all", "--all", @"This option is only valid for the deinit command. Unregister all submodules in the working tree."),
					new GitCommandOption("--branch", "--branch <branch>", @"Branch of repository to add as submodule. The name of the branch is recorded as submodule.<name>.branch in .gitmodules for update --remote.  A special value of . is used to indicate that the name of the branch in the submodule should be the same name as the current branch in the current repository.  If the option is not specified, it defaults to the remote HEAD."),
					new GitCommandOption("--cached", "--cached", @"This option is only valid for status and summary commands.  These commands typically use the commit found in the submodule HEAD, but with this option, the commit stored in the index is used instead."),
					new GitCommandOption("--checkout", "--checkout", @"This option is only valid for the update command. Checkout the commit recorded in the superproject on a detached HEAD in the submodule. This is the default behavior, the main use of this option is to override submodule.$name.update when set to a value other than checkout. If the key submodule.$name.update is either not explicitly set or set to checkout, this option is implicit."),
					new GitCommandOption("--depth", "--depth", @"This option is valid for add and update commands. Create a shallow clone with a history truncated to the specified number of revisions. See git-clone"),
					new GitCommandOption("--dissociate", "--dissociate", @"This option is only valid for add and update commands.  These commands sometimes need to clone a remote repository. In this case, this option will be passed to the git-clone command.  NOTE: see the NOTE for the --reference option."),
					new GitCommandOption("--files", "--files", @"This option is only valid for the summary command. This command compares the commit in the index with that in the submodule HEAD when this option is used."),
					new GitCommandOption("--force", "--force", @"This option is only valid for add, deinit and update commands. When running add, allow adding an otherwise ignored submodule path. When running deinit the submodule working trees will be removed even if they contain local changes. When running update (only effective with the checkout procedure), throw away local changes in submodules when switching to a different commit; and always run a checkout operation in the submodule, even if the commit listed in the index of the containing repository matches the commit checked out in the submodule."),
					new GitCommandOption("--init", "--init", @"This option is only valid for the update command. Initialize all submodules for which ""git submodule init"" has not been called so far before updating."),
					new GitCommandOption("--jobs", "--jobs <n>", @"This option is only valid for the update command. Clone new submodules in parallel with as many jobs. Defaults to the submodule.fetchJobs option."),
					new GitCommandOption("--merge", "--merge", @"This option is only valid for the update command. Merge the commit recorded in the superproject into the current branch of the submodule. If this option is given, the submodule’s HEAD will not be detached. If a merge failure prevents this process, you will have to resolve the resulting conflicts within the submodule with the usual conflict resolution tools. If the key submodule.$name.update is set to merge, this option is implicit."),
					new GitCommandOption("--name", "--name", @"This option is only valid for the add command. It sets the submodule’s name to the given string instead of defaulting to its path. The name must be valid as a directory name and may not end with a /."),
					new GitCommandOption("--no-fetch", "--no-fetch", @"This option is only valid for the update command. Don’t fetch new objects from the remote site."),
					new GitCommandOption("--progress", "--progress", @"This option is only valid for add and update commands. Progress status is reported on the standard error stream by default when it is attached to a terminal, unless -q is specified. This flag forces progress status even if the standard error stream is not directed to a terminal."),
					new GitCommandOption("--quiet", "--quiet", @"Only print error messages."),
					new GitCommandOption("--rebase", "--rebase", @"This option is only valid for the update command. Rebase the current branch onto the commit recorded in the superproject. If this option is given, the submodule’s HEAD will not be detached. If a merge failure prevents this process, you will have to resolve these failures with git-rebase. If the key submodule.$name.update is set to rebase, this option is implicit."),
					new GitCommandOption("--recursive", "--recursive", @"This option is only valid for foreach, update, status and sync commands. Traverse submodules recursively. The operation is performed not only in the submodules of the current repo, but also in any nested submodules inside those submodules (and so on)."),
					new GitCommandOption("--reference", "--reference <repository>", @"This option is only valid for add and update commands.  These commands sometimes need to clone a remote repository. In this case, this option will be passed to the git-clone command.  NOTE: Do not use this option unless you have read the note for git-clone's --reference, --shared, and --dissociate options carefully."),
					new GitCommandOption("--remote", "--remote", @"This option is only valid for the update command.  Instead of using the superproject’s recorded SHA-1 to update the submodule, use the status of the submodule’s remote-tracking branch.  The remote used is branch’s remote (branch.<name>.remote), defaulting to origin. The remote branch used defaults to the remote HEAD, but the branch name may be overridden by setting the submodule.<name>.branch option in either .gitmodules or .git/config (with .git/config taking precedence).  This works for any of the supported update procedures (--checkout, --rebase, etc.).  The only change is the source of the target SHA-1. For example, submodule update --remote --merge will merge upstream submodule changes into the submodules, while submodule update --merge will merge superproject gitlink changes into the submodules.   In order to ensure a current tracking branch state, update --remote fetches the submodule’s remote repository before calculating the SHA-1.  If you don’t want to fetch, you should use submodule update --remote --no-fetch.   Use this option to integrate changes from the upstream subproject with your submodule’s current HEAD.  Alternatively, you can run git pull from the submodule, which is equivalent except for the remote branch name: update --remote uses the default upstream repository and submodule.<name>.branch, while git pull uses the submodule’s branch.<name>.merge.  Prefer submodule.<name>.branch if you want to distribute the default upstream branch with the superproject and branch.<name>.merge if you want a more native feel while working in the submodule itself."),
					new GitCommandOption("--summary-limit", "--summary-limit", @"This option is only valid for the summary command. Limit the summary size (number of commits shown in total). Giving 0 will disable the summary; a negative number means unlimited (the default). This limit only applies to modified submodules. The size is always limited to 1 for added/deleted/typechanged submodules."),
					new GitCommandOption("-b", "-b <branch>", @"Branch of repository to add as submodule. The name of the branch is recorded as submodule.<name>.branch in .gitmodules for update --remote.  A special value of . is used to indicate that the name of the branch in the submodule should be the same name as the current branch in the current repository.  If the option is not specified, it defaults to the remote HEAD."),
					new GitCommandOption("-f", "-f", @"This option is only valid for add, deinit and update commands. When running add, allow adding an otherwise ignored submodule path. When running deinit the submodule working trees will be removed even if they contain local changes. When running update (only effective with the checkout procedure), throw away local changes in submodules when switching to a different commit; and always run a checkout operation in the submodule, even if the commit listed in the index of the containing repository matches the commit checked out in the submodule."),
					new GitCommandOption("-j", "-j <n>", @"This option is only valid for the update command. Clone new submodules in parallel with as many jobs. Defaults to the submodule.fetchJobs option."),
					new GitCommandOption("-n", "-n", @"This option is only valid for the summary command. Limit the summary size (number of commits shown in total). Giving 0 will disable the summary; a negative number means unlimited (the default). This limit only applies to modified submodules. The size is always limited to 1 for added/deleted/typechanged submodules."),
					new GitCommandOption("-N", "-N", @"This option is only valid for the update command. Don’t fetch new objects from the remote site."),
					new GitCommandOption("-q", "-q", @"Only print error messages."),
				}, 
	"subtree" => new GitCommandOption[] {
				}, 
	"svn" => new GitCommandOption[] {
					new GitCommandOption("-", "-", @"Only used with the set-tree command.  Read a list of commits from stdin and commit them in reverse order.  Only the leading sha1 is read from each line, so git rev-list --pretty=oneline output can be used."),
					new GitCommandOption("--add-author-from", "--add-author-from", @"When committing to svn from Git (as part of set-tree or dcommit operations), if the existing log message doesn’t already have a From: or Signed-off-by trailer, append a From: line based on the Git commit’s author string.  If you use this, then --use-log-author will retrieve a valid author string for all commits.  config key: svn.addAuthorFrom"),
					new GitCommandOption("--authors-file", "--authors-file=<filename>", @"Syntax is compatible with the file used by git cvsimport but an empty email address can be supplied with <>:           loginname = Joe User <user@example.com>    If this option is specified and git svn encounters an SVN committer name that does not exist in the authors-file, git svn will abort operation. The user will then have to add the appropriate entry.  Re-running the previous git svn command after the authors-file is modified should continue operation.   config key: svn.authorsfile"),
					new GitCommandOption("--authors-prog", "--authors-prog=<filename>", @"If this option is specified, for each SVN committer name that does not exist in the authors file, the given file is executed with the committer name as the first argument.  The program is expected to return a single line of the form ""Name <email>"" or ""Name <>"", which will be treated as if included in the authors file.  Due to historical reasons a relative filename is first searched relative to the current directory for init and clone and relative to the root of the working tree for fetch. If filename is not found, it is searched like any other command in $PATH.   config key: svn.authorsProg"),
					new GitCommandOption("--dry-run", "--dry-run", @"This can be used with the dcommit, rebase, branch and tag commands.  For dcommit, print out the series of Git arguments that would show which diffs would be committed to SVN.   For rebase, display the local branch associated with the upstream svn repository associated with the current branch and the URL of svn repository that will be fetched from.   For branch and tag, display the urls that will be used for copying when creating the branch or tag."),
					new GitCommandOption("--edit", "--edit", @"Only used with the dcommit, set-tree and commit-diff commands.  Edit the commit message before committing to SVN.  This is off by default for objects that are commits, and forced on when committing tree objects.   config key: svn.edit"),
					new GitCommandOption("--find-copies-harder", "--find-copies-harder", @"Only used with the dcommit, set-tree and commit-diff commands.  They are both passed directly to git diff-tree; see git-diff-tree for more information.   config key: svn.l config key: svn.findcopiesharder"),
					new GitCommandOption("--merge", "--merge", @"These are only used with the dcommit and rebase commands.  Passed directly to git rebase when using dcommit if a git reset cannot be used (see dcommit)."),
					new GitCommandOption("--quiet", "--quiet", @"Make git svn less verbose. Specify a second time to make it even less verbose."),
					new GitCommandOption("--rebase-merges", "--rebase-merges", @"These are only used with the dcommit and rebase commands.  Passed directly to git rebase when using dcommit if a git reset cannot be used (see dcommit)."),
					new GitCommandOption("--revision", "--revision <arg>", @"Used with the fetch command.  This allows revision ranges for partial/cauterized history to be supported.  $NUMBER, $NUMBER1:$NUMBER2 (numeric ranges), $NUMBER:HEAD, and BASE:$NUMBER are all supported.   This can allow you to make partial mirrors when running fetch; but is generally not recommended because history will be skipped and lost."),
					new GitCommandOption("--rmdir", "--rmdir", @"Only used with the dcommit, set-tree and commit-diff commands.  Remove directories from the SVN tree if there are no files left behind.  SVN can version empty directories, and they are not removed by default if there are no files left in them.  Git cannot version empty directories.  Enabling this flag will make the commit to SVN act like Git.   config key: svn.rmdir"),
					new GitCommandOption("--shared[", "--shared[=(false|true|umask|group|all|world|everybody)]", @"Only used with the init command. These are passed directly to git init."),
					new GitCommandOption("--stdin", "--stdin", @"Only used with the set-tree command.  Read a list of commits from stdin and commit them in reverse order.  Only the leading sha1 is read from each line, so git rev-list --pretty=oneline output can be used."),
					new GitCommandOption("--strategy", "--strategy=<strategy>", @"These are only used with the dcommit and rebase commands.  Passed directly to git rebase when using dcommit if a git reset cannot be used (see dcommit)."),
					new GitCommandOption("--template", "--template=<template-directory>", @"Only used with the init command. These are passed directly to git init."),
					new GitCommandOption("--use-log-author", "--use-log-author", @"When retrieving svn commits into Git (as part of fetch, rebase, or dcommit operations), look for the first From: line or Signed-off-by trailer in the log message and use that as the author string.  config key: svn.useLogAuthor"),
					new GitCommandOption("-A<filename>", "-A<filename>", @"Syntax is compatible with the file used by git cvsimport but an empty email address can be supplied with <>:           loginname = Joe User <user@example.com>    If this option is specified and git svn encounters an SVN committer name that does not exist in the authors-file, git svn will abort operation. The user will then have to add the appropriate entry.  Re-running the previous git svn command after the authors-file is modified should continue operation.   config key: svn.authorsfile"),
					new GitCommandOption("-e", "-e", @"Only used with the dcommit, set-tree and commit-diff commands.  Edit the commit message before committing to SVN.  This is off by default for objects that are commits, and forced on when committing tree objects.   config key: svn.edit"),
					new GitCommandOption("-l<num>", "-l<num>", @"Only used with the dcommit, set-tree and commit-diff commands.  They are both passed directly to git diff-tree; see git-diff-tree for more information.   config key: svn.l config key: svn.findcopiesharder"),
					new GitCommandOption("-m", "-m", @"These are only used with the dcommit and rebase commands.  Passed directly to git rebase when using dcommit if a git reset cannot be used (see dcommit)."),
					new GitCommandOption("-n", "-n", @"This can be used with the dcommit, rebase, branch and tag commands.  For dcommit, print out the series of Git arguments that would show which diffs would be committed to SVN.   For rebase, display the local branch associated with the upstream svn repository associated with the current branch and the URL of svn repository that will be fetched from.   For branch and tag, display the urls that will be used for copying when creating the branch or tag."),
					new GitCommandOption("-p", "-p", @"These are only used with the dcommit and rebase commands.  Passed directly to git rebase when using dcommit if a git reset cannot be used (see dcommit)."),
					new GitCommandOption("-q", "-q", @"Make git svn less verbose. Specify a second time to make it even less verbose."),
					new GitCommandOption("-r", "-r <arg>", @"Used with the fetch command.  This allows revision ranges for partial/cauterized history to be supported.  $NUMBER, $NUMBER1:$NUMBER2 (numeric ranges), $NUMBER:HEAD, and BASE:$NUMBER are all supported.   This can allow you to make partial mirrors when running fetch; but is generally not recommended because history will be skipped and lost."),
					new GitCommandOption("-s<strategy>", "-s<strategy>", @"These are only used with the dcommit and rebase commands.  Passed directly to git rebase when using dcommit if a git reset cannot be used (see dcommit)."),
				}, 
	"switch" => new GitCommandOption[] {
					new GitCommandOption("<branch>", "<branch>", @"Branch to switch to."),
					new GitCommandOption("<new-branch>", "<new-branch>", @"Name for the new branch."),
					new GitCommandOption("<start-point>", "<start-point>", @"The starting point for the new branch. Specifying a <start-point> allows you to create a branch based on some other point in history than where HEAD currently points. (Or, in the case of --detach, allows you to inspect and detach from some other point.)  You can use the @{-N} syntax to refer to the N-th last branch/commit switched to using ""git switch"" or ""git checkout"" operation. You may also specify - which is synonymous to @{-1}. This is often used to switch quickly between two branches, or to undo a branch switch by mistake.   As a special case, you may use A...B as a shortcut for the merge base of A and B if there is exactly one merge base. You can leave out at most one of A and B, in which case it defaults to HEAD."),
					new GitCommandOption("--conflict", "--conflict=<style>", @"The same as --merge option above, but changes the way the conflicting hunks are presented, overriding the merge.conflictStyle configuration variable.  Possible values are ""merge"" (default), ""diff3"", and ""zdiff3""."),
					new GitCommandOption("--create", "--create <new-branch>", @"Create a new branch named <new-branch> starting at <start-point> before switching to the branch. This is a convenient shortcut for:   $ git branch <new-branch> $ git switch <new-branch>"),
					new GitCommandOption("--detach", "--detach", @"Switch to a commit for inspection and discardable experiments. See the ""DETACHED HEAD"" section in git-checkout for details."),
					new GitCommandOption("--discard-changes", "--discard-changes", @"Proceed even if the index or the working tree differs from HEAD. Both the index and working tree are restored to match the switching target. If --recurse-submodules is specified, submodule content is also restored to match the switching target. This is used to throw away local changes."),
					new GitCommandOption("--force", "--force", @"An alias for --discard-changes."),
					new GitCommandOption("--force-create", "--force-create <new-branch>", @"Similar to --create except that if <new-branch> already exists, it will be reset to <start-point>. This is a convenient shortcut for:   $ git branch -f <new-branch> $ git switch <new-branch>"),
					new GitCommandOption("--guess", "--guess", @"If <branch> is not found but there does exist a tracking branch in exactly one remote (call it <remote>) with a matching name, treat as equivalent to   $ git switch -c <branch> --track <remote>/<branch>    If the branch exists in multiple remotes and one of them is named by the checkout.defaultRemote configuration variable, we’ll use that one for the purposes of disambiguation, even if the <branch> isn’t unique across all remotes. Set it to e.g. checkout.defaultRemote=origin to always checkout remote branches from there if <branch> is ambiguous but exists on the origin remote. See also checkout.defaultRemote in git-config.   --guess is the default behavior. Use --no-guess to disable it.   The default behavior can be set via the checkout.guess configuration variable."),
					new GitCommandOption("--ignore-other-worktrees", "--ignore-other-worktrees", @"git switch refuses when the wanted ref is already checked out by another worktree. This option makes it check the ref out anyway. In other words, the ref can be held by more than one worktree."),
					new GitCommandOption("--merge", "--merge", @"If you have local modifications to one or more files that are different between the current branch and the branch to which you are switching, the command refuses to switch branches in order to preserve your modifications in context.  However, with this option, a three-way merge between the current branch, your working tree contents, and the new branch is done, and you will be on the new branch.  When a merge conflict happens, the index entries for conflicting paths are left unmerged, and you need to resolve the conflicts and mark the resolved paths with git add (or git rm if the merge should result in deletion of the path)."),
					new GitCommandOption("--no-guess", "--no-guess", @"If <branch> is not found but there does exist a tracking branch in exactly one remote (call it <remote>) with a matching name, treat as equivalent to   $ git switch -c <branch> --track <remote>/<branch>    If the branch exists in multiple remotes and one of them is named by the checkout.defaultRemote configuration variable, we’ll use that one for the purposes of disambiguation, even if the <branch> isn’t unique across all remotes. Set it to e.g. checkout.defaultRemote=origin to always checkout remote branches from there if <branch> is ambiguous but exists on the origin remote. See also checkout.defaultRemote in git-config.   --guess is the default behavior. Use --no-guess to disable it.   The default behavior can be set via the checkout.guess configuration variable."),
					new GitCommandOption("--no-progress", "--no-progress", @"Progress status is reported on the standard error stream by default when it is attached to a terminal, unless --quiet is specified. This flag enables progress reporting even if not attached to a terminal, regardless of --quiet."),
					new GitCommandOption("--no-recurse-submodules", "--no-recurse-submodules", @"Using --recurse-submodules will update the content of all active submodules according to the commit recorded in the superproject. If nothing (or --no-recurse-submodules) is used, submodules working trees will not be updated. Just like git-submodule, this will detach HEAD of the submodules."),
					new GitCommandOption("--no-track", "--no-track", @"Do not set up ""upstream"" configuration, even if the branch.autoSetupMerge configuration variable is true."),
					new GitCommandOption("--orphan", "--orphan <new-branch>", @"Create a new orphan branch, named <new-branch>. All tracked files are removed."),
					new GitCommandOption("--progress", "--progress", @"Progress status is reported on the standard error stream by default when it is attached to a terminal, unless --quiet is specified. This flag enables progress reporting even if not attached to a terminal, regardless of --quiet."),
					new GitCommandOption("--quiet", "--quiet", @"Quiet, suppress feedback messages."),
					new GitCommandOption("--recurse-submodules", "--recurse-submodules", @"Using --recurse-submodules will update the content of all active submodules according to the commit recorded in the superproject. If nothing (or --no-recurse-submodules) is used, submodules working trees will not be updated. Just like git-submodule, this will detach HEAD of the submodules."),
					new GitCommandOption("--track", "--track [direct|inherit]", @"When creating a new branch, set up ""upstream"" configuration. -c is implied. See --track in git-branch for details.  If no -c option is given, the name of the new branch will be derived from the remote-tracking branch, by looking at the local part of the refspec configured for the corresponding remote, and then stripping the initial part up to the ""*"".  This would tell us to use hack as the local branch when branching off of origin/hack (or remotes/origin/hack, or even refs/remotes/origin/hack).  If the given name has no slash, or the above guessing results in an empty name, the guessing is aborted.  You can explicitly give a name with -c in such a case."),
					new GitCommandOption("-C", "-C <new-branch>", @"Similar to --create except that if <new-branch> already exists, it will be reset to <start-point>. This is a convenient shortcut for:   $ git branch -f <new-branch> $ git switch <new-branch>"),
					new GitCommandOption("-c", "-c <new-branch>", @"Create a new branch named <new-branch> starting at <start-point> before switching to the branch. This is a convenient shortcut for:   $ git branch <new-branch> $ git switch <new-branch>"),
					new GitCommandOption("-d", "-d", @"Switch to a commit for inspection and discardable experiments. See the ""DETACHED HEAD"" section in git-checkout for details."),
					new GitCommandOption("-f", "-f", @"An alias for --discard-changes."),
					new GitCommandOption("-m", "-m", @"If you have local modifications to one or more files that are different between the current branch and the branch to which you are switching, the command refuses to switch branches in order to preserve your modifications in context.  However, with this option, a three-way merge between the current branch, your working tree contents, and the new branch is done, and you will be on the new branch.  When a merge conflict happens, the index entries for conflicting paths are left unmerged, and you need to resolve the conflicts and mark the resolved paths with git add (or git rm if the merge should result in deletion of the path)."),
					new GitCommandOption("-q", "-q", @"Quiet, suppress feedback messages."),
					new GitCommandOption("-t", "-t", @"When creating a new branch, set up ""upstream"" configuration. -c is implied. See --track in git-branch for details.  If no -c option is given, the name of the new branch will be derived from the remote-tracking branch, by looking at the local part of the refspec configured for the corresponding remote, and then stripping the initial part up to the ""*"".  This would tell us to use hack as the local branch when branching off of origin/hack (or remotes/origin/hack, or even refs/remotes/origin/hack).  If the given name has no slash, or the above guessing results in an empty name, the guessing is aborted.  You can explicitly give a name with -c in such a case."),
				}, 
	"symbolic-ref" => new GitCommandOption[] {
					new GitCommandOption("--delete", "--delete", @"Delete the symbolic ref <name>."),
					new GitCommandOption("--quiet", "--quiet", @"Do not issue an error message if the <name> is not a symbolic ref but a detached HEAD; instead exit with non-zero status silently."),
					new GitCommandOption("--short", "--short", @"When showing the value of <name> as a symbolic ref, try to shorten the value, e.g. from refs/heads/master to master."),
					new GitCommandOption("-d", "-d", @"Delete the symbolic ref <name>."),
					new GitCommandOption("-m", "-m", @"Update the reflog for <name> with <reason>.  This is valid only when creating or updating a symbolic ref."),
					new GitCommandOption("-q", "-q", @"Do not issue an error message if the <name> is not a symbolic ref but a detached HEAD; instead exit with non-zero status silently."),
				}, 
	"tag" => new GitCommandOption[] {
					new GitCommandOption("<commit>", "<commit>", @"The object that the new tag will refer to, usually a commit. Defaults to HEAD."),
					new GitCommandOption("<object>", "<object>", @"The object that the new tag will refer to, usually a commit. Defaults to HEAD."),
					new GitCommandOption("<tagname>", "<tagname>", @"The name of the tag to create, delete, or describe. The new tag name must pass all checks defined by git-check-ref-format.  Some of these checks may restrict the characters allowed in a tag name."),
					new GitCommandOption("--annotate", "--annotate", @"Make an unsigned, annotated tag object"),
					new GitCommandOption("--cleanup", "--cleanup=<mode>", @"This option sets how the tag message is cleaned up. The  <mode> can be one of verbatim, whitespace and strip.  The strip mode is default. The verbatim mode does not change message at all, whitespace removes just leading/trailing whitespace lines and strip removes both whitespace and commentary."),
					new GitCommandOption("--color[", "--color[=<when>]", @"Respect any colors specified in the --format option. The <when> field must be one of always, never, or auto (if <when> is absent, behave as if always was given)."),
					new GitCommandOption("--column[", "--column[=<options>]", @"Display tag listing in columns. See configuration variable column.tag for option syntax. --column and --no-column without options are equivalent to always and never respectively.  This option is only applicable when listing tags without annotation lines."),
					new GitCommandOption("--contains", "--contains [<commit>]", @"Only list tags which contain the specified commit (HEAD if not specified). Implies --list."),
					new GitCommandOption("--create-reflog", "--create-reflog", @"Create a reflog for the tag. To globally enable reflogs for tags, see core.logAllRefUpdates in git-config. The negated form --no-create-reflog only overrides an earlier --create-reflog, but currently does not negate the setting of core.logAllRefUpdates."),
					new GitCommandOption("--delete", "--delete", @"Delete existing tags with the given names."),
					new GitCommandOption("--edit", "--edit", @"The message taken from file with -F and command line with -m are usually used as the tag message unmodified. This option lets you further edit the message taken from these sources."),
					new GitCommandOption("--file", "--file=<file>", @"Take the tag message from the given file.  Use - to read the message from the standard input. Implies -a if none of -a, -s, or -u <keyid> is given."),
					new GitCommandOption("--force", "--force", @"Replace an existing tag with the given name (instead of failing)"),
					new GitCommandOption("--format", "--format=<format>", @"A string that interpolates %(fieldname) from a tag ref being shown and the object it points at.  The format is the same as that of git-for-each-ref.  When unspecified, defaults to %(refname:strip=2)."),
					new GitCommandOption("--ignore-case", "--ignore-case", @"Sorting and filtering tags are case insensitive."),
					new GitCommandOption("--list", "--list", @"List tags. With optional <pattern>..., e.g. git tag --list 'v-*', list only the tags that match the pattern(s).  Running ""git tag"" without arguments also lists all tags. The pattern is a shell wildcard (i.e., matched using fnmatch). Multiple patterns may be given; if any of them matches, the tag is shown.   This option is implicitly supplied if any other list-like option such as --contains is provided. See the documentation for each of those options for details."),
					new GitCommandOption("--local-user", "--local-user=<keyid>", @"Make a GPG-signed tag, using the given key."),
					new GitCommandOption("--merged", "--merged [<commit>]", @"Only list tags whose commits are reachable from the specified commit (HEAD if not specified)."),
					new GitCommandOption("--message", "--message=<msg>", @"Use the given tag message (instead of prompting). If multiple -m options are given, their values are concatenated as separate paragraphs. Implies -a if none of -a, -s, or -u <keyid> is given."),
					new GitCommandOption("--no-column", "--no-column", @"Display tag listing in columns. See configuration variable column.tag for option syntax. --column and --no-column without options are equivalent to always and never respectively.  This option is only applicable when listing tags without annotation lines."),
					new GitCommandOption("--no-contains", "--no-contains [<commit>]", @"Only list tags which don’t contain the specified commit (HEAD if not specified). Implies --list."),
					new GitCommandOption("--no-merged", "--no-merged [<commit>]", @"Only list tags whose commits are not reachable from the specified commit (HEAD if not specified)."),
					new GitCommandOption("--no-sign", "--no-sign", @"Override tag.gpgSign configuration variable that is set to force each and every tag to be signed."),
					new GitCommandOption("--points-at", "--points-at <object>", @"Only list tags of the given object (HEAD if not specified). Implies --list."),
					new GitCommandOption("--sign", "--sign", @"Make a GPG-signed tag, using the default e-mail address’s key. The default behavior of tag GPG-signing is controlled by tag.gpgSign configuration variable if it exists, or disabled otherwise. See git-config."),
					new GitCommandOption("--sort", "--sort=<key>", @"Sort based on the key given.  Prefix - to sort in descending order of the value. You may use the --sort=<key> option multiple times, in which case the last key becomes the primary key. Also supports ""version:refname"" or ""v:refname"" (tag names are treated as versions). The ""version:refname"" sort order can also be affected by the ""versionsort.suffix"" configuration variable. The keys supported are the same as those in git for-each-ref. Sort order defaults to the value configured for the tag.sort variable if it exists, or lexicographic order otherwise. See git-config."),
					new GitCommandOption("--verify", "--verify", @"Verify the GPG signature of the given tag names."),
					new GitCommandOption("-a", "-a", @"Make an unsigned, annotated tag object"),
					new GitCommandOption("-d", "-d", @"Delete existing tags with the given names."),
					new GitCommandOption("-e", "-e", @"The message taken from file with -F and command line with -m are usually used as the tag message unmodified. This option lets you further edit the message taken from these sources."),
					new GitCommandOption("-F", "-F <file>", @"Take the tag message from the given file.  Use - to read the message from the standard input. Implies -a if none of -a, -s, or -u <keyid> is given."),
					new GitCommandOption("-f", "-f", @"Replace an existing tag with the given name (instead of failing)"),
					new GitCommandOption("-i", "-i", @"Sorting and filtering tags are case insensitive."),
					new GitCommandOption("-l", "-l", @"List tags. With optional <pattern>..., e.g. git tag --list 'v-*', list only the tags that match the pattern(s).  Running ""git tag"" without arguments also lists all tags. The pattern is a shell wildcard (i.e., matched using fnmatch). Multiple patterns may be given; if any of them matches, the tag is shown.   This option is implicitly supplied if any other list-like option such as --contains is provided. See the documentation for each of those options for details."),
					new GitCommandOption("-m", "-m <msg>", @"Use the given tag message (instead of prompting). If multiple -m options are given, their values are concatenated as separate paragraphs. Implies -a if none of -a, -s, or -u <keyid> is given."),
					new GitCommandOption("-n<num>", "-n<num>", @"<num> specifies how many lines from the annotation, if any, are printed when using -l. Implies --list.  The default is not to print any annotation lines. If no number is given to -n, only the first line is printed. If the tag is not annotated, the commit message is displayed instead."),
					new GitCommandOption("-s", "-s", @"Make a GPG-signed tag, using the default e-mail address’s key. The default behavior of tag GPG-signing is controlled by tag.gpgSign configuration variable if it exists, or disabled otherwise. See git-config."),
					new GitCommandOption("-u", "-u <keyid>", @"Make a GPG-signed tag, using the given key."),
					new GitCommandOption("-v", "-v", @"Verify the GPG signature of the given tag names."),
				}, 
	"unpack-file" => new GitCommandOption[] {
					new GitCommandOption("<blob>", "<blob>", @"Must be a blob id"),
				}, 
	"unpack-objects" => new GitCommandOption[] {
					new GitCommandOption("--max-input-size", "--max-input-size=<size>", @"Die, if the pack is larger than <size>."),
					new GitCommandOption("--strict", "--strict", @"Don’t write objects with broken content or links."),
					new GitCommandOption("-n", "-n", @"Dry run.  Check the pack file without actually unpacking the objects."),
					new GitCommandOption("-q", "-q", @"The command usually shows percentage progress.  This flag suppresses it."),
					new GitCommandOption("-r", "-r", @"When unpacking a corrupt packfile, the command dies at the first corruption.  This flag tells it to keep going and make the best effort to recover as many objects as possible."),
				}, 
	"update-index" => new GitCommandOption[] {
					new GitCommandOption("<file>", "<file>", @"Files to act on. Note that files beginning with . are discarded. This includes ./file and dir/./file. If you don’t want this, then use cleaner names. The same applies to directories ending / and paths with //"),
					new GitCommandOption("--", "--", @"Do not interpret any more arguments as options."),
					new GitCommandOption("--[no-]assume-unchanged", "--[no-]assume-unchanged", @"When this flag is specified, the object names recorded for the paths are not updated.  Instead, this option sets/unsets the ""assume unchanged"" bit for the paths.  When the ""assume unchanged"" bit is on, the user promises not to change the file and allows Git to assume that the working tree file matches what is recorded in the index.  If you want to change the working tree file, you need to unset the bit to tell Git.  This is sometimes helpful when working with a big project on a filesystem that has very slow lstat system call (e.g. cifs).  Git will fail (gracefully) in case it needs to modify this file in the index e.g. when merging in a commit; thus, in case the assumed-untracked file is changed upstream, you will need to handle the situation manually."),
					new GitCommandOption("--[no-]fsmonitor-valid", "--[no-]fsmonitor-valid", @"When one of these flags is specified, the object name recorded for the paths are not updated. Instead, these options set and unset the ""fsmonitor valid"" bit for the paths. See section ""File System Monitor"" below for more information."),
					new GitCommandOption("--[no-]ignore-skip-worktree-entries", "--[no-]ignore-skip-worktree-entries", @"Do not remove skip-worktree (AKA ""index-only"") entries even when the --remove option was specified."),
					new GitCommandOption("--[no-]skip-worktree", "--[no-]skip-worktree", @"When one of these flags is specified, the object name recorded for the paths are not updated. Instead, these options set and unset the ""skip-worktree"" bit for the paths. See section ""Skip-worktree bit"" below for more information."),
					new GitCommandOption("--add", "--add", @"If a specified file isn’t in the index already then it’s added. Default behaviour is to ignore new files."),
					new GitCommandOption("--again", "--again", @"Runs git update-index itself on the paths whose index entries are different from those from the HEAD commit."),
					new GitCommandOption("--cacheinfo", "--cacheinfo <mode>,<object>,<path>", @"Directly insert the specified info into the index.  For backward compatibility, you can also give these three arguments as three separate parameters, but new users are encouraged to use a single-parameter form."),
					new GitCommandOption("--cacheinfo", "--cacheinfo <mode> <object> <path>", @"Directly insert the specified info into the index.  For backward compatibility, you can also give these three arguments as three separate parameters, but new users are encouraged to use a single-parameter form."),
					new GitCommandOption("--chmod", "--chmod=(+|-)x", @"Set the execute permissions on the updated files."),
					new GitCommandOption("--force-remove", "--force-remove", @"Remove the file from the index even when the working directory still has such a file. (Implies --remove.)"),
					new GitCommandOption("--force-untracked-cache", "--force-untracked-cache", @"Same as --untracked-cache. Provided for backwards compatibility with older versions of Git where --untracked-cache used to imply --test-untracked-cache but this option would enable the extension unconditionally."),
					new GitCommandOption("--fsmonitor", "--fsmonitor", @"Enable or disable files system monitor feature. These options take effect whatever the value of the core.fsmonitor configuration variable (see git-config). But a warning is emitted when the change goes against the configured value, as the configured value will take effect next time the index is read and this will remove the intended effect of the option."),
					new GitCommandOption("--ignore-missing", "--ignore-missing", @"Ignores missing files during a --refresh"),
					new GitCommandOption("--ignore-submodules", "--ignore-submodules", @"Do not try to update submodules.  This option is only respected when passed before --refresh."),
					new GitCommandOption("--index-info", "--index-info", @"Read index information from stdin."),
					new GitCommandOption("--index-version", "--index-version <n>", @"Write the resulting index out in the named on-disk format version. Supported versions are 2, 3 and 4. The current default version is 2 or 3, depending on whether extra features are used, such as git add -N.  Version 4 performs a simple pathname compression that reduces index size by 30%-50% on large repositories, which results in faster load time. Version 4 is relatively young (first released in 1.8.0 in October 2012). Other Git implementations such as JGit and libgit2 may not support it yet."),
					new GitCommandOption("--info-only", "--info-only", @"Do not create objects in the object database for all <file> arguments that follow this flag; just insert their object IDs into the index."),
					new GitCommandOption("--no-fsmonitor", "--no-fsmonitor", @"Enable or disable files system monitor feature. These options take effect whatever the value of the core.fsmonitor configuration variable (see git-config). But a warning is emitted when the change goes against the configured value, as the configured value will take effect next time the index is read and this will remove the intended effect of the option."),
					new GitCommandOption("--no-split-index", "--no-split-index", @"Enable or disable split index mode. If split-index mode is already enabled and --split-index is given again, all changes in $GIT_DIR/index are pushed back to the shared index file.  These options take effect whatever the value of the core.splitIndex configuration variable (see git-config). But a warning is emitted when the change goes against the configured value, as the configured value will take effect next time the index is read and this will remove the intended effect of the option."),
					new GitCommandOption("--no-untracked-cache", "--no-untracked-cache", @"Enable or disable untracked cache feature. Please use --test-untracked-cache before enabling it.  These options take effect whatever the value of the core.untrackedCache configuration variable (see git-config). But a warning is emitted when the change goes against the configured value, as the configured value will take effect next time the index is read and this will remove the intended effect of the option."),
					new GitCommandOption("--really-refresh", "--really-refresh", @"Like --refresh, but checks stat information unconditionally, without regard to the ""assume unchanged"" setting."),
					new GitCommandOption("--refresh", "--refresh", @"Looks at the current index and checks to see if merges or updates are needed by checking stat() information."),
					new GitCommandOption("--remove", "--remove", @"If a specified file is in the index but is missing then it’s removed. Default behavior is to ignore removed file."),
					new GitCommandOption("--replace", "--replace", @"By default, when a file path exists in the index, git update-index refuses an attempt to add path/file. Similarly if a file path/file exists, a file path cannot be added.  With --replace flag, existing entries that conflict with the entry being added are automatically removed with warning messages."),
					new GitCommandOption("--split-index", "--split-index", @"Enable or disable split index mode. If split-index mode is already enabled and --split-index is given again, all changes in $GIT_DIR/index are pushed back to the shared index file.  These options take effect whatever the value of the core.splitIndex configuration variable (see git-config). But a warning is emitted when the change goes against the configured value, as the configured value will take effect next time the index is read and this will remove the intended effect of the option."),
					new GitCommandOption("--stdin", "--stdin", @"Instead of taking list of paths from the command line, read list of paths from the standard input.  Paths are separated by LF (i.e. one path per line) by default."),
					new GitCommandOption("--test-untracked-cache", "--test-untracked-cache", @"Only perform tests on the working directory to make sure untracked cache can be used. You have to manually enable untracked cache using --untracked-cache or --force-untracked-cache or the core.untrackedCache configuration variable afterwards if you really want to use it. If a test fails the exit code is 1 and a message explains what is not working as needed, otherwise the exit code is 0 and OK is printed."),
					new GitCommandOption("--unmerged", "--unmerged", @"If --refresh finds unmerged changes in the index, the default behavior is to error out.  This option makes git update-index        continue anyway."),
					new GitCommandOption("--unresolve", "--unresolve", @"Restores the unmerged or needs updating state of a file during a merge if it was cleared by accident."),
					new GitCommandOption("--untracked-cache", "--untracked-cache", @"Enable or disable untracked cache feature. Please use --test-untracked-cache before enabling it.  These options take effect whatever the value of the core.untrackedCache configuration variable (see git-config). But a warning is emitted when the change goes against the configured value, as the configured value will take effect next time the index is read and this will remove the intended effect of the option."),
					new GitCommandOption("--verbose", "--verbose", @"Report what is being added and removed from index."),
					new GitCommandOption("-g", "-g", @"Runs git update-index itself on the paths whose index entries are different from those from the HEAD commit."),
					new GitCommandOption("-q", "-q", @"Quiet.  If --refresh finds that the index needs an update, the        default behavior is to error out.  This option makes git update-index continue anyway."),
					new GitCommandOption("-z", "-z", @"Only meaningful with --stdin or --index-info; paths are separated with NUL character instead of LF."),
				}, 
	"update-ref" => new GitCommandOption[] {
				}, 
	"update-server-info" => new GitCommandOption[] {
				}, 
	"upload-archive" => new GitCommandOption[] {
					new GitCommandOption("<directory>", "<directory>", @"The repository to get a tar archive from."),
				}, 
	"upload-pack" => new GitCommandOption[] {
					new GitCommandOption("<directory>", "<directory>", @"The repository to sync from."),
					new GitCommandOption("--[no-]strict", "--[no-]strict", @"Do not try <directory>/.git/ if <directory> is no Git directory."),
					new GitCommandOption("--http-backend-info-refs", "--http-backend-info-refs", @"Used by git-http-backend to serve up $GIT_URL/info/refs?service=git-upload-pack requests. See ""Smart Clients"" in the HTTP transfer protocols documentation and ""HTTP Transport"" in the Git Wire Protocol, Version 2 documentation. Also understood by git-receive-pack."),
					new GitCommandOption("--stateless-rpc", "--stateless-rpc", @"Perform only a single read-write cycle with stdin and stdout. This fits with the HTTP POST request processing model where a program may read the request, write a response, and must exit."),
					new GitCommandOption("--timeout", "--timeout=<n>", @"Interrupt transfer after <n> seconds of inactivity."),
				}, 
	"var" => new GitCommandOption[] {
					new GitCommandOption("-l", "-l", @"Cause the logical variables to be listed. In addition, all the variables of the Git configuration file .git/config are listed as well. (However, the configuration variables listing functionality is deprecated in favor of git config -l.)"),
				}, 
	"verify-commit" => new GitCommandOption[] {
					new GitCommandOption("<commit>…​", "<commit>…​", @"SHA-1 identifiers of Git commit objects."),
					new GitCommandOption("--raw", "--raw", @"Print the raw gpg status output to standard error instead of the normal human-readable output."),
					new GitCommandOption("--verbose", "--verbose", @"Print the contents of the commit object before validating it."),
					new GitCommandOption("-v", "-v", @"Print the contents of the commit object before validating it."),
				}, 
	"verify-pack" => new GitCommandOption[] {
					new GitCommandOption("<pack>.idx", "<pack>.idx …​", @"The idx files to verify."),
					new GitCommandOption("--", "--", @"Do not interpret any more arguments as options."),
					new GitCommandOption("--stat-only", "--stat-only", @"Do not verify the pack contents; only show the histogram of delta chain length.  With --verbose, list of objects is also shown."),
					new GitCommandOption("--verbose", "--verbose", @"After verifying the pack, show list of objects contained in the pack and a histogram of delta chain length."),
					new GitCommandOption("-s", "-s", @"Do not verify the pack contents; only show the histogram of delta chain length.  With --verbose, list of objects is also shown."),
					new GitCommandOption("-v", "-v", @"After verifying the pack, show list of objects contained in the pack and a histogram of delta chain length."),
				}, 
	"verify-tag" => new GitCommandOption[] {
					new GitCommandOption("<tag>…​", "<tag>…​", @"SHA-1 identifiers of Git tag objects."),
					new GitCommandOption("--raw", "--raw", @"Print the raw gpg status output to standard error instead of the normal human-readable output."),
					new GitCommandOption("--verbose", "--verbose", @"Print the contents of the tag object before validating it."),
					new GitCommandOption("-v", "-v", @"Print the contents of the tag object before validating it."),
				}, 
	"version" => new GitCommandOption[] {
					new GitCommandOption("--build-options", "--build-options", @"Include additional information about how git was built for diagnostic purposes."),
				}, 
	"web--browse" => new GitCommandOption[] {
					new GitCommandOption("--browser", "--browser=<browser>", @"Use the specified browser. It must be in the list of supported browsers."),
					new GitCommandOption("--config", "--config=<conf.var>", @"CONF.VAR is looked up in the Git config files. If it’s set, then its value specifies the browser that should be used."),
					new GitCommandOption("--tool", "--tool=<browser>", @"Same as above."),
					new GitCommandOption("-b", "-b <browser>", @"Use the specified browser. It must be in the list of supported browsers."),
					new GitCommandOption("-c", "-c <conf.var>", @"CONF.VAR is looked up in the Git config files. If it’s set, then its value specifies the browser that should be used."),
					new GitCommandOption("-t", "-t <browser>", @"Same as above."),
				}, 
	"whatchanged" => new GitCommandOption[] {
				}, 
	"worktree" => new GitCommandOption[] {
					new GitCommandOption("<worktree>", "<worktree>", @"Worktrees can be identified by path, either relative or absolute.  If the last path components in the worktree’s path is unique among worktrees, it can be used to identify a worktree. For example if you only have two worktrees, at /abc/def/ghi and /abc/def/ggg, then ghi or def/ghi is enough to point to the former worktree."),
					new GitCommandOption("--[no-]checkout", "--[no-]checkout", @"By default, add checks out <commit-ish>, however, --no-checkout can be used to suppress checkout in order to make customizations, such as configuring sparse-checkout. See ""Sparse checkout"" in git-read-tree."),
					new GitCommandOption("--[no-]guess-remote", "--[no-]guess-remote", @"With worktree add <path>, without <commit-ish>, instead of creating a new branch from HEAD, if there exists a tracking branch in exactly one remote matching the basename of <path>, base the new branch on the remote-tracking branch, and mark the remote-tracking branch as ""upstream"" from the new branch.  This can also be set up as the default behaviour by using the worktree.guessRemote config option."),
					new GitCommandOption("--[no-]track", "--[no-]track", @"When creating a new branch, if <commit-ish> is a branch, mark it as ""upstream"" from the new branch.  This is the default if <commit-ish> is a remote-tracking branch.  See --track in git-branch for details."),
					new GitCommandOption("--detach", "--detach", @"With add, detach HEAD in the new worktree. See ""DETACHED HEAD"" in git-checkout."),
					new GitCommandOption("--dry-run", "--dry-run", @"With prune, do not remove anything; just report what it would remove."),
					new GitCommandOption("--expire", "--expire <time>", @"With prune, only expire unused worktrees older than <time>.  With list, annotate missing worktrees as prunable if they are older than <time>."),
					new GitCommandOption("--force", "--force", @"By default, add refuses to create a new worktree when <commit-ish> is a branch name and is already checked out by another worktree, or if <path> is already assigned to some worktree but is missing (for instance, if <path> was deleted manually). This option overrides these safeguards. To add a missing but locked worktree path, specify --force twice.  move refuses to move a locked worktree unless --force is specified twice. If the destination is already assigned to some other worktree but is missing (for instance, if <new-path> was deleted manually), then --force allows the move to proceed; use --force twice if the destination is locked.   remove refuses to remove an unclean worktree unless --force is used. To remove a locked worktree, specify --force twice."),
					new GitCommandOption("--lock", "--lock", @"Keep the worktree locked after creation. This is the equivalent of git worktree lock after git worktree add, but without a race condition."),
					new GitCommandOption("--porcelain", "--porcelain", @"With list, output in an easy-to-parse format for scripts. This format will remain stable across Git versions and regardless of user configuration.  It is recommended to combine this with -z. See below for details."),
					new GitCommandOption("--quiet", "--quiet", @"With add, suppress feedback messages."),
					new GitCommandOption("--reason", "--reason <string>", @"With lock or with add --lock, an explanation why the worktree is locked."),
					new GitCommandOption("--verbose", "--verbose", @"With prune, report all removals.  With list, output additional information about worktrees (see below)."),
					new GitCommandOption("-b", "-b <new-branch>", @"With add, create a new branch named <new-branch> starting at <commit-ish>, and check out <new-branch> into the new worktree. If <commit-ish> is omitted, it defaults to HEAD. By default, -b refuses to create a new branch if it already exists. -B overrides this safeguard, resetting <new-branch> to <commit-ish>."),
					new GitCommandOption("-B", "-B <new-branch>", @"With add, create a new branch named <new-branch> starting at <commit-ish>, and check out <new-branch> into the new worktree. If <commit-ish> is omitted, it defaults to HEAD. By default, -b refuses to create a new branch if it already exists. -B overrides this safeguard, resetting <new-branch> to <commit-ish>."),
					new GitCommandOption("-d", "-d", @"With add, detach HEAD in the new worktree. See ""DETACHED HEAD"" in git-checkout."),
					new GitCommandOption("-f", "-f", @"By default, add refuses to create a new worktree when <commit-ish> is a branch name and is already checked out by another worktree, or if <path> is already assigned to some worktree but is missing (for instance, if <path> was deleted manually). This option overrides these safeguards. To add a missing but locked worktree path, specify --force twice.  move refuses to move a locked worktree unless --force is specified twice. If the destination is already assigned to some other worktree but is missing (for instance, if <new-path> was deleted manually), then --force allows the move to proceed; use --force twice if the destination is locked.   remove refuses to remove an unclean worktree unless --force is used. To remove a locked worktree, specify --force twice."),
					new GitCommandOption("-n", "-n", @"With prune, do not remove anything; just report what it would remove."),
					new GitCommandOption("-q", "-q", @"With add, suppress feedback messages."),
					new GitCommandOption("-v", "-v", @"With prune, report all removals.  With list, output additional information about worktrees (see below)."),
					new GitCommandOption("-z", "-z", @"Terminate each line with a NUL rather than a newline when --porcelain is specified with list. This makes it possible to parse the output when a worktree path contains a newline character."),
				}, 
	"write-tree" => new GitCommandOption[] {
					new GitCommandOption("--missing-ok", "--missing-ok", @"Normally git write-tree ensures that the objects referenced by the directory exist in the object database.  This option disables this check."),
					new GitCommandOption("--prefix", "--prefix=<prefix>/", @"Writes a tree object that represents a subdirectory <prefix>.  This can be used to write the tree object for a subproject that is in the named subdirectory."),
				}, 
                _ => resolveAliases ? TryGetOptionsFromAlias(name) : System.Array.Empty<GitCommandOption>()

            };
        }

        private static GitCommandOption[] TryGetOptionsFromAlias(string name) {
            var aliases = Git.GetAliases(name).ToArray();
            if (aliases.Length != 1) {
                return Array.Empty<GitCommandOption>();
            }

            var (alias, command, _) = aliases[0];
            return alias != name ? Array.Empty<GitCommandOption>() : GetOptions(command, false);
        }
    }
}

